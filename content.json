{"meta":{"title":"太阳以西？","subtitle":"太阳以西有些什么？","description":"专注 WEB 开发的技术博客","author":"xyc","url":"http://javacoderx.github.io","root":"/"},"pages":[{"title":"","date":"2021-04-22T12:33:48.143Z","updated":"2021-04-22T12:33:48.143Z","comments":true,"path":"about/index.html","permalink":"http://javacoderx.github.io/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 PHP，熟悉使用 Laravel、ThinkPHP 等主流框架；对 Modern PHP 情有独钟；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：深圳 关于学习正在往终身学习者前进…近期学习方向：Python (人工智能) 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱羽毛球、阅读、电影（Top250）、旅行。 联系我 Home: minhow.com Blog: blog.minhow.com Email: &#x68;&#117;&#x61;&#x6e;&#103;&#109;&#105;&#x6e;&#104;&#111;&#x77;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109; GitHub: MinHow WeiBo: MinHow Twitter: MinHow"}],"posts":[{"title":"springboot零基础入门篇","slug":"springboot","date":"2021-04-23T16:53:11.000Z","updated":"2021-04-23T09:13:12.484Z","comments":true,"path":"2021/04/24/springboot/","link":"","permalink":"http://javacoderx.github.io/2021/04/24/springboot/","excerpt":"","text":"一、SpringBoot入门1.1、springboot 简介 springboot是什么？ 简化Spring应用开发的框架，spring技术栈的整合，J2EE开发的一站式解决方案 优点： 为所有spring开发者快速入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 1.2、微服务 是一种架构风格（服务微化） 要求在开发一个应用的时候，这个应用必须构建成一系列小服务的组合； 可以通过http的方式进行互通 单体应用 每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 1.3、快速开始 使用Spring Initializr创建一个springboot应用 创建一个主程序类，启动SpringBoot应用 编写Helloworld的Controller （在主程序类的同级目录下创建一个controller包，在其中写Controller类） 运行主程序 简化部署 123456789&lt;!‐‐ 这个插件，可以将应用打包成一个可执行的jar包；‐‐&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐maven‐plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 彩蛋 到项目下的 resources 目录下新建一个banner.txt文件就可以，将启动时显示的字符更改为自己想要的 12345678910111213141516171819202122 /\\/\\/\\ / \\ | \\ / | / \\ | \\/ | / \\ | /\\ |----------------------| /\\ | | / \\ | | / \\ | |/ \\| | / \\ | |\\ /| | | ( ) | | | \\ / | | | ( ) | | | \\/ | /\\ | | | | /\\ | /\\ | / \\ | | | | / \\ | / \\ | |----| | | | | |----| |/ \\|---------------| | | /| . |\\ | | | |\\ /| | | / | . | \\ | | | \\ / | | / | . | \\ | | \\/ | | / | . | \\ | | /\\ |---------------|/ | . | \\| | / \\ | / NASA | . | NASA \\ |/ \\| ( | | ) |/\\/\\/\\| | | |--| |--| | | ------------------------/ \\-----/ \\/ \\-----/ \\-------- \\\\// \\\\//\\\\// \\\\// \\/ \\/ \\/ \\/ 12345678910111213141516171819202122&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; _ooOoo_ &#x2F;&#x2F;&#x2F;&#x2F; o8888888o &#x2F;&#x2F;&#x2F;&#x2F; 88&quot; . &quot;88 &#x2F;&#x2F;&#x2F;&#x2F; (| ^_^ |) &#x2F;&#x2F;&#x2F;&#x2F; O\\ &#x3D; &#x2F;O &#x2F;&#x2F;&#x2F;&#x2F; ____&#x2F;&#96;---&#39;\\____ &#x2F;&#x2F;&#x2F;&#x2F; .&#39; \\\\| |&#x2F;&#x2F; &#96;. &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; \\\\||| : |||&#x2F;&#x2F; \\ &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; _||||| -:- |||||- \\ &#x2F;&#x2F;&#x2F;&#x2F; | | \\\\\\ - &#x2F;&#x2F;&#x2F; | | &#x2F;&#x2F;&#x2F;&#x2F; | \\_| &#39;&#39;\\---&#x2F;&#39;&#39; | | &#x2F;&#x2F;&#x2F;&#x2F; \\ .-\\__ &#96;-&#96; ___&#x2F;-. &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; ___&#96;. .&#39; &#x2F;--.--\\ &#96;. . ___ &#x2F;&#x2F;&#x2F;&#x2F; .&quot;&quot; &#39;&lt; &#96;.___\\_&lt;|&gt;_&#x2F;___.&#39; &gt;&#39;&quot;&quot;. &#x2F;&#x2F;&#x2F;&#x2F; | | : &#96;- \\&#96;.;&#96;\\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | | &#x2F;&#x2F;&#x2F;&#x2F; \\ \\ &#96;-. \\_ __\\ &#x2F;__ _&#x2F; .-&#96; &#x2F; &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;&#x2F;&#x2F; &#96;&#x3D;---&#x3D;&#39; &#x2F;&#x2F;&#x2F;&#x2F; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &#x2F;&#x2F;&#x2F;&#x2F; 佛祖保佑 永不宕机 永无BUG &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 二、自动装配原理2.1、POM文件分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--parent部分 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!--项目元数据信息部分--&gt; &lt;groupId&gt;com.xyc&lt;/groupId&gt; &lt;artifactId&gt;springboot-web&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-web&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!--dependencies部分 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--build部分 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 如上所示：POM文件分为四部分 项目元数据信息 ：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括：groupId、artifactId、version、name、description等 parent：继承spring-boot-starter-parent的依赖管理，控制版本与打包等内容 dependencies：项目具体依赖，这里包含了spring-boot-starter-web用于实现HTTP接口（该依赖中包含了Spring MVC），官网对它的描述是：使用Spring MVC构建Web（包括RESTful）应用程序的入门者，使用Tomcat作为默认嵌入式容器。；spring-boot-starter-test用于编写单元测试的依赖包。更多功能模块的使用我们将在后面逐步展开。 build：构建配置部分。默认使用了spring-boot-maven-plugin，配合spring-boot-starter-parent就可以把Spring Boot应用打包成JAR来直接运行。 我们的程序要想运行主要依赖一个父项目 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; Ctrl+鼠标左键 进入父项目 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt; 在这里定义着Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2.2、启动器12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;&lt;/dependency&gt; springboot-boot-starter：就是spring-boot的场景启动器 **spring-boot-starter-web **帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2.3、主程序类12345678910//@SpringBootApplication 来标注一个主程序类 ， 说明这是一个Spring Boot应用@SpringBootApplicationpublic class Springboot01HelloworldApplication &#123; public static void main(String[] args) &#123; //将SpringBoot应用启动起来 SpringApplication.run(Springboot01HelloworldApplication.class, args); &#125;&#125; 1. @SpringBootApplication 注解：来标注一个主程序类 ， 说明这是一个Spring Boot应用,在该类的main方法启动springboot应用 进入这个注解 ： 1234567891011121314151617@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; 2. @ComponentScan 注解 这个注解在Spring中很重要 ， 它对应XML配置中的元素。 @ComponentScan的功能就是自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 ； 3. @SpringBootConfiguration 注解: Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类； 进入这个注解 ： 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123; @Configuration:配置类上来标注这个注解，说明这是一个配置类。 配置类 &lt;--&gt; 配置文件； 进入这个注解： 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @Component :配置类也是容器中的一个组件；说明启动类也是容器的一个组件 4. @EnableAutoConfiguration： 开启自动配置功能； 以前我们需要配置的东西，Spring Boot帮我们自动配置； 进入这个注解： 12345678@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @import ：Spring底层注解 ， 给容器中导入一个组件 AutoConfigurationImportSelector.class： 自动配置导入选择器， 那么它会导入哪些组件的选择器呢？ 点击进入该类查看源码即可。 @AutoConfigurationPackage ： 自动配置包 进入这个注解： 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123; @import ：Spring底层注解 ， 给容器中导入一个组件 Registrar.class 将主配置类 【即@SpringBootApplication标注的类】的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； 自动配置真正实现是从classpath中搜寻所有的METINF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 结论： SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作； 以前我们需要自己配置的东西 ， 自动配置类都帮我们解决了 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中； 它将所有需要导入的组件以全类名的方式返回 ， 这些组件就会被添加到容器中 ； 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ； 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； 2.4、Run开启一个服务 1234567891011@SpringBootApplicationpublic class SpringbootDemo02Application &#123; public static void main(String[] args) &#123; //该方法返回一个ConfigurableApplicationContext对象 //参数一：应用入口的类 参数类：命令行参数 SpringApplication.run(SpringbootDemo02Application.class, args); &#125;&#125; SpringApplication.run分析 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； 2.5、SpringApplication这个类主要做了以下四件事情 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 三、配置文件3.1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； application.properties application.yml 作用：修改SpringBoot自动配置的默认值； （我们在配置文件中做的修改，SpringBoot在底层都给我们自动配置好） 3.2、yaml 是一种标记语言，不是一种标记语言。 语法：key:(空格)value 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级 12server: port: 8081 对象： 123456friends: lastName: zhangsan age: 20 行内写法： friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）： 1234567animals: - dog - cat - pid行内写法：animals: [cat,dog,pid] 3.3、配置文件占位符1、随机数 123$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值 123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 3.4、配置文件值的注入@Value和@ConfigurationProperties yaml： 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: ‐ lisi ‐ zhaoliu dog: name: 小狗 age: 12 javaBean: 12345678910111213141516171819/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供 * @ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 配置文件处理器 123456&lt;!‐‐导入配置文件处理器，配置文件进行绑定就会有提示‐‐&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐configuration‐ processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; @Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 Profile 多Profile文件 我们在主配置文件编写的时候，文件名可以是 application-&#123;profile&#125;.properties/yml 默认使用application.properties的配置； yml支持多文档块方式 123456789101112131415 server: port: 8081spring: profiles: active: prod‐‐‐server: port: 8083spring: profiles: dev‐‐‐server: port: 8084spring: profiles: prod #指定属于哪个环境 激活指定profile 1、在配置文件中指定 spring.profiles.active=dev 2、命令行： java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev； 可以直接在测试的时候，配置传入命令行参数 3、虚拟机参数； -Dspring.profiles.active=dev 3.5、配置文件的加载位置 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置 3.6、加载指定配置文件@PropertySource： 加载指定的配置文件 1@PropertySource(value &#x3D; &#123;&quot;classpath:person.properties&quot;&#125;) @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； 标注在一个配置类上 1@ImportResource(locations &#x3D; &#123;&quot;classpath:beans.xml&quot;&#125;) SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式1、配置类@Configuration——&gt;Spring配置文件2、使用@Bean给容器中添加组件 123456789101112131415 /** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;); return new HelloService(); &#125;&#125; 四、日志4.1、日志框架市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ==SpringBoot选用 SLF4j和logback；== 4.2、SLF4j使用如何在系统中使用SLF4j https://www.slf4j.org 日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); &#125;&#125; 图示： 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 遗留问题 a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 4.3、日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 2）、SpringBoot也把其他的日志都替换成了slf4j； 3）、中间替换包？ 123456@SuppressWarnings(&quot;rawtypes&quot;)public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = &quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;; static LogFactory logFactory = new SLF4JLogFactory(); 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4.4、日志使用默认设置 可直接使用 123456789101112131415161718//记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(&quot;这是trace日志...&quot;); logger.debug(&quot;这是debug日志...&quot;); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(&quot;这是info日志...&quot;); logger.warn(&quot;这是warn日志...&quot;); logger.error(&quot;这是error日志...&quot;); &#125; springboot修改日志的默认设置 1234567891011121314logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console =%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file =%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n 123456789日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 指定配置 给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 12345&lt;springProfile name=&quot;staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 4.5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 五、Web开发5.1、静态资源映射 所有**/webjars/**** ，都去classpath:/META-INF/resources/webjars/找资源； webjars：以jar包的方式引入静态资源； “/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射 12345&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;resources&#x2F;&quot;,&quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &quot;&#x2F;&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc 欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射； localhost:8080/ 找index页面 所有的 /favicon.ico 都是在静态资源文件下找； 5.2、模板引擎JSP、Velocity、Freemarker、Thymeleaf Springboot推荐Thymelea 引入thymeleaf1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!‐‐切换thymeleaf版本‐‐&gt; &lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!‐‐ 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 ‐‐&gt; &lt;!‐‐ thymeleaf2 layout1‐‐&gt; &lt;thymeleaf‐layout‐dialect.version&gt;2.2.2&lt;/thymeleaf‐layout‐dialect.version&gt; &lt;/properties&gt; thymeleaf使用只要我们把HTML页面放在classpath:/templates/下，thymeleaf就能自动渲染 1.导入thymeleaf的命名空间 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 2.使用语法 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF‐8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!‐‐th:text 将div里面的文本内容设置为 ‐‐&gt; &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache&#x3D;false 语法规则th:text；改变当前元素里面的文本内容； th：任意html属性；来替换原生属性的值 表达式: ${…}：获取变量值 #{…}：获取国际化内容 *{…}：选择表达式 和${}在功能上是一样 @{…}：定义URL ~{…}：片段引用表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象： #execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in thesame way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as aresult of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , ‐ , * , / , % Minus sign (unary operator): ‐Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If‐then: (if) ? (then) If‐then‐else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No‐Operation: _ 5.3、SpringMVC 自动配置auto-configurationSpring Boot 自动配置好了SpringMVC以下是SpringBoot对SpringMVC的默认配置:（WebMvcAutoConfiguration） Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？） ContentNegotiatingViewResolver：组合所有的视图解析器的； 如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来； Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter , GenericConverter , Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 123456789@Bean @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date‐format&quot;)//在文件中配置日期格式化的规则 public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat()); //日期格式化组件 &#125; 自己添加的格式化器转换器，我们只需要放在容器中即可 Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component） Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below).我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器） 12初始化WebDataBinder；请求数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； 扩展SpringMVC在config包下 编写一个配置类（@Configuration），实现WebMvcConfigurer接口 注意 ：不能标注@EnableWebMvc;标注后springmvc的自动配置就会失效，我们全面接管springmvc 1234567891011121314151617181920212223242526272829303132/** * 2020/2/13 14:32 * 文件说明：Mvc的自定义配置类 * * @author 薛云冲 * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123;// 视图解析器 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;main.html&quot;).setViewName(&quot;dashboard&quot;); &#125; //自定义的国际化组件 @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(&quot;/**&quot;）.excludePathPatterns (&quot;/index.html&quot;,&quot;/&quot;,&quot;/index&quot;,&quot;/user/login&quot;,&quot;/asserts/**&quot;); &#125;&#125; 5.4、修改springboot默认配置1） SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；2） 在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置3） 在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 5.5、CRUD操作后台Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.xyc.springbootweb.Controller;/** * 2020/2/14 21:37 * 文件说明： * * @author 薛云冲 * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Controller@RequestMapping(&quot;EMP&quot;)public class EmployeeController &#123; @Autowired private EmployeeService employeeService; @Autowired private DepartmentDao departmentDao; @RequestMapping(&quot;/findAll&quot;) public String findAll(Model model)&#123; Collection&lt;Employee&gt; employees = employeeService.findAll(); model.addAttribute(&quot;emps&quot;,employees); return &quot;list&quot;; &#125;// 跳转到添加员工的页面 @GetMapping(&quot;/add&quot;) public String toAddEmployee( Model model)&#123; model.addAttribute(&quot;depts&quot;,departmentDao.getDepartments()); return &quot;addEmp&quot;; &#125; @PostMapping(&quot;/add&quot;) public String addEmployee(Employee employee)&#123; if (employee!=null)&#123; employeeService.addEmp(employee); &#125; return &quot;redirect:findAll&quot;; &#125; @GetMapping(&quot;/toUpdate&quot;)// 跳转到修改员工信息的页面 public String toUpdateEmployee(String id,Model model)&#123; Employee employee = employeeService.findById(id); model.addAttribute(&quot;depts&quot;,departmentDao.getDepartments()); model.addAttribute(&quot;emp&quot;,employee); return &quot;updateEmp&quot;; &#125; @PostMapping(&quot;/update&quot;) public String updateEmployee(Employee employee)&#123; employeeService.updateEmployee(employee); return &quot;redirect:findAll&quot;; &#125; @RequestMapping(&quot;/delete&quot;) public String deleteEmployee(String id)&#123; employeeService.deleteEmployee(id); return &quot;redirect:findAll&quot;; &#125;&#125; 前端利用thymeleaf模板引擎进行数据回显，等等 5.6、国际化1.在resources文件夹下创建包 i18n，在i18n下编写国际化消息 2.在配置文件中添加消息文件的真实位置 123# 我们自定义的消息的配置文件的真实位置 messages: basename: i18n.login 3.根据请求切换国际化语言（只需在相关请求中加入相关参数） 12&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt; 4.创建国际化配置类放入容器（一定要放入容器） 1234567891011121314151617181920212223242526272829303132333435363738package com.xyc.springbootweb.config;/** * 2020/2/14 1:52 * 文件说明： * * @author 薛云冲 * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Componentpublic class MyLocaleResolver implements LocaleResolver &#123; //解析请求 @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; //获取请求中的语言参数 String language = httpServletRequest.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); // 如果没有就是用默认值 //如果请求中的链接携带了国际化参数 if (!StringUtils.isEmpty(language))&#123; //zh_CN String[] split = language.split(&quot;_&quot;); //国家地区 locale = new Locale(split[0], split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 4.去页面获取国际化的值； 12#&#123;login.tip&#125;#&#123;login.username&#125; 5.7、拦截器自定义拦截器 1234567891011121314151617181920212223242526/** * 2020/2/14 18:43 * 文件说明： * * @author 薛云冲 * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 登录成功之后，应该有用户的session Object username = request.getSession().getAttribute(&quot;username&quot;); if(username==null)&#123; request.setAttribute(&quot;msg&quot;,&quot;未登录，请先登录!&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; &#125;else&#123; return true; &#125; &#125;&#125; 在自定义MvcConfig类中的注册拦截器（必须） 123456@Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(&quot;/**&quot;).excludePathPatterns (&quot;/index.html&quot;,&quot;/&quot;,&quot;/index&quot;,&quot;/user/login&quot;,&quot;/asserts/**&quot;); &#125; 5.8、错误处理机制5.8.1、默认的错误处理机制默认效果： 1）、浏览器，返回一个默认的错误页面 原理 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(&quot;timestamp&quot;, new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = &quot;text/html&quot;)//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; 3、ErrorPageCustomizer： 12@Value(&quot;$&#123;error.path:/error&#125;&quot;)private String path = &quot;/error&quot;; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = &quot;error/&quot; + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; 步骤 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被**BasicErrorController**处理； 1）响应页面；去哪个页面是由**DefaultErrorViewResolver**解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 5.8.2、定制错误响应：定制错误的页面；1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； 页面能获取的信息； timestamp：时间戳 status：状态码 error：错误提示 exception：异常对象 message：异常消息 errors：JSR303数据校验的错误都在这里 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 定制错误的json数据；1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); return map; &#125;&#125;//没有自适应效果... 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(&quot;javax.servlet.error.status_code&quot;); */ request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); //转发到/error return &quot;forward:/error&quot;; &#125; 3）、将我们的定制数据携带出去； 出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(&quot;company&quot;,&quot;atguigu&quot;); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 六、整合JDBC配置 导入JDBC的启动器，以及mysql的相关依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 在springboot的配置中对数据源datasource进行配置 1234567891011spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/ems?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver #type 指定自定义数据源类型，以下是阿里的druid数据源 type: com.alibaba.druid.pool.DruidDataSource 配置好，就可以直接使用了，其余的springboot自动配置 com.zaxxer.hikari.HikariDataSource （Spring Boot 2.0 以上，默认使用此数据源） 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。默认情况下，它是从类路径自动检测的。 可以测试一下是否配置完成 在测试类中 123456789101112131415161718192021@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootDemoDataApplicationTests &#123; //DI注入数据源 @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException &#123; //看一下默认数据源 dataSource.getClass() System.out.println(dataSource.getClass()); //输出默认数据源：com.zaxxer.hikari.HikariDataSource //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); //关闭连接 connection.close(); &#125;&#125; 使用CRUD操作 方法： 配置好数据源（dataSource）后，就可以拿到数据库连接（Connection），使用连接和原生的JDBC就可以进行操作数据库 使用第三方框架，mybatis，hibernate等 使用Spring对原生JDBC的轻量级封装 ，即org.springframework.jdbc.core.JdbcTemplate。 在jdbcTemplate中，封装有数据库操作的所有CRUD方法 在springboot中已默认配置了jdbcTemplate，并放入容器中，直接自行注入即可使用。 jdbcTempalte提供的几类方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句； update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句； query方法及queryForXXX方法：用于执行查询相关语句； call方法：用于执行存储过程、函数相关语句。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@RestControllerpublic class JdbcController &#123; //JdbcTemplate 是 core 包的核心类，用于简化 JDBC操作，还能避免一些常见的错误，如忘记关闭数据库连接 //Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate //JdbcTemplate 中会自己注入数据源，使用起来也不用再自己来关闭数据库连接 @Autowired JdbcTemplate jdbcTemplate; //查询数据库的所有连接 //没有实体类，怎么取数据库的数据？用Map&lt;String,Object&gt; //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值 @GetMapping(&quot;findAll&quot;) //查询所有 public List&lt;Map&lt;String,Object&gt;&gt; findAll()&#123; String sql=&quot;select * from admin&quot;; //List 中的1个 Map 对应数据库的 1行数据 //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值 List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql); return maps; &#125; //增加信息 @GetMapping(&quot;add&quot;) public String add()&#123; String sql=&quot;insert into ems.admin values(&#x27;123142&#x27;,&#x27;root&#x27;,&#x27;991016&#x27;,&#x27;测试3&#x27;)&quot;; jdbcTemplate.update(sql); return &quot;update-ok&quot;; &#125; //删除数据 @GetMapping(&quot;delete&quot;) public String delete()&#123; String sql=&quot;delete from ems.admin where id=&#x27;123142&#x27;&quot;; jdbcTemplate.update(sql); return &quot;delete-ok&quot;; &#125; //修改数据 @GetMapping(&quot;update&quot;) public String update()&#123; String sql=&quot;update ems.admin set name=&#x27;测试&#x27; where id=&#x27;123142&#x27;&quot;; jdbcTemplate.update(sql); return &quot;update-ok&quot;; &#125;&#125; 七、整合Druid数据源简介： Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP、PROXOOL 等 DB 池的优点，同时加入了日志监控。 Druid 基本配置参数： 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 详情-点此处。 url 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 validationQueryTimeout 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 1分钟（1.0.14） 有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis 30分钟（1.0.14） 连接保持空闲而不被驱逐的最长时间 connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 导入依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--log4j--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 配置数据源12345678910111213141516171819202122232425262728293031323334spring: datasource: username: root password: 991016# 如果mysql关于时区报错，就在url中加一个参数 ：serverTimezeno=UTC url: JDBC:mysql://localhost:3306/ems?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver# 切换数据源 默认的数据源：com.zaxxer.hikari.HikariDataSource type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 druid: initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址： https://mvnrepository.com/artifact/log4j/log4j filters: stat,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 配置完成后可在测试类中，检测数据源是否配置完成 配置Druid数据监控Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。 所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; //后台监控 web.xml ServletRegistrationBean //因为springboot 内置了servlet容器，所以没有web.xml ，替代方法：servletRegistrationBean @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(),&quot;/druid/*&quot;); //后台需要有人登录，账号密码配置 HashMap&lt;String,String&gt; initParameters = new HashMap&lt;&gt;(); //增加配置 initParameters.put(&quot;loginUsername&quot;,&quot;admin&quot;);//登录key，是固定的 LoginUsername、LoginPassword initParameters.put(&quot;loginPassword&quot;,&quot;991016&quot;); //允许谁可以访问 initParameters.put(&quot;allow&quot;,&quot;&quot;); //禁止谁可以访问 initParameters.put(&quot;kuangsheng&quot;,&quot;192.168&quot;); bean.setInitParameters(initParameters); return bean; &#125; // filter public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); //可以过滤哪些请求？ HashMap&lt;String,String&gt; initParameters = new HashMap&lt;&gt;(); //这些东西不进行统计 initParameters.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParameters); return bean; &#125;&#125; 八、整合Mybatis1.导入整合mybatis所需依赖123456&lt;!-- 引入 myBatis，这是 MyBatis官方提供的适配 Spring Boot 的，而不是Spring Boot自己的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 2.配置数据源12345678spring: datasource: username: root password: 991016 url: jdbc:mysql://localhost:3306/ems?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver 测试类测试一下是否可以连接成功。。。 3.整合Mybatis在配置文件中加入 123456 #整合mybatismybatis: #对应实体类的路径 type-aliases-package: com.xyc.pojo #指定mybatis的核心配置文件与Mapper映射文件 mapper-locations: classpath:mybatis/mapper/*.xml 4.创建实体类：12345678910111213//lombok的注解标注这是一个实体类@Data//标注自动创建无参构造@NoArgsConstructor//标注自动创建有参构造@AllArgsConstructorpublic class Admin &#123;private String id;private String username;private String password;private String name;&#125; 5.配置Mapper接口类123456789101112131415161718//@Mapper : 表示本类是一个 MyBatis 的 Mapper，（dao层）// 等价于以前 Spring 整合 MyBatis 时的 Mapper 接口@Mapper//@Repository:将此类放入spring容器中@Repositorypublic interface AdminMapper &#123; //查询所有 public List&lt;Admin&gt; findAll(); //通过id查询 public Admin findById(String id); // 增加 public int add(Admin admin); // 修改 public int update(Admin admin); // 删除 public int delete(String id);&#125; 6.Mapper映射文件1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.xyc.mapper.AdminMapper&quot; &gt; &lt;select id=&quot;findAll&quot; resultType=&quot;Admin&quot; &gt; select * from admin; &lt;/select&gt; &lt;select id=&quot;findById&quot; resultType=&quot;Admin&quot;&gt; select * from admin where id = #&#123;id&#125;; &lt;/select&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;Admin&quot;&gt; insert into admin(id, username, password, name) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;name&#125;) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Admin&quot;&gt; update admin set id= #&#123;id&#125;, username= #&#123;username&#125;, password= #&#123;password&#125;, name =#&#123;name&#125; where id = #&#123;id&#125;; &lt;/update&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;String&quot;&gt; delete from admin where id = #&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 九、springSecurity1、SpringSecurity简介1.1、安全框架概述什么是安全框架 ? 解决系统安全问题的框架。如果没有安全框架,我们需要手动处理每个资源的访问控制,非常麻烦。使用安全框架,我们可以通过配置的方式实现对资源的访问限制。 1.2、常用安全框架Spring Security: Spring全家桶的一员。是一个能够为基于 Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean,充分利用了 Spring IoC、DI (控制反转 Inversion of Control；DI: Dependency Injection 依赖注入)和**AoP(面问切面编程)**功能,为应用系统提供声明式的安全访问控制功能,减少了为企业系统安全控制编写大量重复代码的工作。 Apache Shiro: 一个功能强大且易于使用的Java安全框架提供了认证、授权、加密和会话管理 1.3、简介Spring Security是一个高度自定义的安全框架。利用 Spring loC/D和AOP功能,为系统提供了声明式安全访问控制功能,减少了为系统安全而编写大量重复代码的工作。使用 Spring Secruity的原因有很多,但大部分都是发现了javaEE的 Servlet规范或EJB规范中的安全功能缺乏典型企业应用场景。同时认识到他们在WAR或EAR级别无法移植。因此如果你更换服务器环境,还有大量工作去重新配置你的应用程序。使用 Spring Security解决了这些问题也为你提供许多其他有用的、可定制的安全功能。正如你可能知道的两个应用程序的两个主要区域是“认证和授权”(或者访问控制)。这两点也是 Spring Security重要核心功能。 “认证“,是建立一个他声明的主体的过程(一个“主体”一般是指用户,设备或一些可以在你的应用程序中执行动作的其他系统),通俗点说就是系统认为用户是否能登录。 “授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情。 2、简单使用导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 前端页面 login.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 导入spring-boot-starter-security 启动器后，Spring Security 已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。 默认的 username 为 user，password 打印在控制台中。 3、UserDetailsService当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。 3.1、返回值返回值为 UserDetails 接口 的实例 UserDetails接口 123456789101112131415public interface UserDetails extends Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); // 获取密码 String getPassword(); // 获取用户名 String getUsername(); // 是否账号过期 boolean isAccountNonExpired(); // 是否账号被锁定 boolean isAccountNonLocked(); // 凭证（密码）是否过期 boolean isCredentialsNonExpired(); // 是否可用 boolean isEnabled();&#125; 想返回 UserDetails 的实例,只能返回接口的实现类。SpringSecurity 中提供了如下的实例。 我们只需要使用里面的 User 类即可。注意 User 的全限定路径是：org.springframework.security.core.userdetails.User 此处经常和系统中自己开发的 User 类弄混。 User 类的方法和属性 构造方法 1234567891011121314151617181920/** * username : 用户名 ，password : 密码，authorities ： 用户所具有的权限 （not null） */public User(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this(username, password, true, true, true, true, authorities); &#125; public User(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; if (username != null &amp;&amp; !&quot;&quot;.equals(username) &amp;&amp; password != null) &#123; this.username = username; this.password = password; this.enabled = enabled; this.accountNonExpired = accountNonExpired; this.credentialsNonExpired = credentialsNonExpired; this.accountNonLocked = accountNonLocked; this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities)); &#125; else &#123; throw new IllegalArgumentException(&quot;Cannot pass null or empty values to constructor&quot;); &#125; &#125; 此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。SpringSecurity 会根据 User 中的 password 和客户端传递过来的 password 进行比较。如果相同则表示认证通过，如果不相同表示认证失败。 authorities 里面包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现 403。通常都是通过AuthorityUtils.commaSeparatedStringToAuthorityList(“”) 来创建authorities 集合对象的。参数是一个字符串，多个权限使用逗号分隔。 3.2、方法参数方法参数为登录时传入的用户名 3.3、异常UsernameNotFoundException 用户名没有发现异常。在 loadUserByUsername 中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出UsernameNotFoundException ，系统就知道用户名没有查询到。 3.4、实现案例UserDetailsService接口的实现类 ：UserDetailsServiceImpl 12345678910111213141516171819202122232425262728293031@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; private static final Logger log = LoggerFactory.getLogger(UserDetailsServiceImpl.class); @Autowired private ISysUserService userService; @Autowired private SysPermissionService permissionService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; SysUser user = userService.selectUserByUserName(username); if (StringUtils.isNull(user)) &#123; log.info(&quot;登录用户：&#123;&#125; 不存在.&quot;, username); throw new UsernameNotFoundException(&quot;登录用户：&quot; + username + &quot; 不存在&quot;); &#125; else if (UserStatus.DELETED.getCode().equals(user.getDelFlag())) &#123; log.info(&quot;登录用户：&#123;&#125; 已被删除.&quot;, username); throw new BaseException(&quot;对不起，您的账号：&quot; + username + &quot; 已被删除&quot;); &#125; else if (UserStatus.DISABLE.getCode().equals(user.getStatus())) &#123; log.info(&quot;登录用户：&#123;&#125; 已被停用.&quot;, username); throw new BaseException(&quot;对不起，您的账号：&quot; + username + &quot; 已停用&quot;); &#125; return createLoginUser(user); &#125; public UserDetails createLoginUser(SysUser user) &#123; return new LoginUser(user, permissionService.getMenuPermission(user)); &#125;&#125; UserDetails接口的实现类 LoginUser 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public class LoginUser implements UserDetails &#123; private static final long serialVersionUID = 1L; /** * 用户唯一标识 */ private String token; /** * 登录时间 */ private Long loginTime; /** * 过期时间 */ private Long expireTime; /** * 登录IP地址 */ private String ipaddr; /** * 登录地点 */ private String loginLocation; /** * 浏览器类型 */ private String browser; /** * 操作系统 */ private String os; /** * 权限列表 */ private Set&lt;String&gt; permissions; /** * 用户信息 */ private SysUser user; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public LoginUser() &#123; &#125; public LoginUser(SysUser user, Set&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; @JsonIgnore @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; /** * 账户是否未过期,过期无法验证 */ @JsonIgnore @Override public boolean isAccountNonExpired() &#123; return true; &#125; /** * 指定用户是否解锁,锁定的用户无法进行身份验证 * * @return */ @JsonIgnore @Override public boolean isAccountNonLocked() &#123; return true; &#125; /** * 指示是否已过期的用户的凭据(密码),过期的凭据防止认证 * * @return */ @JsonIgnore @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; /** * 是否可用 ,禁用的用户不能身份验证 * * @return */ @JsonIgnore @Override public boolean isEnabled() &#123; return true; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125;&#125; 4、PasswordEncoderSpring Security 要求容器中必须有 PasswordEncoder 实例。所以当自定义登录逻辑时要求必须给容器注入 PaswordEncoder 的bean对象。 123456789101112131415161718public interface PasswordEncoder &#123; /** * 把参数按照特定的解析规则进行解析 */ String encode(CharSequence var1); /* * 验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配， * 则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存 * 储的密码。 */ boolean matches(CharSequence var1, String var2); /** * 如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回 false。默认返回 false。 */ default boolean upgradeEncoding(String encodedPassword) &#123; return false; &#125;&#125; 内置解析器 内置解析器有很多 ，BCryptPasswordEncoder 是官方推荐的密码解析器。 BCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认 10. 5、自定义登录逻辑当 进 行 自 定 义 登 录 逻 辑 时 需 要 用 到 之 前 讲 解 的 UserDetailsService 和PasswordEncoder 。但是 Spring Security 要求：当进行自定义登录逻辑时容器内必须有PasswordEncoder 实例。 5.1、配置类将PasswordEncoder注入到容器中 1234567@Configurationpublic class SecurityConfig &#123;@Beanpublic PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder();&#125;&#125; 5.2、自定义逻辑在 Spring Security 中实现 UserDetailService 就表示为用户详情服务。在这个类中编写用户认证逻辑。 1234567891011121314151617@Servicepublic class UserServiceImpl implements UserDetailsService &#123;@Autowiredprivate PasswordEncoder pw;@Overridepublic UserDetails loadUserByUsername(String username) throwsUsernameNotFoundException &#123; //1.查询数据库判断用户名是否存在，如果不存在抛出UsernameNotFoundException异常 if (!&quot;admin&quot;.equals(username))&#123; throw new UsernameNotFoundException(&quot;用户名不存在&quot;); &#125; //2.把查询出来的密码（注册时已经加密过）进行解析，或直接把密码放入构造方法中 String password = pw.encode(&quot;123&quot;); return new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,normal&quot;)); &#125;&#125; 6、自定义登录界面6.1、修改配置类主要是设置哪个页面是登录页面。配置类需要继承WebSecurityConfigurerAdapte,并重写 configure 方法。 successForwardUrl() ：登录成功后跳转地址 loginPage() ：登录页面 loginProcessingUrl() ：登录页面表单提交地址，此地址可以不真实存在。 antMatchers() ：匹配内容 permitAll() ：允许 12345678910111213141516171819202122232425262728@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //表单提交 http.formLogin() //自定义登录页面 .loginPage(&quot;/login.html&quot;) //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl .loginProcessingUrl(&quot;/login&quot;) //登录成功后跳转页面，POST请求 .successForwardUrl(&quot;/toMain&quot;); http.authorizeRequests() //login.html不需要被认证 .antMatchers(&quot;/login.html&quot;).permitAll() //所有请求都必须被认证，必须登录后被访问 .anyRequest().authenticated(); //关闭csrf防护 http.csrf().disable();&#125;@Beanpublic PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder();&#125;&#125; 7、认证过程中其他常用配置7.1、失败跳转设置失败跳转页面 12345678910//表单提交http.formLogin() //自定义登录页面 .loginPage(&quot;/login.html&quot;) //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl .loginProcessingUrl(&quot;/login&quot;) //登录成功后跳转页面，POST请求 .successForwardUrl(&quot;/toMain&quot;) //登录失败后跳转页面，POST请求 .failureForwardUrl(&quot;/toError&quot;); 设置失败页面不拦截 1234567http.authorizeRequests()//login.html不需要被认证.antMatchers(&quot;/login.html&quot;).permitAll()//error.html不需要被认证.antMatchers(&quot;/error.html&quot;).permitAll()//所有请求都必须被认证，必须登录后被访问.anyRequest().authenticated(); 7.2、设置请求账户和密码的参数名当进行登录时会执行 UsernamePasswordAuthenticationFilter 过滤器。在该过滤器中定义请求的用户名密码默认为 username和password。 修改默认用户名和密码参数名 12345678910111213//表单提交http.formLogin() //自定义登录页面 .loginPage(&quot;/login.html&quot;) //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl .loginProcessingUrl(&quot;/login&quot;) //登录成功后跳转页面，POST请求 .successForwardUrl(&quot;/toMain&quot;) //登录失败后跳转页面，POST请求 .failureForwardUrl(&quot;/toError&quot;) //修改默认用户名和密码参数名 .usernameParameter(&quot;myusername&quot;) .passwordParameter(&quot;mypassword&quot;) 7.3、自定义登录成功处理器使用successForwardUrl()时表示成功后转发请求到地址。内部是通过 successHandler() 方法进行控制成功后交给哪个类进行处理 ForwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了, 当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。 自定义类 12345678910111213141516171819public class MyAuthenticationSuccessHandler implementsAuthenticationSuccessHandler &#123; private String url; public MyAuthenticationSuccessHandler(String url) &#123; this.url = url; &#125; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; //Principal 主体，存放了登录用户的信息 User user = (User) authentication.getPrincipal(); System.out.println(user.getUsername()); //输出null System.out.println(user.getPassword()); System.out.println(user.getAuthorities()); response.sendRedirect(url); &#125;&#125; 修改配置 123456789101112131415/表单提交http.formLogin()//自定义登录页面.loginPage(&quot;/login.html&quot;)//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl.loginProcessingUrl(&quot;/login&quot;)//登录成功后跳转页面，POST请求// .successForwardUrl(&quot;/toMain&quot;)//和successForwardUrl不能共存.successHandler(newMyAuthenticationSuccessHandler(&quot;/login&quot;))//登录失败后跳转页面，POST请求.failureForwardUrl(&quot;/toError&quot;).usernameParameter(&quot;myusername&quot;).passwordParameter(&quot;mypassword&quot;); 7.4、自定义登录失败处理器failureForwardUrl()内部调用的是 failureHandler() 方法 ForwardAuthenticationFailureHandler 中也是一个请求转发，并在request 作用域中设置SPRING_SECURITY_LAST_EXCEPTION 的 key，内容为异常对象。 123456789101112131415public class ForwardAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; private final String forwardUrl; public ForwardAuthenticationFailureHandler(String forwardUrl) &#123; Assert.isTrue(UrlUtils.isValidRedirectUrl(forwardUrl), () -&gt; &#123; return &quot;&#x27;&quot; + forwardUrl + &quot;&#x27; is not a valid forward URL&quot;; &#125;); this.forwardUrl = forwardUrl; &#125; public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; request.setAttribute(&quot;SPRING_SECURITY_LAST_EXCEPTION&quot;, exception); request.getRequestDispatcher(this.forwardUrl).forward(request, response); &#125;&#125; 实现 12345678910111213public class MyForwardAuthenticationFailureHandler implementsAuthenticationFailureHandler &#123; private String url; public MyForwardAuthenticationFailureHandler(String url) &#123; this.url = url; &#125; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; response.sendRedirect(url); &#125;&#125; 配置 12345678910111213141516//表单提交http.formLogin()//自定义登录页面.loginPage(&quot;/login.html&quot;)//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl.loginProcessingUrl(&quot;/login&quot;)//登录成功后跳转页面，POST请求// .successForwardUrl(&quot;/toMain&quot;)//和successForwardUrl不能共存.successHandler(newMyAuthenticationSuccessHandler(&quot;http://www.baidu.com&quot;))//登录失败后跳转页面，POST请求// .failureForwardUrl(&quot;/toError&quot;).failureHandler(new MyForwardAuthenticationFailureHandler(&quot;/error.html&quot;)).usernameParameter(&quot;myusername&quot;).passwordParameter(&quot;mypassword&quot;); 8、访问控制url匹配在前面认证中所有常用配置，主要是对 http.formLogin() 进行操作。而在配置类中http.authorizeRequests() 主要是对url进行控制，也就是我们所说的授权（访问控制）。http.authorizeRequests() 也支持链式编程 8.1、anyRequest()在之前认证过程中我们就已经使用过 anyRequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。 1.anyRequest().authenticated(); 8.2、antMatcher()1public C antMatchers(String... antPatterns) 参数是不定向参数，每个参数是一个 ant 表达式，用于匹配 URL规则。 ? ： 匹配一个字符 * ：匹配 0 个或多个字符 ** ：匹配 0 个或多个目录 在实际项目中经常需要放行所有静态资源 1.antMatchers(&quot;/js/**&quot;,&quot;/css/**&quot;).permitAll() 或 12.antMatchers(&quot;/**/*.js&quot;).permitAll().antMatchers(&quot;/**/*.css&quot;).permitAll() 8.3、regexMatchers()使用正则表达式进行匹配。和 antMatchers() 主要的区别就是参数， antMatchers() 参数是 ant表达式， regexMatchers() 参数是正则表达式。 1.regexMatchers( &quot;.+[.]js&quot;).permitAll() 无论是 antMatchers() 还是 regexMatchers() 都具有两个参数的方法，其中第一个参数都是HttpMethod ，表示请求方式，当设置了 HttpMethod 后表示只有设定的特定的请求方式才执行对应的权限设置。 1234567891011121314151617181920public enum HttpMethod &#123; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE; private static final Map&lt;String, HttpMethod&gt; mappings = new HashMap&lt;&gt;(16); static &#123; for (HttpMethod httpMethod : values()) &#123; mappings.put(httpMethod.name(), httpMethod); &#125; &#125; @Nullable public static HttpMethod resolve(@Nullable String method) &#123; return (method != null ? mappings.get(method) : null); &#125; public boolean matches(String method) &#123; return (this == resolve(method)); &#125;&#125; 8.4、mvcMatchers()mvcMatchers()适用于配置了 servletPath 的情况。 servletPath 就是所有的 URL 的统一前缀。在 SpringBoot 整合SpringMVC 的项目中可以在application.properties 中添加下面内容设置 ServletPath 1spring.mvc.servlet.path = /system 在 Spring Security 的配置类中配置 .servletPath() 是 mvcMatchers()返回值特有的方法，antMatchers()和 regexMatchers()没有这个方法。在 servletPath() 中配置了 servletPath 后，mvcMatchers()直接写 SpringMVC 中@RequestMapping()中设置的路径即可。 1.mvcMatchers(&quot;/demo&quot;).servletPath(&quot;/xxxx&quot;).permitAll() 等价于 1.antMatchers(&quot;/xxxx/demo&quot;).permitAll() 9、内置访问控制方法Spring Security 匹配了 URL 后调用了 permitAll() 表示不需要认证，随意访问。在 Spring Security中提供了多种内置控制。 9.1、permitAll()permitAll()表示所匹配的 URL 任何人都允许访问。 9.2、authenticated()authenticated()表示所匹配的 URL 都需要被认证才能访问。 9.3、anonymous()anonymous()表示可以匿名访问匹配的URL。和permitAll()效果类似，只是设置为 anonymous()的 url会执行 filter 链中 9.4、denyAll()denyAll()表示所匹配的 URL 都不允许被访问。 9.5、rememberMe()被“remember me”的用户允许访问 9.6、fullyAuthenticated()如果用户不是被 remember me 的，才可以访问。 10、角色权限判断Spring Security 中还支持很多其他权限控制。这些方法一般都用于用户已经被认证后，判断用户是否具有特定的要求。 10.1、hasAuthority(String)判断用户是否具有特定的权限，用户的权限是在自定义登录逻辑中创建 User 对象时指定的。下图中admin和normal 就是用户的权限。admin和normal 严格区分大小写。 1.antMatchers(&quot;/main1.html&quot;).hasAuthority(&quot;admin&quot;) 10.2、hasAnyAuthority(String …)如果用户具备给定权限中某一个，就允许访问。 1.antMatchers(&quot;/main1.html&quot;).hasAnyAuthority(&quot;adMin&quot;,&quot;admiN&quot;) 10.3、hasRole(String)如果用户具备给定角色就允许访问。否则出现 403。 在给用户赋予角色时角色需要以： ROLE_开头 ，后面添加角色名称。例如：ROLE_abc 其中 abc 是角色名，ROLE_是固定的字符开头。 使用 hasRole()时参数也只写 abc 即可。否则启动报错。 1.antMatchers(&quot;/main1.html&quot;).hasRole(&quot;abc&quot;) 10.4、hasAnyRole(String …)如果用户具备给定角色的任意一个，就允许被访问 10.5、hasIpAddress(String)如果请求是指定的 IP 就运行访问。 1.antMatchers(&quot;/main1.html&quot;).hasIpAddress(&quot;127.0.0.1&quot;) 而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security 支持自定义权限受限。 11、自定义403处理方案使用 Spring Security 时经常会看见 403（无权限），默认情况下显示的效果如下： 新建类 实现 AccessDeniedHandler接口 1234567891011121314@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123;@Overridepublic void handle(HttpServletRequest request, HttpServletResponse response,AccessDeniedException accessDeniedException) throws IOException,ServletException &#123; response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); out.write(&quot;&#123;\\&quot;status\\&quot;:\\&quot;error\\&quot;,\\&quot;msg\\&quot;:\\&quot;权限不足，请联系管理员！\\&quot;&#125;&quot;); out.flush(); out.close();&#125;&#125; 配置类中添加 123//异常处理http.exceptionHandling().accessDeniedHandler(myAccessDeniedHandler); 12、基于表达式的访问控制12.1、access() 可以通过 access() 实现和之前学习的权限控制完成相同的功能。 12.2、使用自定义方法新建接口和实现类 MyService.java 1234public interface MyService &#123;boolean hasPermission(HttpServletRequest request, Authenticationauthentication);&#125; 1234567891011121314@Componentpublic class MyServiceImpl implements MyService &#123;@Overridepublic boolean hasPermission(HttpServletRequest request, Authenticationauthentication) &#123; Object obj = authentication.getPrincipal(); if (obj instanceof UserDetails)&#123; UserDetails userDetails = (UserDetails) obj; Collection&lt;? extends GrantedAuthority&gt; authorities =userDetails.getAuthorities(); return authorities.contains(newSimpleGrantedAuthority(request.getRequestURI())); &#125; return false;&#125;&#125; 修改配置 12345678//url拦截http.authorizeRequests()//login.html不需要被认证// .antMatchers(&quot;/login.html&quot;).permitAll().antMatchers(&quot;/login.html&quot;).access(&quot;permitAll&quot;)// .antMatchers(&quot;/main.html&quot;).hasRole(&quot;abc&quot;).antMatchers(&quot;/main.html&quot;).access(&quot;hasRole(&#x27;abc&#x27;)&quot;).anyRequest().access(&quot;@myServiceImpl.hasPermission(request,authentication)&quot;) 13、基于注解的访问控制在 Spring Security 中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过@EnableGlobalMethodSecurity 进行开启后使用。如果设置的条件允许，程序正常执行。如果不允许会报 500 这些注解可以写到 Service 接口或方法上，也可以写到 Controller或 Controller 的方法上。通常情况下都是写在控制器方法上的，控制接口URL是否允许被访问。 13.1、@Secured@Secured 是专门用于判断是否具有角色的。能写在方法或类上。参数要以 ROLE_开头。 12345@Secured(&quot;ROLE_abc&quot;)@RequestMapping(&quot;/toMain&quot;)public String toMain()&#123;return &quot;redirect:/main.html&quot;;&#125; 13.2、@PreAuthorize/@PostAuthorize@PreAuthorize 和@PostAuthorize 都是方法或类级别注解。 @PreAuthorize 表示访问方法或类在执行之前先判断权限，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。 @PostAuthorize 表示方法或类执行结束后判断权限，此注解很少被使用到。 123456789/*** 成功后跳转页面* @return*/@PreAuthorize(&quot;hasRole(&#x27;ROLE_abc&#x27;)&quot;)@RequestMapping(&quot;/toMain&quot;)public String toMain()&#123;return &quot;redirect:/main.html&quot;;&#125; 14、RememberMe功能实现Spring Security 中 Remember Me 为“记住我”功能，用户只需要在登录时添加 remember-me复选框，取值为true。Spring Security 会自动把用户信息存储到数据源中，以后就可以不登录进行访问 Spring Security 实 现 Remember Me 功 能 时 底 层 实 现 依 赖Spring-JDBC，所以需要导入 Spring-JDBC。以后多使用 MyBatis 框架而很少直接导入 spring-jdbc，所以此处导入 mybatis 启动器同时还需要添加 MySQL 驱动 123456789101112&lt;!-- mybatis 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql 数据库依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt; 配置数据源 12345spring.datasource.driver-class-name= com.mysql.cj.jdbc.Driverspring.datasource.url= jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.username= rootspring.datasource.password= root 编写配置 1234567891011121314@Configurationpublic class RememberMeConfig &#123;@Autowiredprivate DataSource dataSource;@Beanpublic PersistentTokenRepository getPersistentTokenRepository()&#123;JdbcTokenRepositoryImpl jdbcTokenRepository = newJdbcTokenRepositoryImpl();jdbcTokenRepository.setDataSource(dataSource);//自动建表，第一次启动时需要，第二次启动时注释掉jdbcTokenRepository.setCreateTableOnStartup(true);return jdbcTokenRepository;&#125;&#125; ==注意== : jdbcTokenRepository.setCreateTableOnStartup(true); :自动建表，第一次启动时需要，第二次启动时注释掉 修改SecurityConfig.java 在 configure 中添加下面配置内容。 1234567http.rememberMe() //失效时间，单位秒 .tokenValiditySeconds(120) //登录逻辑交给哪个对象 .userDetailsService(userService) // 持久层对象 .tokenRepository(persistentTokenRepository); 15、Thymeleaf中SpringSecurity的使用Spring Security 可以在一些视图技术中进行控制显示效果。例如： JSP 或 Thymeleaf 。在非前后端分离且使用 Spring Boot 的项目中多使用 Thymeleaf 作为视图展示技术。 Thymeleaf 对 Spring Security 的 支 持 都 放 在 thymeleaf-extras-springsecurityX 中，目前最新版本为 5。所以需要在项目中添加此 jar 包的依赖和 thymeleaf 的依赖。。 12345678910&lt;!--thymeleaf springsecurity5 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--thymeleaf依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在 html 页面中引入 thymeleaf 命名空间和 security 命名空间 123&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;xmlns:th=&quot;http://www.thymeleaf.org&quot;xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt; 获取属性 可以在html页面中通过 sec:authentication=”” 获取UsernamePasswordAuthenticationToken 中所有 getXXX 的内容，包含父类中的 getXXX 的内容。 根据源码得出下面属性： name ：登录账号名称 principal ：登录主体，在自定义登录逻辑中是 UserDetails credentials ：凭证 authorities ：权限和角色 details ：实际上是 WebAuthenticationDetails 的实例。可以获取 remoteAddress (客户端ip)和 sessionId (当前 sessionId) 新建demo.html在项目 resources 中新建 templates 文件夹，在 templates 中新建demo.html 页面 123456789101112131415&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登录账号:&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;&lt;br/&gt; 登录账号:&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;&lt;br/&gt; 凭证：&lt;span sec:authentication=&quot;credentials&quot;&gt;&lt;/span&gt;&lt;br/&gt; 权限和角色：&lt;span sec:authentication=&quot;authorities&quot;&gt;&lt;/span&gt;&lt;br/&gt; 客户端地址：&lt;span sec:authentication=&quot;details.remoteAddress&quot;&gt;&lt;/span&gt;&lt;br/&gt; sessionId：&lt;span sec:authentication=&quot;details.sessionId&quot;&gt;&lt;/span&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 权限判断 设置用户角色和权限 123return new User(username,password,AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,ROLE_abc,/insert,/delete&quot;)); 控制页面显示效果 1234567891011通过权限判断：&lt;button sec:authorize=&quot;hasAuthority(&#x27;/insert&#x27;)&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/delete&#x27;)&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/update&#x27;)&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/select&#x27;)&quot;&gt;查看&lt;/button&gt;&lt;br/&gt;通过角色判断：&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;查看&lt;/button&gt; 16、退出登录用户只需要向 Spring Security 项目中发送 /logout 退出请求即可 进入我们自定义的界面 123http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/login.html&quot;); logout其他常用配置源码解读 addLogoutHandler(LogoutHandler) 默认是 contextLogoutHandler 默认实例内容 clearAuthentication(boolean) 是否清除认证状态，默认为 true 是否销毁 HttpSession 对象，默认为 true logoutSuccessHandler(LogoutSuccessHandler) 退出成功处理器 也可以自己进行定义退出成功处理器。只要实现了 LogoutSuccessHandler 接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。 17、SpringSecurity中的CSRF17.1、什么是CSRF？CSRF（Cross-site request forgery）跨站请求伪造，也被称为“OneClick Attack” 或者 SessionRiding。通过伪造用户请求访问受信任站点的非法请求访问。 跨域：只要网络协议，ip 地址，端口中任何一个不相同就是跨域请求。 客户端与服务进行交互时，由于 http 协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id 可能被第三方恶意劫持，通过这个 session id 向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。 17.2、Spring Security中的CSRF从 Spring Security4开始CSRF防护默认开启。默认会拦截请求。进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为 _csrf 值为token(token 在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot; name=&quot;_csrf&quot; th:if=&quot;$&#123;_csrf&#125;&quot;/&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 18、Oauth2认证OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说OAUTH标准逐渐成为开放资源授权的标准。 一个Oauth2认证的例子，网站使用微信认证的过程： 用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者 点击“微信”出现一个二维码，此时用户扫描二维码，开始给网站授权。 资源拥有者同意给客户端授权 资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。 客户端获取到授权码，请求认证服务器申请令牌此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。 认证服务器向客户端响应令牌认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。 客户端请求资源服务器的资源客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。 资源服务器返回受保护资源资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。 注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。 客户端本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。资源拥有者通常为用户，也可以是应用程序，即该资源的拥有者。授权服务器（也称认证服务器）用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。资源服务器存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。 术语 客户凭证(client Credentials) ：客户端的clientId和密码用于认证客户令牌(tokens) ：授权服务器在接收到客户请求后，颁发的访问令牌作用域(scopes) ：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission) 令牌类型授权码 ：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌访问令牌 ：用于代表一个用户或服务直接去访问受保护的资源刷新令牌 ：用于去授权服务器获取一个刷新访问令牌BearerToken ：不管谁拿到Token都可以访问资源，类似现金Proof of Possession(PoP) Token ：可以校验client是否对Token有明确的拥有权 19、Spring Security Oauth2 Authorize Endpoint ：授权端点，进行授权Token Endpoint ：令牌端点，经过授权拿到对应的TokenIntrospection Endpoint ：校验端点，校验Token的合法性Revocation Endpoint ：撤销端点，撤销授权 Spring Security Oauth2架构 用户访问,此时没有Token。Oauth2RestTemplate会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重定向到认证服务器 认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端 客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端 客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。 使用 授权模式导入依赖 (导入spring-cloud的依赖使用时比较简单一些) 1234567891011121314151617&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置类 SecurityConfig 需要继承 WebSecurityConfigurerAdapter 12345678910111213141516171819202122@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Override public void configure(HttpSecurity http) throws Exception &#123; http.csrf() .disable() .authorizeRequests() .antMatchers(&quot;/oauth/**&quot;, &quot;/login/**&quot;, &quot;/logout/**&quot;) .permitAll() .anyRequest() .authenticated() .and() .formLogin() .permitAll(); &#125; 编写UserDetailsService接口的实现类，通过loadUserByUsername方法处理登录逻辑 123456789101112@Servicepublic class UserService implements UserDetailsService &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; String password = passwordEncoder.encode(&quot;123456&quot;); return new User(&quot;admin&quot;,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 可以实现UserDetails接口定义我们自己的登录用户类 授权服务器配置 AuthorizationServerConfig.java 12345678910111213141516171819202122232425@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() //配置client_id .withClient(&quot;admin&quot;) //配置client-secret .secret(passwordEncoder.encode(&quot;112233&quot;)) //配置访问token的有效期 .accessTokenValiditySeconds(3600) //配置刷新token的有效期 .refreshTokenValiditySeconds(864000) //配置redirect_uri，用于授权成功后跳转 .redirectUris(&quot;http://www.baidu.com&quot;) //配置申请的权限范围 .scopes(&quot;all&quot;) //配置grant_type，表示授权类型 .authorizedGrantTypes(&quot;authorization_code&quot;); &#125;&#125; 资源服务器配置 ResourceServerConfig.java 12345678910111213@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest() .authenticated() .and() .requestMatchers() .antMatchers(&quot;/user/**&quot;);//配置需要保护的资源路径 &#125;&#125; 编写Controller 12345678@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @GetMapping(&quot;/getCurrentUser&quot;) public Object getCurrentUser(Authentication authentication) &#123; return authentication.getPrincipal(); &#125;&#125; 测试： 获取授权码 http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=client&amp;redirect_uri=http://www.baidu.com&amp;scope=all 输入账户密码 ：—》 进入授权页面 点击授权获取授权码 xNx1zB 根据授权码获取令牌（POST请求） grant_type ：授权类型，填写authorization_code，表示授权码模式code ：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。client_id :客户端标识redirect_uri ：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。scope :授权范围。 认证失败服务端返回 401 Unauthorized注意：此时无法请求到令牌，访问服务器会报错 根据token去资源服务器拿资源 Spring Security Oauth2 密码模式SecurityConfig中添加 AuthenticationManager 12345@Bean@Overridepublic AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean();&#125; AuthorizationServerConfig.java中重写该方法，并添加授权类型 12345678910111213141516171819202122232425262728/*** 使用密码模式需要配置*/@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; endpoints.authenticationManager(authenticationManager) .userDetailsService(userService);&#125;@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throwsException &#123; clients.inMemory() //配置client_id .withClient(&quot;admin&quot;) //配置client-secret .secret(passwordEncoder.encode(&quot;112233&quot;)) //配置访问token的有效期 .accessTokenValiditySeconds(3600) //配置刷新token的有效期 .refreshTokenValiditySeconds(864000) //配置redirect_uri，用于授权成功后跳转 .redirectUris(&quot;http://www.baidu.com&quot;) //配置申请的权限范围 .scopes(&quot;all&quot;) //配置grant_type，表示授权类型 .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;); &#125; redis中存储token导入依赖 12345678910&lt;!--redis 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- commons-pool2 对象池依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; redisConfig 123456789@Configurationpublic class RedisConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; @Bean public TokenStore redisTokenStore()&#123; return new RedisTokenStore(redisConnectionFactory); &#125;&#125; 在认证服务器配置中指定令牌的存储策略为Redis 123456789/*** 使用密码模式需要配置*/@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123;endpoints.authenticationManager(authenticationManager).userDetailsService(userService).tokenStore(tokenStore);&#125; 20、JWT常见的认证机制HTTP Basic Auth HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth。 Cookie Auth Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。 OAuth 基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。 Token Auth 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）： 支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可. 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多. 不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）. JWT简介JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。 官网： https://jwt.io/ JWT 优点： jwt基于json，非常方便解析。 可以在令牌中自定义丰富的内容，易扩展。 通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。 资源服务使用JWT可不依赖认证服务即可完成授权。 缺点： JWT令牌较长，占存储空间比较大。 组成由三部分组成头部、负载与签名 头部：用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMACSHA256或RSA）等。 使用Base64编码 负载：存放有效信息。 分为三个部分 标准中注册的声明（建议但不强制使用） 1234567iss: jwt签发者sub: jwt所面向的用户aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 公共的声明：可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 私有的声明 ：提供者和消费者所共同定义的声明，不建议存放敏感信息，Base64编码是对称解密的 签名：一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret（盐，一定要保密） 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分 使用导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; 测试使用 12345678910111213141516171819202122232425262728@Testpublic void testCreatToken() &#123; //创建一个JwtBuilder对象 JwtBuilder jwtBuilder = Jwts.builder() //声明的标识&#123;&quot;jti&quot;:&quot;8848&quot;&#125; .setId(&quot;8848&quot;) //主体，用户&#123;&quot;sub&quot;:&quot;gailun&quot;&#125; .setSubject(&quot;gailun&quot;) //创建日期&#123;&quot;ita&quot;:&quot;xxxxxx&quot;&#125; .setIssuedAt(new Date()) //签名手段，参数1：算法，参数2：盐 .signWith(SignatureAlgorithm.HS256,&quot;xxxx&quot;) //设置过期时间 .setExpiration(new Date(exp)); // 自定义claim .claim(&quot;roles&quot;,&quot;admin&quot;) .claim(&quot;logo&quot;,&quot;shsxt.jpg&quot;) //获取jwt的token String token = jwtBuilder.compact(); System.out.println(token); //三部分的base64解密 System.out.println(&quot;--------------------&quot;); String[] split = token.split(&quot;\\\\.&quot;); System.out.println(Base64Codec.BASE64.decodeToString(split[0])); System.out.println(Base64Codec.BASE64.decodeToString(split[1])); //无法解密 System.out.println(Base64Codec.BASE64.decodeToString(split[2]));&#125; 验证JWT 12345678910111213141516@Testpublic void testParseToken()&#123;//tokenString token =&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE0MjUyfQ&quot; +&quot;.-FYFMHyfTcGzq900f_Drfdsges0ge2UjaWvPW9gCDto&quot;;//解析token获取负载中的声明对象Claims claims = Jwts.parser() .setSigningKey(&quot;xxxx&quot;) //加密时的 盐 .parseClaimsJws(token) .getBody();//打印声明的属性System.out.println(&quot;id:&quot;+claims.getId());System.out.println(&quot;subject:&quot;+claims.getSubject());System.out.println(&quot;issuedAt:&quot;+claims.getIssuedAt());&#125; 21、Spring Security Oauth2 整合JWT在之前Spring Security Oauth2的基础上进行修改 添加配置类 1234567891011121314@Configurationpublic class JwtTokenStoreConfig &#123;@Beanpublic TokenStore jwtTokenStore()&#123; return new JwtTokenStore(jwtAccessTokenConverter());&#125;@Beanpublic JwtAccessTokenConverter jwtAccessTokenConverter()&#123; JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter(); //配置JWT使用的秘钥 accessTokenConverter.setSigningKey(&quot;test_key&quot;); return jwtAccessTokenConverter();&#125;&#125; 在认证服务器配置中指定令牌的存储策略为JWT 12345678@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; endpoints.authenticationManager(authenticationManager) .userDetailsService(userService) //配置存储令牌策略 .tokenStore(tokenStore) .accessTokenConverter(jwtAccessTokenConverter);&#125; 扩展JWT中存储的内容，这里我们在JWT中扩展一个 key为enhance，value为enhance info 的数据。实现接口TokenEnhancer实现一个JWT内容增强器 123456789public class JwtTokenEnhancer implements TokenEnhancer &#123;@Overridepublic OAuth2AccessToken enhance(OAuth2AccessToken accessToken,OAuth2Authentication authentication) &#123; Map&lt;String,Object&gt; info = new HashMap&lt;&gt;(); info.put(&quot;enhance&quot;,&quot;enhance info&quot;); ((DefaultOAuth2AccessToken)accessToken).setAdditionalInformation(info); return accessToken;&#125;&#125; 创建一个JwtTokenEnhancer实例 1234@Beanpublic JwtTokenEnhancer jwtTokenEnhancer() &#123;return new JwtTokenEnhancer();&#125; 在认证服务器配置中配置JWT的内容增强器 123456789101112131415@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123;TokenEnhancerChain enhancerChain = new TokenEnhancerChain();List&lt;TokenEnhancer&gt; delegates = new ArrayList&lt;&gt;(); //配置JWT的内容增强器 delegates.add(jwtTokenEnhancer); delegates.add(jwtAccessTokenConverter); enhancerChain.setTokenEnhancers(delegates); endpoints.authenticationManager(authenticationManager) .userDetailsService(userService) //配置存储令牌策略 .tokenStore(tokenStore) .accessTokenConverter(jwtAccessTokenConverter) .tokenEnhancer(enhancerChain);&#125; 解析token 12345678910@GetMapping(&quot;/getCurrentUser&quot;)public Object getCurrentUser(Authentication authentication,HttpServletRequest request) &#123; String header = request.getHeader(&quot;Authorization&quot;); String token = header.substring(header.indexOf(&quot;bearer&quot;) + 7); return Jwts.parser() .setSigningKey(&quot;test_key&quot;.getBytes(StandardCharsets.UTF_8)) .parseClaimsJws(token) .getBody();&#125; 刷新令牌 在Spring Cloud Security 中使用oauth2时，如果令牌失效了，可以使用刷新令牌通过refresh_token的授权模式再次获取access_token。只需修改认证服务器的配置，添加refresh_token的授权模式即可。 1234//配置访问token的有效期.accessTokenValiditySeconds(3600)//配置刷新token的有效期.refreshTokenValiditySeconds(864000) 22、Spring Security Oauth2 整合单点登录（SSO）添加依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; 修改配置文件 123456789101112server.port=8081#防止Cookie冲突，冲突会导致登录验证不通过server.servlet.session.cookie.name=OAUTH2-CLIENT-SESSIONID01#授权服务器地址oauth2-server-url: http://localhost:8080#与授权服务器对应的配置security.oauth2.client.client-id=adminsecurity.oauth2.client.client-secret=112233security.oauth2.client.user-authorization-uri=$&#123;oauth2-server-url&#125;/oauth/authorizesecurity.oauth2.client.access-token-uri=$&#123;oauth2-server-url&#125;/oauth/tokensecurity.oauth2.resource.jwt.key-uri=$&#123;oauth2-server-url&#125;/oauth/token_key 启动类添加@EnableOAuth2Sso注解 1234567@SpringBootApplication@EnableOAuth2Ssopublic class Oauth2client01demoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Oauth2client01demoApplication.class, args); &#125;&#125; 修改认证服务器配置 123456789101112131415161718192021222324252627@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;clients.inMemory() //配置client_id .withClient(&quot;admin&quot;) //配置client-secret .secret(passwordEncoder.encode(&quot;112233&quot;)) //配置访问token的有效期 .accessTokenValiditySeconds(3600) //配置刷新token的有效期 .refreshTokenValiditySeconds(864000) //配置redirect_uri，用于授权成功后跳转 // .redirectUris(&quot;http://www.baidu.com&quot;) //单点登录时配置 .redirectUris(&quot;http://localhost:8081/login&quot;) //配置申请的权限范围 .scopes(&quot;all&quot;) //自动授权配置 .autoApprove(true) //配置grant_type，表示授权类型 .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;,&quot;refresh_token&quot;);&#125;@Overridepublic void configure(AuthorizationServerSecurityConfigurer security) &#123; // 获取密钥需要身份认证，使用单点登录时必须配置 security.tokenKeyAccess(&quot;isAuthenticated()&quot;);&#125; 十、整合Shiro安全框架整合 Shiro 环境搭建Shiro 三大对象Subject 当前用户SecurityManager 管理所有用户Realm 连接数据 一、在pom文件中导入shiro的坐标依赖 12345678910&lt;!-- Shiro 三大对象 Subject 用户 SecurityManager 管理用户 Realm 连接数据 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; 二、创建Shiro的配置类一个ShiroConfig类: 该类有三大核心组件： getShiroFilterFactoryBean getDefaultWebSecrityManager userRealm 三大组件相互关联： DefaultWebSecrityManager与userRealm相关联 ShiroFilterFactoryBean与DefaultWebSecrityManager相关联 1234567891011121314151617181920212223242526272829303132333435//ShiroFilterFactoryBean : 3 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean ( @Qualifier(&quot;SecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); return bean; &#125; //DefaultWebSecrityManager :2 @Bean(name=&quot;SecurityManager&quot;) public DefaultWebSecurityManager getDefaultWebSecrityManager ( @Qualifier(&quot;userRealm&quot;) UserRealm userRealm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联UserRealm securityManager.setRealm(userRealm); return securityManager; &#125; //创建realm对象 ，需要自定义类 : 1 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125; 三、创建UserRealm类 并继承AuthorizingRealm类，重写其方法 重写的方法有两个： 1.授权-&gt;doGetAuthorizationInfo 2.认证-&gt;doGetAuthenticationInfo 12345678910111213141516171819202122232425//自定义的UserRealm extends AuthorizingRealmpublic class UserRealm extends AuthorizingRealm &#123; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo (PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行了—&gt; 授权doGetAuthorizationInfo&quot; ); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo (AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了—&gt; 认证doGetAuthorizationInfo&quot; ); return null; &#125;&#125; 实现登录拦截在getShiroFilterFactoryBean组件中 添加shiro的内置过滤器 该过滤器有五大权限: anon：无需认证就可以访问 authc：必需认证才能访问 user：必须拥有 记住我 功能才能用 perms：拥有对某个资源的权限才能访问 role：拥有某个角色权限才能访问 1234567891011121314151617181920212223242526272829303132333435//ShiroFilterFactoryBean : 3 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean ( @Qualifier(&quot;SecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置安全管理器 //defaultWebSecurityManager为 //DefaultWebSecurityManager组件的对象 bean.setSecurityManager(defaultWebSecurityManager); //添加shiro的内置过滤器 /* * anon：无需认证就可以访问 * authc：必需认证才能访问 * user：必须拥有 记住我 功能才能用 * perms：拥有对某个资源的权限才能访问 * role：拥有某个角色权限才能访问 * */ //登录拦截 Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); //添加需要拦截（未登录）的请求 filterChainDefinitionMap.put(&quot;/user/add&quot;,&quot;authc&quot;); filterChainDefinitionMap.put(&quot;/user/update&quot;,&quot;authc&quot;); //filterChainDefinitionMap.put(&quot;/user/*&quot;,&quot;authc&quot;); bean.setFilterChainDefinitionMap(filterChainDefinitionMap); //设置登录页面的路径(当拦截到未登录的请求时，跳转到该页面) bean.setLoginUrl(&quot;/toLogin&quot;); return bean; &#125; 实现用户认证 在登陆的controller中接收用户信息，并封装成一个token（令牌） 1234 UsernamePasswordToken token = new UsernamePasswordToken (username, password);//设置记住我//token.setRememberMe(true); 用当前用户进行登录 1234567891011121314151617181920212223@RequestMapping(&quot;/login&quot;) public String login(String username,String password,Model model)&#123; //获取当前的用户 Subject subject = SecurityUtils.getSubject(); //封装用户的登陆数据 UsernamePasswordToken token = new UsernamePasswordToken (username, password); try&#123; subject.login(token);//执行登录方法，如果没有异常就说明ok &#125;catch (UnknownAccountException e)&#123; model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;); return &quot;login&quot;; &#125;catch (IncorrectCredentialsException e)&#123; model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;); return &quot;login&quot;; &#125; return &quot;index&quot;; &#125; 然后 在userRealm类中的 认证—&gt;方法中对用户名进行认证。。 shiro不用验证密码，shiro自动认证 12345678910111213141516171819202122232425//认证 @Override protected AuthenticationInfo doGetAuthenticationInfo (AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了—&gt; 认证doGetAuthorizationInfo&quot; ); //用户名，密码 数据库中取 String username=&quot;root&quot;;//伪造数据 String password=&quot;123456&quot;; UsernamePasswordToken usertoken = (UsernamePasswordToken) authenticationToken; if(!usertoken.getUsername().equals(username))&#123; return null;//抛出用户名错误异常 UnknownAccountException &#125; //密码认证：shiro做 ,加密了 //该构造方法中三个参数： // 第一个参数为向授权方法中传递的用户信息， // 第二个参数为从数据库中查找的用户的密码，用于shiro验证登录的密码是否正确 return new SimpleAuthenticationInfo (admin,admin.getPassword(),&quot;&quot;); &#125; 整合mybatis的认证首先导入mybatis， mysql，jdbc的相关依赖坐标 在对数据源和mybatis进行配置 写好与登录所需查找用户表相关的mapper 以及其映射文件，及service类 然后 在userRealm类中的 认证—&gt;方法中，通过前端传来的username从数据库中获取 用户信息；并进行认证 1234567891011121314151617181920212223242526 @Autowired private AdminService service; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了—&gt; 认证doGetAuthorizationInfo&quot; ); UsernamePasswordToken usertoken = (UsernamePasswordToken) authenticationToken; //用户名，密码 数据库中取 Admin admin = service.findByUsername(usertoken.getUsername()); if (admin==null)&#123; return null; //UnknowAccountExeception 抛出用户名错误异常 &#125; //密码认证：shiro做 ,加密了 //该构造方法中三个参数： // 第一个参数为向授权方法中传递的用户信息， // 第二个参数为从数据库中查找的用户的密码，用于shiro验证登录的密码是否正确 return new SimpleAuthenticationInfo (admin,admin.getPassword(),&quot;&quot;); &#125;&#125; 实现权限设置在shiroConfig类中可以 对访问某个资源页面所需权限 进行设置 //拦截未拥有对/user/add资源的权限的请求，跳转到未授权页面 filterChainDefinitionMap.put(“/user/add”,”perms[user:add]”); 显示未授权信息的页面也可自己设置 //设置未授权页面的路径bean.setUnauthorizedUrl(“/noauth”); 12345678910111213141516171819202122232425262728293031323334353637 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean ( @Qualifier(&quot;SecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置安全管理器 bean.setSecurityManager(defaultWebSecurityManager); //添加shiro的内置过滤器 /* * anon：无需认证就可以访问 * authc：必需认证才能访问 * user：必须拥有 记住我 功能才能用 * perms：拥有对某个资源的权限才能访问 * role：拥有某个角色权限才能访问 * */ //设置权限 //登录拦截 Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); //拦截未拥有对/user/add资源的权限的请求，跳转到未授权页面 filterChainDefinitionMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); //拦截user下所有未认证请求 filterChainDefinitionMap.put(&quot;/user/*&quot;,&quot;authc&quot;);// filterChainDefinitionMap.put(&quot;/user/add&quot;,&quot;authc&quot;);// filterChainDefinitionMap.put(&quot;/user/update&quot;,&quot;authc&quot;); bean.setFilterChainDefinitionMap(filterChainDefinitionMap); //设置登录页面的路径 bean.setLoginUrl(&quot;/toLogin&quot;); //设置未授权页面的路径 bean.setUnauthorizedUrl(&quot;/noauth&quot;); return bean; &#125; 实现用户授权在UserRealm类的 授权-&gt;doGetAuthorizationInfo方法中对当前用户所拥有 用户权限进行授权 123456789101112131415//授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行了—&gt; 授权doGetAuthorizationInfo&quot; ); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //拿到当前登录的对象,该对象为 认证方法返回值的第一个参数 Subject subject = SecurityUtils.getSubject(); Admin admin = (Admin) subject.getPrincipal(); //给用户添加在ShiroConfig类中设置的相关权限。 //(参数为admin用户所拥有的权限) info.addStringPermission ( admin.getPerms() ); return info; &#125; shiro整合thymeleaf 导入相关依赖 123456&lt;!-- shiro整合thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 在shiroConfig中将ShiroDialect配置到容器中 用来整合shiro 和 thymeleaf 12345//整合ShiroDialect ：用来整合shiro 和 thymeleaf @Bean public ShiroDialect getShiroDialect()&#123; return new ShiroDialect(); &#125; 最后 使用 在拥有该权限时，显示该模块 1234567&lt;div shiro:hasPermission=&quot;user:add&quot;&gt; &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt; &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;&lt;/div&gt; 十一、整合Swagger简介 号称世界上最流行的Api框架 RestFul Api文档在线生成工具-&gt;Api文档与API定义同步更新 直接运行，可以在线测试API接口； 支持多种语言 springboot集成Swagger 新建一个springboot项目 导入相关依赖 1234567891011&lt;!-- swagger依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 创建SwaggerConfig类，@EnableSwagger2注解开启Swagger2 此时Swagger2已经可以使用，（设置为默认配置） 1234@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123;&#125; 测试运行： localhost:8080//swagger-ui.html 配置Swagger 再SwaggerConfig类中配置了Swagger的Docket的bean实例 123456789101112131415161718192021222324252627282930313233@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; //配置了Swagger的Docket的bean实例 @Bean public Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) //配置Swagger信息 .select() //RequestHandlerSelectors :配置要扫描接口的方式 //basePackage 指定要扫描的包 .apis(RequestHandlerSelectors.basePackage(&quot;com.xyc&quot;)) //.paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;))) //.paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;))) .build(); &#125; //配置Swagger信息 private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() .title(&quot;谷粒学院-SwaggerAPI文档&quot;) .description(&quot;本文档描述了课程中心微服务接口定义&quot;) .version( &quot;v1.0&quot;) .contact(new Contact(&quot;java&quot;,&quot;http://www.baidu.com&quot;,&quot;452662481@qq.com&quot;)) .build(); &#125;&#125; 十二、任务1、异步任务常规使用异步任务，我们需要自定义多线程，通过开启线程来处理异步任务 springboot使用异步任务，只需用@EnableAsync 注解开启异步任务功能，并在指定方法上使用@Async注解标注该方法为异步任务。 案例： 用一个AsyncService类模拟数据处理， 如果不使用异步任务，在提交请求后，系统会把数据处理完成后，才进行响应。 service 123456789101112131415161718192021222324252627282930package com.xyc.service;import org.springframework.stereotype.Service;/** * 2020/5/1 22:39 * 文件说明：模拟一个service 需要进行处理一个耗时时间长的任务 * * @author xyc * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Servicepublic class AsyncService &#123; public void hello()&#123; System.out.println(&quot;数据正在处理。。。&quot;); try &#123; System.out.println(&quot;数据3秒后处理完成。。。&quot;); Thread.sleep(1000); System.out.println(&quot;数据2秒后处理完成。。。&quot;); Thread.sleep(1000); System.out.println(&quot;数据1秒后处理完成。。。&quot;); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;数据处理完成。。。&quot;); &#125;&#125; controller 12345678910111213141516171819202122232425262728293031package com.xyc.controller;import com.xyc.service.AsyncService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * 2020/5/1 22:43 * 文件说明： * * @author xyc * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@EnableAsync@RestControllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @Async @RequestMapping(&quot;/hello&quot;) public String hello()&#123; asyncService.hello(); return &quot;hello&quot;; &#125;&#125; 2、定时任务主要的类与注解 12345678910TaskScheduler 任务调度者TaskExecutor 任务执行者@EnableScheduling &#x2F;&#x2F;开启定时功能的注解&#x2F;&#x2F;在特定时间执行这个方法&#x2F;&#x2F; 秒 分 时 日 月 周几@Scheduled(cron &#x3D; &quot;10 31 20 * * ?&quot;)cron表达式 使用案例 1234567891011@EnableScheduling//开启定时功能的注解@Servicepublic class ScheduledService &#123; //在特定时间执行这个方法 // 秒 分 时 日 月 周几 @Scheduled(cron = &quot;10 31 20 * * ?&quot;) public void hello()&#123; System.out.println(&quot;hello ya~&quot;); &#125;&#125; 3、邮件任务javaWeb原生的发送邮件需要手动配置好多的东西，使用springboot发送邮件，只需要在配置文件中配置邮件相关信息，并 new一个JavaMailSenderImpl类，并调用send方法即可。 在springboot中存在一个 MailSenderAutoConfiguration类，在里面面定义了对mail的自动配置。 在MailProperties.class类中定义了电子邮件支持的配置属性，即在application.yml配置文件中需要配置的相关属性 1234567891011121314151617181920@ConfigurationProperties(prefix = &quot;spring.mail&quot;)public class MailProperties &#123; private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8; /** SMTP server host. For instance, `smtp.example.com`.*/ private String host;//主机 smtp.XXX.com /** SMTP server port.*/ private Integer port;//端口 /** Login user of the SMTP server.*/ private String username;//用户名 /** Login password of the SMTP server.*/ private String password;//密码 /** Protocol used by the SMTP server.*/ private String protocol = &quot;smtp&quot;;//协议 /** Default MimeMessage encoding.*/ private Charset defaultEncoding = DEFAULT_CHARSET; /** Additional JavaMail Session properties.*/ private Map&lt;String, String&gt; properties = new HashMap&lt;&gt;(); /** Session JNDI name. When set, takes precedence over other Session settings.*/ private String jndiName; 并导入了MailSenderJndiConfiguration.class和MailSenderPropertiesConfiguration.class对邮件发送人进行自动配置，使我们在需要发送邮件时只需要直接调用JavaMailSenderImpl即可 1@Import(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;) javaMailSenderImpl实现了JavaMailSender接口，并同时支持JavaMail &#123;@link MimeMessage MimeMessages&#125;和Spring &#123;@link SimpleMailMessage SimpleMailMessages&#125;可以仅仅当做mailSender的实现类使用， 允许将所有设置本地定义为Bean属性。或者，可以指定一个预先配置的JavaMail {@link javax.mail.Session}，可以从应用程序服务器的JNDI环境中提取。 javaMailSenderImpl中发送邮件需要的的一些方法实现， 123456789101112131415161718192021 //--------------------------------------------------------------------- // Implementation of MailSender //--------------------------------------------------------------------- //发送简单邮件消息 public void send(SimpleMailMessage simpleMessage) throws MailException &#123;&#125; public void send(SimpleMailMessage... simpleMessages) throws MailException &#123; &#125; //--------------------------------------------------------------------- // Implementation of JavaMailSender //---------------------------------------------------------------------//返回一个MimeMessage类，此类用于定义发送邮件消息的相关信息 public MimeMessage createMimeMessage() &#123;&#125; public MimeMessage createMimeMessage(InputStream contentStream) throws MailException &#123;&#125;//发送复杂的邮件//包括支持html和可以发送附件，在使用时需要借助MimeMessageHelper类 public void send(MimeMessage mimeMessage) throws MailException &#123;&#125; public void send(MimeMessage... mimeMessages) throws MailException &#123;&#125; public void send(MimeMessagePreparator mimeMessagePreparator) throws MailException &#123;&#125; public void send(MimeMessagePreparator... mimeMessagePreparators) throws MailException &#123;&#125; 使用 导入坐标依赖 在yml文件中配置相关信息 编写邮件并发送 坐标依赖 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 配置信息 12345678spring: mail: username: 13072667463@163.com password: XYC123456 host: smtp.163.com #qq邮箱需要开启加密验证 使用 实例化 JavaMailSenderImpl类 发送简单邮件时，实例化SimpleMailMessage对象，并在里面配置所发送邮件的相关信息 发送复杂邮件时，通过JavaMailSenderImp的实例化对象，调用createMimeMessage()方法创建MimeMessage对象，并通过MimeMessageHelper对象配置所发送邮件的相关信息 可以通过Ctrl+左键点击类中，来查看发送邮件信息所需要的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.xyc.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import org.springframework.mail.javamail.MimeMailMessage;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Service;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import javax.xml.soap.MimeHeader;import java.io.File;/** * 2020/5/4 10:20 * 文件说明： * * @author xyc * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Servicepublic class MailService &#123; @Autowired private JavaMailSenderImpl mailSender; //简单的邮件 public void simpleSend()&#123; //创建简单邮件信息 SimpleMailMessage simpleMailMessage =new SimpleMailMessage(); //设置标题 simpleMailMessage.setSubject(&quot;你好啊！&quot;); //设置内容 simpleMailMessage.setText(&quot;哈哈哈哈哈&quot;); simpleMailMessage.setTo(&quot;452662481@qq.com&quot;); simpleMailMessage.setFrom(&quot;13072667463@163.com&quot;); mailSender.send(simpleMailMessage); &#125; public void mimeSend() throws MessagingException &#123; MimeMessage mimeMessage = mailSender.createMimeMessage(); // @param mimeMessage the mime message to work on // @param multipart whether to create a multipart message that // supports alternative texts, inline elements and attachments MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage,true); messageHelper.setSubject(&quot;你好啊&quot;); messageHelper.setText(&quot;&lt;p style=&#x27;color:red&#x27;&gt;薛云冲，&lt;br&gt;你订购的软件的验证码123123&lt;/p&gt;&quot;,true); messageHelper.setTo(&quot;452662481@qq.com&quot;); messageHelper.setFrom(&quot;13072667463@163.com&quot;); //添加附件 messageHelper.addAttachment(&quot;&quot;,new File(&quot;&quot;)); mailSender.send(mimeMessage); &#125;&#125; 十三、整合Redisspringboot在 RedisAutoConfiguration 中为我们自动配置了Redis RedisAutoConfiguration类 123456789101112131415161718192021222324252627282930@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)public class RedisAutoConfiguration &#123; @Bean //当redisTemplate不存在时使用下面的配置，即当我们需要自己定制redisTemplate时， //可以自行定义redisTemplate来替换这个默认值 @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; //默认的RedisTemplate没有过多的设置，redis对象都需要序列化 //两个泛型都是Object，Object的类型，使用时需要强制类型转换&lt;String ,Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean //由于string类型是redis最常用的类型，所以特别提出了一个类 public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 在application.yml配置文件中需要配置的相关属性在RedisProperties.class类中定义 RedisProperties.class类 12345678910111213141516171819202122@ConfigurationProperties(prefix = &quot;spring.redis&quot;)public class RedisProperties &#123; /** Database index used by the connection factory.*/ private int database = 0; /** Connection URL. Overrides host, port, and password. User is ignored. */ private String url; /** Redis server host.*/ private String host = &quot;localhost&quot;; /** Login password of the redis server.*/ private String password; /** Redis server port.*/ private int port = 6379; /**Whether to enable SSL support.*/ private boolean ssl; /** Connection timeout.*/ private Duration timeout; /** Client name to be set on connections with CLIENT SETNAME.*/ private String clientName; private Sentinel sentinel; private Cluster cluster; private final Jedis jedis = new Jedis(); private final Lettuce lettuce = new Lettuce(); 使用1、导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置连接 12345spring: redis: host: 127.0.0.1 post: 6379 3.测试 12345678910111213141516@Autowired RedisTemplate redisTemplate; @Test void contextLoads() &#123; // opsForValue() // opsForList() // opsForSet() // opsForHash() // opsForZSet() // opsForGeo() // opsForHyperLogLog() redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;myValue&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;)); &#125; 十四、消息队列rabbitmq简介RabbitMQ是一个erlang开发的AMQP（Advanved Message Queue Protoco）的开源实现 核心概念Message：消息，消息不是具体名，它是由消息头和消息体组成，消息体是不透明的，而消息头则是由一系列的可选的属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher：消息生产着，也是一个向交换器发布消息的客户端应用程序。 Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange（四种类型）：1、direct（默认），fanout，topic，headers，不同类型的Exchange的转发消息的策略有区别 Queue：消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走 Binding：绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 Exchange和Queue之间绑定是多对多的关系。 Conection：网络连接 Channel：信道，多路复用链接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息，订阅队列还是接受信息都是通过信道完成。 Consumer：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序 Virtual Host：虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。 Broker：表示消息队列服务器实体 RabbitMQ运行图解 Exchange（四种类型） 1、direct（默认）：（单播模式）完全匹配，点对点 2、fanout：（广播模式，发布订阅）fanout交换器不会处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。 3、topic：通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定在一个模式上。他将路由键和绑定键的字符串分为多个单词，这些单词之间用点隔开。他同样也会识别两个通配符：符号“#”：匹配0个或多个单词，“*”匹配一个单词。 4、headers，headers匹配的是消息头而不是路由键，和direct一样完全匹配，点对点，性能不行，不怎么用 rabbitMQ使用使用Docker安装RabbitMQ 12345# 拉取镜像docker pull rabbitmq:3-management# 启动镜像 docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 镜像id 可以通过 15672端口访问Web界面 Web界面的登录密码 默认用户：guest 密码：guest 添加Exchange 添加queue Exchange bind queue 发送消息 接收消息 整合RabbitMQ自动装配 探究Springboot自动装配RabbitMQ 我们先搜索 RabbitAutoConfiguration 该类为RabbitMQ自动配置类 里面有三个静态内部类 1、RabbitConnectionFactoryCreator类中的rabbitConnectionFactory方法将rabbit的连接对象注入容器，rabbitConnectionFactory方法的参数RabbitProperties中封装了配置RabbitMQ的所有配置，即我们在配置文件中写的配置信息. RabbitProperties类,为获取配置文件内容的类 2、RabbitTemplateConfiguration类中配置了RabbitTemplate，amqpAdmin RabbitTemplate: RabbitMQ发送消息和接受消息 AmqpAdmin：RabbitMQ系统管理功能组件 使用1、导入pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置文件中配置rabbitmq 12345spring.rabbitmq.host=47.94.45.85spring.rabbitmq.port=5672#端口号不写默认是 5672#用户密码不写，默认是 guest#虚拟主机不写默认是 &quot;/&quot; 3、测试使用 发送信息 12345//Message需要自己构造一个:定义消息体和消息头//rabbitTemplate.send(exchange,routeKey,message);//object默认当做message，只需要传入要发送的对象，自动序列化发送给RabbitMQ//rabbitTemplate.convertAndSend(exchange,routeKey,object); 单播模式（direct） 12345678910111213141516@Autowired RabbitTemplate rabbitTemplate; /* * 1、单播（点对点） * */ @Test void contextLoads() &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,&quot;这是第一个&quot;); map.put(&quot;data&quot;, Arrays.asList(&quot;helloworld&quot;,123,true)); //对象被默认序列化以后发送出去 rabbitTemplate.convertAndSend (&quot;exchange.direct&quot;,&quot;atguigu.news&quot;,map); &#125; 广播模式（fanout） 12345678910/** * 广播 */ @Test public void sendMsg() &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,&quot;这是第二个&quot;); map.put(&quot;name&quot;,&quot;西游记&quot;); rabbitTemplate.convertAndSend(&quot;exchange.fanout&quot;,&quot;&quot;,map); &#125; 此时，无论单播、广播，所使用的MessageConverter都是默认的，在序列化时使用的Java的序列化，在消息队列中的是通过Java的序列化编码的格式 而我们一般都会发送Json格式的数据，此时就需要我们自己配置MessageConverter 123456789101112@Configurationpublic class MyAmqpConfig &#123; /** * 配置Json格式的MessageConverter * 当我们自己配置过MessageConverter之后， * 会使用我们配置的MessageConverter * */ @Bean public MessageConverter messageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125;&#125; 当我们配置好Json格式的MessageConverter之后，再发送消息 接受消息 1234567891011/** * 接受数据， */ @Test public void receive()&#123; //接受指定的消息队列中的消息，并返回一个Message //Message receive = rabbitTemplate.receive(&quot;atguigu.news&quot;); Object o = rabbitTemplate.receiveAndConvert(&quot;atguigu.news&quot;); System.out.println(o.getClass()); System.out.println(o); &#125; 结果： 消息监听 用来监听消息队列中收到的消息 只需要两个注解@EnableRabbit + @RabbitListener 监听消息队列的内容 @EnableRabbit；开启基于注解的RabbitMQ模式 @RabbitListener ：监听指定的消息队列 案例： 开启注解 12345678910//开启基于注解的RabbitMQ模式@EnableRabbit@SpringBootApplicationpublic class SpringbootAmqpApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootAmqpApplication.class, args); &#125;&#125; 启动监听 123456789101112131415@Servicepublic class BookService &#123; @RabbitListener(queues = &quot;atguigu.news&quot;) public void receive01(Book book)&#123; System.out.println(&quot;收到消息：&quot;+book); &#125; @RabbitListener(queues = &quot;atguigu&quot;) public void receive02(Message message)&#123; System.out.println(message.getBody()); System.out.println(message.getMessageProperties()); &#125;&#125; 当使用这两个注解之后，每次向指定该消息队列中发送消息时，这两个方法就会自动从该消息队列中获取消息。 结果展示： 管理RabbitMQ的组件 AmqpAdmin：RabbitMQ系统管理功能组件,可以创建、删除 queue Exchange Binding 使用案例 12345678910111213141516171819202122232425@Autowired AmqpAdmin amqpAdmin; @Test public void createExchange()&#123; //以declare***开头的 一般都是 amqpAdmin.declareExchange(new DirectExchange(&quot;amqpadmin.exchange&quot;)); System.out.println(&quot;创建成功&quot;); amqpAdmin.declareQueue(new Queue(&quot;amqpadmin.queue&quot;,true)); System.out.println(&quot;创建成功&quot;); amqpAdmin.declareBinding(new Binding(&quot;amqpadmin.queue&quot;, Binding.DestinationType.QUEUE, &quot;amqpadmin.exchange&quot;,&quot;amqp.haha&quot;,null)); //以delete或remove开头的一般都是删除 amqpAdmin.removeBinding(new Binding(&quot;amqpadmin.queue&quot;, Binding.DestinationType.QUEUE, &quot;amqpadmin.exchange&quot;,&quot;amqp.haha&quot;,null)); amqpAdmin.deleteQueue(&quot;amqpadmin.queue&quot;); amqpAdmin.deleteExchange(&quot;amqpadmin.exchange&quot;); &#125; 十五、ElasticSearchElasticsearch概述Elasticsearch是一个分布式、高度可扩展的开源全文本搜索和分析引擎。它使您可以快速，近乎实时地存储，搜索和分析大量数据。它通常用作支持具有复杂搜索功能和要求的应用程序的基础引擎/技术。 Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene基础之上,Lucene 仅仅只是一个库。 Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎, Elasticsearch 是 一个分布式的实时文档存储，每个字段 可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据 安装123456# 拉取镜像docker pull docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.9.3# 运行docker run -d -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS&#x3D;&quot;-Xms512m -Xmx512m&quot; -e -Des.scripting.exception_for_missing_value&#x3D;true --name elasticsearch 镜像ID 安装成功标志 简介Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档。Elasticsearch 不仅存储文档，而且 索引 每个文档的内容，使之可以被检索。在 Elasticsearch 中，我们对文档进行索引、检索、排序和过滤—而不是对行列数据。 Elasticsearch 使用 JSON 作为文档的序列化格式。 例：这就代表一个User对象 1234567891011&#123; &quot;email&quot;: &quot;john@smith.com&quot;, &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;info&quot;: &#123; &quot;bio&quot;: &quot;Eco-warrior and defender of the weak&quot;, &quot;age&quot;: 25, &quot;interests&quot;: [ &quot;dolphins&quot;, &quot;whales&quot; ] &#125;, &quot;join_date&quot;: &quot;2014/05/01&quot;&#125; 一个 Elasticsearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。 索引（名词）：如前所述，一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes 。 索引（动词）：索引一个文档 就是存储一个文档到一个 索引 （名词）中以便被检索和查询。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时，新文档会替换旧文档情况之外。 入门使用新增（索引）员工PUT请求 ==注意：== 新增是发PUT请求 路径 /megacorp/employee/1 包含了三部分的信息： megacorp 索引名称 employee 类型名称 1 特定雇员的ID 请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息， 他的名字叫 John Smith ，今年 25 岁，喜欢攀岩。 响应 修改员工和新增时的操作是一样的，都是PUT请求 此次对ID为1的员工进行修改 响应结果： ==注意==：和上面 第一次添加时进行对比，可以发现_version变为了 2 检索（查找）员工get请求 响应 查找成功 查找失败 轻量搜索数据依然是get请求，但是此时并没有指定文档ID，而是使用_search.返回结果放在一个hits数组中，默认一个搜索返回十条数据 _search 无参数返回结果放在一个hits数组中，默认一个搜索返回十条数据 _search 带参数 将查询本身赋值给参数q=，返回所有last_name为Smith的员工 查询表达式搜索领域特定语言 （DSL）， 使用 JSON 构造了一个请求。 案例1 响应和上面查询的结果一样 案例2 查询姓氏为Smith ，年龄大于30 的员工 全文搜索查询所有喜欢攀岩（rock climbing）的员工 响应结果： 查询结果不但返回了John Smith 还返回了Jane Smith ，Jane Smith的about中只有rock albums 而没有 rock climbing 。 原因 Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。 短语搜索找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者_短语_ 。 为此对 match 查询稍作调整，使用一个叫做 match_phrase 的查询 高亮查询在查询时，增加一个新的 highlight 参数 响应 当执行该查询时，返回结果与之前一样，与此同时结果中还多了一个叫做 highlight 的部分。这个部分包含了 about 属性匹配的文本片段，并以 HTML 标签 &lt;em&gt;&lt;/em&gt; 封装： 深入学习《Elasticsearch: 权威指南》 https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html","categories":[{"name":"springboot","slug":"springboot","permalink":"http://javacoderx.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://javacoderx.github.io/tags/springboot/"}]},{"title":"docker","slug":"docker","date":"2021-04-23T09:35:55.000Z","updated":"2021-04-23T01:38:27.829Z","comments":true,"path":"2021/04/23/docker/","link":"","permalink":"http://javacoderx.github.io/2021/04/23/docker/","excerpt":"","text":"","categories":[{"name":"docker","slug":"docker","permalink":"http://javacoderx.github.io/categories/docker/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://javacoderx.github.io/tags/spring/"},{"name":"docker","slug":"docker","permalink":"http://javacoderx.github.io/tags/docker/"}]}],"categories":[{"name":"springboot","slug":"springboot","permalink":"http://javacoderx.github.io/categories/springboot/"},{"name":"docker","slug":"docker","permalink":"http://javacoderx.github.io/categories/docker/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://javacoderx.github.io/tags/springboot/"},{"name":"spring","slug":"spring","permalink":"http://javacoderx.github.io/tags/spring/"},{"name":"docker","slug":"docker","permalink":"http://javacoderx.github.io/tags/docker/"}]}