{"meta":{"title":"太阳以西？","subtitle":"太阳以西有些什么？","description":"专注 WEB 开发的技术博客","author":"xyc","url":"http://javacoderx.github.io","root":"/"},"pages":[{"title":"","date":"2021-04-22T12:33:48.143Z","updated":"2021-04-22T12:33:48.143Z","comments":true,"path":"about/index.html","permalink":"http://javacoderx.github.io/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 PHP，熟悉使用 Laravel、ThinkPHP 等主流框架；对 Modern PHP 情有独钟；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：深圳 关于学习正在往终身学习者前进…近期学习方向：Python (人工智能) 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱羽毛球、阅读、电影（Top250）、旅行。 联系我 Home: minhow.com Blog: blog.minhow.com Email: &#104;&#x75;&#x61;&#x6e;&#x67;&#109;&#x69;&#x6e;&#x68;&#111;&#x77;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109; GitHub: MinHow WeiBo: MinHow Twitter: MinHow"}],"posts":[{"title":"带你手动编译openjdk","slug":"openjdk","date":"2021-04-23T21:32:16.000Z","updated":"2021-04-23T13:36:07.966Z","comments":true,"path":"2021/04/24/openjdk/","link":"","permalink":"http://javacoderx.github.io/2021/04/24/openjdk/","excerpt":"","text":"正在学习《深入理解java虚拟机第2版》，在第一章的实例中，自己动手对openjdk7进行编译。以下是实验过程。本实验是在ubuntu14.04下进行的，编译的openjdk为openjdk 7，依赖的jdk为openjdk 6 在编译openjdk7时，Bootstrap JDk必须使用 Jdk6 update 14 或之后的版本 openjdk7源码获取直接从官网下载源码包即可 openJDK7 获取源码包之后，需要对源码包进行解压 1unzip openjdk-7u75-src-b13-18_dec_2014.zip 安装依赖在使用下面的命令可一次安装完成 1apt install build-essential gawk m4 libmotif3 libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif-dev ant 遇见问题1： 如果系统使用的是ubuntu16.04； 安装 libmotif3 时 如果出现错误 E: Package &#39;libmotif4&#39; has no installation candidate 只是因为在最新的Ubuntu 16.04中不存在libmotif4，因此会发生此错误。 我们只需从https://launchpad.net/ubuntu/xenial/amd64/libmotif4/2.3.4-8ubuntu1中下载deb文件，从文件下载到的目录运行以下命令： 1sudo dpkg -i libmotif4_2.3.4-8ubuntu1_amd64.deb 安装BootStrap jdk6 1apt install openjdk-6-jdk 进行编译此时我们需要的编译环境和依赖项目都准备完成，最后只需对系统的环境变量进行简单设置以便编译的顺利通过。 设置LANG 和ALT_BOOTDIR,必须设置 1234567891011121314151617181920212223242526272829303132333435#语言选项，这个必须设置，否则编译好后会出现一个HashTable的NPE错export LANG&#x3D;C#Bootstrap JDK的安装路径。必须设置export ALT_BOOTDIR&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.6.0-openjdk-amd64#允许自动下载依赖export ALLOW_DOWNLOADS&#x3D;true#并行编译的线程数，设置为和CPU内核数量一致即可export HOTSPOT_BUILD_JOBS&#x3D;6export ALT_PARALLEL_COMPILE_JOBS&#x3D;6#比较本次build出来的映像与先前版本的差异。这对我们来说没有意义，#必须设置为false，否则sanity检查会报缺少先前版本JDK的映像的错误提示。#如果已经设置dev或者DEV_ONLY&#x3D;true，这个不显式设置也行export SKIP_COMPARE_IMAGES&#x3D;true#使用预编译头文件，不加这个编译会更慢一些export USE_PRECOMPILED_HEADER&#x3D;true#要编译的内容export BUILD_LANGTOOLS&#x3D;true#export BUILD_JAXP&#x3D;false#export BUILD_JAXWS&#x3D;false#export BUILD_CORBA&#x3D;falseexport BUILD_HOTSPOT&#x3D;trueexport BUILD_JDK&#x3D;true#把它设置为false可以避开javaws和浏览器Java插件之类的部分的buildBUILD_DEPLOY&#x3D;false#把它设置为false就不会build出安装包。因为安装包里有些奇怪的依赖，#但即便不build出它也已经能得到完整的JDK映像，所以还是别build它好了BUILD_INSTALL&#x3D;false 如果之前设置了JAVA_HOME和CLASSPATH两个环境变量 ，在编译之前必须取消，否则会发生”诡异的事情“ 12unset CLASSPATHunset JAVA_HOME 在设置完成之后，可以输入 make sanity来检查我们前面的设置是否全部正确 123root@ubuntu:~# cd openjdkroot@ubuntu:~&#x2F;openjdk# make sanity makefile的Sanity检查过程输出了编译所需的所有环境变量，如果看见‘ Sanity check passed. ’则代表检查通过。 12345678910111213141516171819202122232425262728293031Build Platform Settings: USER &#x3D; root PLATFORM &#x3D; linux ARCH &#x3D; amd64 LIBARCH &#x3D; amd64 ARCH_FAMILY &#x3D; amd64 ARCH_DATA_MODEL &#x3D; 64 ARCHPROP &#x3D; amd64 ALSA_VERSION &#x3D; 1.1.0 OS_VERSION &#x3D; 4.15.0-107-generic [requires at least 2.6] OS_VARIANT_NAME &#x3D; Ubuntu OS_VARIANT_VERSION &#x3D; 16.04 MB_OF_MEMORY &#x3D; 2978 -----------------------------省略部分------------------------------ Previous JDK Settings: PREVIOUS_RELEASE_PATH &#x3D; USING-PREVIOUS_RELEASE_IMAGE ALT_PREVIOUS_RELEASE_PATH &#x3D; PREVIOUS_JDK_VERSION &#x3D; 1.6.0 ALT_PREVIOUS_JDK_VERSION &#x3D; PREVIOUS_JDK_FILE &#x3D; ALT_PREVIOUS_JDK_FILE &#x3D; PREVIOUS_JRE_FILE &#x3D; ALT_PREVIOUS_JRE_FILE &#x3D; PREVIOUS_RELEASE_IMAGE &#x3D; &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-amd64 ALT_PREVIOUS_RELEASE_IMAGE &#x3D; Sanity check passed. 接下来可以输入make执行整个OpenJDK 编译（make不带参数 ， 默认为make all） 编译的时间有点长，耐心等待。。。 遇见问题2：使用‘make’编译时会，出现 check_os_version 错误，这是为了阻止源码在老版本上被编译 解决方法： 方法一： 添加对应的内核版本SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3% 4%方法二： 在make时添加参数 DISABLE_HOTSPOT_OS_VERSION_CHECK=ok 我使用的是方法二 1make DISABLE_HOTSPOT_OS_VERSION_CHECK&#x3D;ok 遇见问题3：time is more than 10 years from present 12345Error: time is more than 10 years from present: 1136059200000java.lang.RuntimeException: time is more than 10 years from present: 1136059200000 at build.tools.generatecurrencydata.GenerateCurrencyData.makeSpecialCaseEntry(GenerateCurrencyData.java:285) at build.tools.generatecurrencydata.GenerateCurrencyData.buildMainAndSpecialCaseTables(GenerateCurrencyData.java:225) at build.tools.generatecurrencydata.GenerateCurrencyData.main(GenerateCurrencyData.java:154) 解决方法： 修改jdk/src/share/classes/java/util/CurrencyData.properties文件 1vim jdk&#x2F;src&#x2F;share&#x2F;classes&#x2F;&#x2F;java&#x2F;util&#x2F;CurrencyData.properties 12345678910#修改108AZ&#x3D;AZM;2019-12-31-20-00-00;AZN#修改381行MZ&#x3D;MZM;2019-06-30-22-00-00;MZN#修改443行RO&#x3D;ROL;2019-06-30-21-00-00;RON#修改535行TR&#x3D;TRL;2019-12-31-22-00-00;TRY#修改561行VE&#x3D;VEB;2019-01-01-04-00-00;VEF vim显示怎么行号？ 按ESC键 然后输入:set nu ，回车 即可 改过之后 按ESC键 然后输入:wq ，保存并退出 即可 下面是编译成功的结果 123456789101112#-- Build times ----------Target all_product_buildStart 2020-07-06 20:05:03End 2020-07-06 20:12:1800:00:08 corba00:00:05 hotspot00:00:02 jaxp00:00:02 jaxws00:06:56 jdk00:00:02 langtools00:07:15 TOTAL------------------------- 编译完成","categories":[{"name":"openjdk","slug":"openjdk","permalink":"http://javacoderx.github.io/categories/openjdk/"}],"tags":[{"name":"openjdk","slug":"openjdk","permalink":"http://javacoderx.github.io/tags/openjdk/"}]},{"title":"深入理解JVM虚拟机---类加载、内存区域、GC","slug":"jvm","date":"2021-04-23T21:24:21.000Z","updated":"2021-04-23T13:30:54.952Z","comments":true,"path":"2021/04/24/jvm/","link":"","permalink":"http://javacoderx.github.io/2021/04/24/jvm/","excerpt":"","text":"Java是跨平台语言，图示 1、类加载器 类加载器子系统：从文件系统或网络中加载class文件，class文件在文件开头有特定的文件标识 CAFEBABE 类加载器加载的类信息，会放在方法区的内存空间。 1.1、类加载的过程加载阶段： 1、通过类的全限定类名获取此类的二进制流 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接阶段 验证（Verify）： 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，确保被加载类的正确性。不会危害虚拟机自身安全 四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。 准备 为类变量分配内存并设置该类的默认初始化值。 不包含用final修饰的static ，因为final在编译的时候就会分配了，准备阶段会显示初始化； 不会为实例变量分配初始化，类变量会分配在方法区，实例变量会随着对象一起分配到Java堆中。 解析 将常量池内的符号引用转换为直接引用的过程 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。直接引用就是指向目标的指针、相对偏移量或者一个间接定位到目标的句柄 解析动作主要针对 类或接口、字段、类方法、方法类型等 初始化阶段 初始化阶段就是执行类构造方法的过程 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来 构造器方法中指令是按照语句在文件中出现的顺序执行 &lt;Clinit&gt;( )不同于类的构造器。（注意：类构造器是虚拟机视角下的&lt;init&gt;()） 若该类有super类，JVM会保证子类的&lt;clinit&gt;()执行前，super类的&lt;clinit&gt;已经执行完毕 虚拟机必须保证一个类的&lt;clinit&gt;方法在多线程下被同步加锁 1.2、类加载器的分类总的来说类加载器分为两大类：引导类加载器，用户自定义类加载器 如图所示： 在图中除了Bootstrap Class Loader以外，其他的类加载器都直接或间接的继承ClassLoader 1.2.1、引导类加载器 （启动类加载器 Bootstrap Class Loader） c/c++实现，嵌套在JVM内部 用来加载JAVA核心库（jre/lib/rt.jar 、resource.jar 或者sun.boot.class.path路径下的内容，用于提供JVM自身需要的类） 没有继承 ClassLoader 加载 扩展类和应用程序类加载器，并指定他们的父类加载器 只加载java、javax、sun开头的类 1.2.2、扩展类加载器 （Extension ClassLoader） java编写的 派生于ClassLoader类 是由引导类加载器 加载的 从java.ext.dirs系统属性所制定的目录下加载类库，或者从JDK的安装目录jre/lib/ext子目录下加载类库。用户创建的JAR放在此位置，也会自动由扩展类加载器加载 1.2.3、应用程序类加载器 （系统类加载器 AppClassLoader） java编写 派生于ClassLader 由扩展类加载器 加载 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 该类加载程序中默认的类加载器 通过ClassLoader.getSystemClassLoader()方法可以获取该类加载器 1.2.4、用户自定义类加载器为什么要自定义类加载器？ 隔离加载类 修改类加载的方式 扩展加载源 防止源码泄露 自定义类加载器实现步骤 1、可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求 2、在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载器，但是在JDK1.2之后，不建议覆盖loadClass（）方法，而是建议把自定义的类加载逻辑写在findClass（）方法中 3、在编写自定义类加载器时，如果没有太复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass（）方法及其获取字节码流的方式。 1.3、ClassLoader类的常用方法 方法名称 描述 getParent（） 返回该类加载器的超类加载器 loadClass（String name） 加载名称为name的类，返回java.lang.Class类的实例 findClass（String name） 使用指定的二进制名称查找类。 findLoadedClass（String name） 查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例 defineClass（String name ，byte[] b , int off , int len） 将一个 byte 数组转换为java.lang.Class类的实例。 resolveClass(Class&lt;?&gt; c) 连接指定的一个java类 获取ClassLoader的方法 1、class.getClassLoader() ：获取当前类的类加载器 2、Thread.currentThread().getContextClassLoader(); 获取当前线程上下文的ClassLoader 3、ClassLoader.getSystemClassLoader();获取当前系统的ClassLoader 4、DriverManager.getCallerClassLoader() 获取调用者的ClassLoager000 1.4、双亲委派机制工作原理 1、如果一个类加载器收到了类加载得请求，他并不会自己去加载，而是把这个请求委托给父类加载器去执行 2、如果父类加载器还存在父类加载器，则进一步向上委托，依次递归请求，最终将到达引导类加载器 3、如果父类加载器可以完成加载任务，就成功返回，若父类加载器无法完成加载任务，子类加载器才会尝试自己去加载 ==注意：==这里说的父类加载器，指的是加载该类加载器的类加载器 优势 1、避免类的重复加载 2、保护程序安全，防止核心api被篡改。 1.5、类的使用方式 类的使用方式分为主动使用和被动使用 主动使用 1、创建类的实例 2、访问某个类或借口的静态变量，或者对静态变量赋值 3、调用类的静态方法 4、反射 5、初始化一个类的子类 6、Java虚拟机启动时被标明为启动类的类 7、JDK7开始提供的动态语言支持 其他的使用JAVA类的方式都是类的被动使用，都不会进行类的初始化 2、运行时数据区 Java虚拟机定义了部分程序运行期间会使用运行时数据区，其中一部分随虚拟机的创建销毁而创建销毁，一部分是跟线程对应的 运行时数据区内存模型 2.1、程序计数器 (program Counter Register) 程序计数寄存器 又称PC寄存器 作用：PC寄存器用来存储当前线程指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。 是一块较小的内存空间 每一条Java虚拟机线程都有自己的pc寄存器。 可看作当前线程所执行的字节码的行号指示器 任意时刻，一条Java虚拟机线程只会运行一个方法，该方法被称为当前方法 若该方法不是native的，那pc寄存器就保存Java虚拟机正在执行的字节码指令的地址 若是native的，那么pc寄存器的值是undefined。 pc寄存器的容量，至少可以存一个returnAddress类型的数据或者一个与平台相关的 本地指针的值 此区域是唯一一个在Java虚拟机规范中没有规定任何OurOfMemoryError情况的区域 2.2、Java虚拟机栈Java虚拟机栈是什么？ java虚拟机栈（Java Virtual Machine Stack），早期也叫java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用。 一个栈帧对应着一个方法 生命周期 随着线程的创建而创建，消失而消失。 作用 主管Java程序的运行，他保存方法的局部变量、部分结果、并参与方法的调用和返回。 异常 Java虚拟机规范允许栈的大小是动态的或者固定不变的 如果线程请求的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机抛出StackOverflowError异常 如果Java虚拟机栈可以动态扩展，在尝试扩展时无法申请足够内存，或创建新的线程时没有足够内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出OutOfMemoryError异常 2.2.1、栈的存储单位每个线程都有私有的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在的 在线程中正在执行的每个方法都各自对应一个栈帧（Frame） 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中各种数据信息 注意：不同线程中所包含的栈帧是不允许存在相互引用的，既不可能 在一个栈帧之中引用另外一个线程的栈帧。 Java方法的两种返回函数的方式 一种是通过return指令进行正常的函数返回，另外一种是抛出异常，不管使用哪种方式，都会导致栈帧被弹出。 2.2.2、栈帧的存储结构在栈帧中存储着： 局部变量表（Local Variables） 操作数栈（Operand Stack）（或表达式栈） 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或异常退出的定义） 一些附加信息 1、局部变量表 定义为一个数组，用于存储方法参数和定义在方法体内的局部变量，包括基本数据类型、对象引用、returnAddress类型 局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。 局部变量表的大小是在编译期确定下来的。方法运行期间不会改变局部变量表的大小 局部变量表随着方法栈帧的销毁而销毁 局部变量表的基本存储单位：Slot（变量槽） 在局部变量表里，32位以内的类型只占用一个Slot（包括returnAddress类型），64位的类型（long或double）占用两个Slot。 ==非静态方法栈帧的局部变量表中索引为零的位置上会多一个this（对当前对象的引用）== 局部变量与成员变量在赋值时的区别 变量的分类：按照数据类型分：1、基本数据类型；2、引用数据类型 按照在类中声明的位置分：1、成员变量（类变量，实例变量）；2、局部变量 成员变量：在使用前，都默认的初始化赋值 类变量 ：lingking的prepare阶段：给类变量默认赋值 —&gt; inital阶段：给类变量显示赋值； 实例变量：随着对象的创建，在堆空间中分配实例变量空间，并进行默认赋值 局部变量：在使用前，必须显示赋值，否则编译不通过。 2、操作数栈 在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，及入栈（push）、出栈（pop）。 主要保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间 操作数栈的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。 在操作数栈里，32位以内的类型只占用一个栈单位深度，64位的类型（long或double）占用两个栈单位深度。 通过i++和++i理解 操作数栈 3、动态链接 指向运行时常量池的方法引用 每个栈帧内部都包含一个指向运行时常量池中==该栈帧所属方法的引用==。包含这个引用的目的就是为了就是为了支持当前方法的代码能够实现动态链接。 动态链接的作用 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用被保存在class文件的常量池中。 描述一个方法调用另外其他方法时，就是通过常量池中指向方法的符号引用来表示的，动态链接就是为了将这些符号引用转换为调用方法的直接引用。 4、方法的调用在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 （以下内容理解时想想多态） 静态链接： 当一个字节码文件被转载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接 动态链接 如果被调用的方法在编译期无法被确定下来，即只能在程序运行期将调用方法的符号引用转换为直接引用。由于这种引用转换的过程具备动态性，因此也就被称之为动态链接 方法的绑定机制 对应的方法的绑定机制：早期绑定和晚期绑定。绑定是一个字段，方法或者类在符号引用被替换为直接引用弄个的过程，这仅仅发生一次 虚方法和非虚方法 普通调用指令 invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用方法，私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令 invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法 方法重写的本质 1、找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。 2、如果在类型C中找到与常量池中的描述符和简单名称都符合的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。 3、否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。 4、如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常 虚方法表 在面向对象的编程中，会频繁的使用动态分派，如果每次动态分派的过程都要重新在类的方法元数据中搜索合适的目标的话就会影响到执行效率。 为了提高性能，JVM采用在类的方法区建立一个虚方法表来实现。使用索引表来替代查找。 每个类都有一个虚方法表，表中存放着各种方法的实际入口。 虚方法表的创建时间 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 5、方法返回地址 存放调用该方法的pc寄存器的值。 方法的结束方式 1、正常执行完成 2、出现未处理的异常，非正常退出 正常退出，调用者的PC寄存器的值作为返回地址， 异常退出，返回地址是通过异常表来确定的，栈帧中不会存储这部分信息 6、附加信息栈帧中还允许携带一些与Java虚拟机实现相关的一些附加信息。不一定有 2.3、本地方法栈 Native Method 是一个Java调用非Java代码的接口。 用于支持native方法（指使用java以外的其他语言写的方法）的执行。 如果虚拟机支持该栈，则该栈在线程创建时创建 可固定大小，也可根据计算动态扩展和收缩 可能的异常与Java虚拟机栈一样 当某个线程调用一个本地方法时，他就不在受虚拟机限制，和虚拟机有相同的权限 2.4、堆2.4.1、概述 一个JVM实例只存在一个堆内存，在JVM启动的时候即被创建，其空间大小也被确定。是JVM管理的最大的一块内存空间 堆内存大小可调节 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上视为连续的 所有线程都共享Java堆，还可以划分线程私有的缓冲区。 《Java虚拟机规范》描述：所有的对象实例以及数组都应当在运行时分配在堆上。 “几乎”所有的对象实例都在这里分配内存。 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。 栈、堆、方法区的联系 2.4.2、堆内存细分现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为： JDK7及之前：堆内存逻辑上分为新生区，养老区，永久区。 JDK8及以后：堆内存逻辑上分为新生区，养老区，元空间。 约定： 新生区&lt;=&gt;新生代&lt;=&gt;年轻代； 养老区&lt;=&gt;老年区&lt;=&gt;老年代 永久区&lt;=&gt;永久代 堆内存结构示意图 2.4.3、设置堆空间大小可以通过-Xmx,-Xms来进行设置堆空间大小 -Xms：用于表示堆区的起始内存，等价于-XX:InitialHeapSize -Xmx：用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区中的内存大小超过-Xmx所指定的最大内存时，将会抛出OutOfMemoryError异常 通常将 -Xms和Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分割计算堆区的大小，从而提高性能 默认情况下，初始内存大小：物理内存大小的 1/64 最大内存大小：物理内存大小的 1/4 查看设置的参数： 方式一：cmd中jps， jstat -gc 进程id 方式二：加参数-XX:+PrintGCDeTails 2.4.4、新生代与老年代存储在JVM中的Java对象分为两类： 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常快 一类是生命周期非常长的对象 堆可细分为年轻代、老年代 年轻代又可以划分为 Eden空间，Survivor0（from区），Survivor1空间（to区） 配置新生代与老年代在堆结构的占比 默认 -XX:NewRatio=2,表示新生代占1，老年代占2，新生代占整个堆得1/3 修改为-XX:NewRatio=4,表示新生代占1，老年代占4，新生代占整个堆得1/5 设置新生代中Eden区与Survivor区比例 HotSpot中，新生代的Eden空间和另外两个Survivor空间所占比例，默认为8:1:1（官网） 但是事实上通过JVisualVM发现，并不是8:1:1，而是6:1:1；这是因为开启了自适应的内存分配策略。 可以通过-XX:SurvivorRatio=8来调整这个空间比例为8:1:1。 ==几乎所有的对象都是从“Eden”区new出来的==，绝大部分的Java对象的销毁都在新生代进行 -Xmn：设置新生代的空间大小，一般使用默认值 2.4.5、图解对象分配过程 总结： 针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to。 关于垃圾回收：频繁在新生代收集，很少在老年代收集，机会不在永久代/元空间收集 对象分配的特殊情况 2.4.6、区分Minor GC(Y GC) 、Major GC、Full GC 在JVM进行GC时，并非每一次都会对（新生代、老年代、方法区）进行一起回收，一般回收的都是新生代 针对HotSpot VM的实现，里面的GC按照回收区域划分为两种类型：部分收集（Partial GC），一种是整堆收集（Full GC）； 部分收集：不是对整个Java堆进行垃圾回收 新生代（Minor GC / Young GC）收集：只是新生代的垃圾收集 老年代（Major GC / Old GC）收集: 只是老年代的垃圾收集 目前，只有CMS GC 会有单独收集老年代的行为 注意：很多时候Major GC 和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆收集 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。 目前，只有G1 GC会有这种行为 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。 2.4.7、内存分配策略针对不同年龄段的对象分配原则： 优先分配到Eden 大对象直接分配老年代 尽量避免程序中出现大对象 长期存活的对象分配到老年代 动态对象年龄判断 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold 中要求的年龄。 空间分配担保 : -XX：HandlePromotionFailure 2.4.8、对象分配过程 TLAB 为什么有TLAB（Thread Local Allocation Buffer）？ 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 为可避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。 什么是TLAB？ 从内存模型的角度，对Eden区进行划分，JVM为每个线程分配一个私有缓存区域，它包含在Eden空间 多线程同时分配时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此可以将这种内存分配方式称之为快速分配策略 由OpenJDK衍生出来的JVM都提供TLAB。 详细说明TLAB 尽管不是所有的对象实力都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间，默认开启。 默认情况下，**TLAB空间内存非常小，仅占“Eden”区的1%**； 图解 2.4.9、堆空间常用参数 -Xms：用于表示堆区的起始内存，等价于-XX:InitialHeapSize -Xmx：用于表示堆区的最大内存，等价于-XX:MaxHeapSize -Xmn：设置新生代的空间大小，一般使用默认值 -XX:+PrintFlagsInitial:查看所有的参数的默认初始值 -XX:+PrintFlagsFinal:查看所有的参数的最终值（可能存在修改，不再是初始值） 具体查看某进程中某个参数的指令： 步骤1、jps:查看当前运行的java程序进程 步骤2、jinfo -flag 参数名称 进程id -XX:NewRatio=2：配置老年代新生代在堆结构的占比 （Old：Young = 2:1） -XX:SurvivorRatio=8：配置新生代中Eden区和s1 /s0区的比例 -XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄 -XX:+PrintGCDetails:输出详细的GC处理日志 -XX:+PrintGC或-verbose:gc:打印gc简要信息 -XX:HandlePromotionFailure是否设置空间分配担保 2.4.10、逃逸分析 1、堆是分配对象的唯一选择吗？ 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识，但是，有一种特殊情况，就是**经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，就有可能被优化成栈上分配**。这样就无需对上分配内存，也无需进行垃圾回收了。这是常见的**堆外存储技术**。 基于OpenJDK深度定制的TaobaoVM、其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GC内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 逃逸分析概述 逃逸分析：一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象动态作用域 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例：作为调用参数传递到其他地方 判断是否发生逃逸： 就看new的对象实体是否有可能在方法外被调用。 在JDK 6u23版本之后，Hotspot中默认就已经开启了逃逸分析。 显示开启逃逸分析： -XX:+DoEscapeAnalysis 查看逃逸分析的筛结果：-XX:+PrintEscapeAnalysis 逃逸分析：代码优化： 使用逃逸分析，编译器可以对代码进行优化 一、栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要是指向对象的指针永不逃逸，对象可能是栈分配的候选，而不是堆分配 二、同步省略：如果一个对象被发现只能在从一个线程被访问到，那么对于这个对象的操作可以不考虑同步（锁消除） 三、分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中 标量：指一个无法分解成更小的数据的数据。Java中的原始数据类型就是标量。 聚合量：还可以分解的数据 参数：-XX:+EliminateAllocations,Jdk7之后默认开启。 开启逃逸分析之后，使性能得到提升的主要还是标量替换，而不是栈上分配，其实Oracle的jdk并没有实现栈上分配，而是利用标量替换，存储在cpu寄存器中。 2.5、方法区从线程共享与否分析内存示意图 堆、栈、方法区的交互关系图解 2.5.1、理解方法区 Java虚拟机具有一个在所有Java虚拟机线程之间共享的方法区域。该方法区域类似于常规语言的编译代码的存储区域，或者类似于操作系统过程中的“文本”段。它存储每个类的结构，例如运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括用于类和实例初始化以及接口初始化的特殊方法。 方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但是简单的实现可以选择不进行垃圾回收或压缩。该规范没有规定方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，如果不需要更大的方法区域，则可以缩小。方法区域的内存不必是连续的。 Java虚拟机实现可以为程序员或用户提供对方法区域初始大小的控制，并且在方法区域大小可变的情况下，可以控制最大和最小方法区域大小。 以下异常条件与方法区域相关联： 如果无法提供方法区域中的内存来满足分配请求，则Java虚拟机将抛出一个OutOfMemoryError。 方法区在哪里？ 在《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区有一个别名叫做“Non-Heap”（非堆），目的就是要和堆分开。 所以，方法区是一块独立于Java堆的内存空间。 永久代和元空间 在JDK8之前方法区的实现是永久代，JDK8之后，完全废弃永久代的概念而用元空间对方法区的进行实现 元空间与永久代的本质区别：元空间不在虚拟机设置的内存中，而是使用本地内存。 2.5.2、设置方法区设置方法区的大小 在JDK7及以前： -XX:PermSize：来设置永久代初始分配空间，默认20.75M -XX:MaxPermSize: 来设定永久代最大可分配空间。32位默认是64M，63位默认是82M 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space. 在JDK8及以后： -XX:MetaspaceSize: 来设置元空间初始分配空间,64位默认是21M -XX:MaxMetaspaceSize : 的值是 -1, 即没有上限限制 如果元空间发生了溢出，也会报OutOfMemoryError：Metaspace 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC 多次调用。为了避免频繁地GC，建议将 -XX:MetaspaceSize设置为一个相对较高的值 2.5.3、内部结构 方法区存储什么？ 类型信息、常量、静态变量、即时编译器编译后的代码缓存，域信息，方法信息等。 类型信息 域（field）信息 方法（Method）信息 non-final的类变量 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分 类变量被类的所有实例共享 全局常量static final 被声明为final的类变量在编译的时候就会被分配 探究字节码层面类变量（static） 与 全局常量（static final）的区别： 12public static int count = 1; //类变量public static final int number = 2; //全局常量 下图是，编译为字节码文件之后： 明显可以发现 类变量在编译期没有赋值，全局常量在编译期已被赋值 class文件中常量池 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域、和方法的符号引用。 为什么需要常量池？ 常量池，可以看做是一张表，虚拟机指令根据这种常量表找到要执行的类名、方法名、参数类型、字面量等类型。 运行时常量池 从字节码文件理解方法区123456789public class MethodAreaDemo &#123; public static void main(String[] args) &#123; int x = 500; int y = 100; int a = x / y; int b = 50; System.out.println( a + b); &#125;&#125; 编译之后的字节码文件 main方法的执行过程 方法区的演变 永久代为什么要被元空间替换？ 方法区的垃圾回收 Stirng Table为什么要调整？ 2.6、总结 2.7、常见面试题 3、对象的实例化、内存布局与访问定位3.1、对象的实例化 创建对象的方式 创建对象的步骤 详细步骤 1、判断对象对应的类是否加载、链接、初始化 2、为对象分配内存 如果内存规整 指针碰撞 如果内存不规整 虚拟机需要维护一个列表 空闲列表分配 说明 3、处理并发安全问题 采用CAS失败重试、区域加锁保证更新的原子性 每个线程预先分配一块TLAB - 通过 -XX:+/-UseTLAB参数来设定 4、初始化分配到的空间 所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用 5、设置对象的对象头 6、执行init方法进行初始化 3.2、对象的内存布局 小结：图示所示 12345public class CustomerTest&#123; public static void main(String[] args)&#123; Customer cust = new Customer(); &#125;&#125; 3.3、对象的访问定位 对象访问方式（两种）： 1、句柄访问 好处： 坏处：需要在对空间额外申请内存，速度慢 2、直接指针（hotspot采用） 好处：不用再额外申请内存，速度快 坏处：不稳定，对象移动时，需要改变reference类型的值 3.4、直接内存 直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。 直接内存是在Java堆外的、直接向系统申请的内存空间 来源于NIO，通过存在堆中的DirectByteBuffer操作native内存 通常，访问直接内存的速度会优于Java堆。即读写性能高 因此出于性能考虑，读写频率频繁的场合可能会考虑使用直接内存 Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。 也可能导致OutOfMemoryError异常 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点： 分配回收成本较高 不受JVM内存回收管理 直接内存大小可通过MaxDirectMemorySize设置 如果不指定，默认与堆的最大值-Xmx参数值一致。 简单理解： Java process memory = java heap + native memory 直接缓冲区与非直接缓冲区的区别： （即io/nio的区别） 图解 io nio 通过案例 测试程序使用本地直接内存 123456789101112131415161718192021/** * 查看直接内存的占用与释放 */public class BufferTest &#123; private static final int BUFFER = 1024*1024*1024; public static void main(String[] args) &#123; // 直接分配本地内存 ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER); System.out.println(&quot;直接内存分配完毕,请指示&quot;); Scanner scanner = new Scanner(System.in); scanner.next(); System.out.println(&quot;直接内存开始释放！&quot;); byteBuffer = null; System.gc(); scanner.next(); &#125;&#125; 运行结果： 运行之前本地内存使用情况： 分配直接内存之后本地内存使用情况： 内存释放之后，本地内存使用情况： 4、执行引擎4.1、概述执行引擎是Java虚拟机核心的组成部分之一 JVM的主要任务是负责装载字节码到其内部。 字节码并不能直接运行在操作系统之上，因为字节码指令并不是等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他的辅助信息。 一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令。 4.2、工作过程 Java代码编译/执行过程 大部分程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都要 经过上图中的各个步骤。 java代码编译流程图 Java字节码执行流程图 4.3、机器码、指令、汇编、高级语言理解机器码 指令 汇编语言 高级语言 对应关系 字节码 4.4、解释器什么是解释器？什么是JIT编译器？ 为什么Java是半编译半解释型语言？ 图解解释器和JIT编译器 解释器工作机制 将字节码文件中内容“翻译”为对应平台的本地机器指令执行 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作 。 解释器分类 字节码解释器，模板解释器 基于解释器执行已经沦落为低效的代名词 4.5、JIT编译器概述 虚拟机将源代码直接编译为和本地机器相关的机器语言。 为了解决 解释器执行低效的问题，JVM平台支持一种即时编译的技术。 ==目的==是为了避免函数被解释执行，而是将整个函数体编译成为机器码，。每次函数执行时，只执行编译后的机器码即可。 概念解释 编译器： HotSpot JVM的执行方式 热点代码一个被多次调用的方法，或者是一个方法内部循环次数较多循环体都可称为“热点代码”。都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也称为栈上替换。简称OSR（On Stack Replacement ）编译。 热点探测功能 用来探测那些代码为热点代码。 HotSpot VM采用 热点探测方式是 基于计数器的热点探测。 方法调用计数器用于统计方法被调用的次数，它的默认阈值在Client模式下是1500下，在Server模式下是10000次，超过这个阈值，就会出发JIT编译。 这个阈值可以通过虚拟机参数“-XX:CompileThreshold”来设定。 具体描述 当一个方法被调用时，会先检查方法是否存在JIT编译版本，优先执行编译后的代码。如果不存在被JIT编译过的版本，则此方法的调用计数器+1.然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值，如果超过将向即时编译器提交一个该方法的代码编译请求。 图解 热度衰减 回边计数器 5、StringTable5.1、String的基本特性 String ：字符串，使用“”引起来表示。 String声明为final的，不可被继承。 String 实现了Serializable接口：表示字符串是支持序列化的。 实现了Comparable接口：表示string可以比较大小。 String在Jdk8以前内部定义了final char[] value 用于存储字符串数据。jdk9时改为了byte[] value . 5.2、String的内存分配 5.3、String的拼接操作1、常量与常量的拼接结果在常量池，原理：编译期优化 2、常量池不会存在相同内存的常量 3、只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder 4、如果拼接的结果调用intern( )方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。 案例1、 常量与常量拼接 案例2、 只要其中有一个为变量，结果就在堆中 案例3、 变量与变量相加，底层原理 案例4、 当两个被标记final关键字的字符串相加时 String 拼接 + 和 append方法效率对比 ==结论：==通过StringBuilder的append（）方式添加字符串的效率要远高于使用String的+拼接方式。 ==详情== 1、StringBuilder的append（）方式：自始至终只创建一个StringBuilder对象 String的+字符串拼接方式：每次相加都会创建新的StringBuilder对象 2、String的+字符串拼接方式：内存中由于创建了较多的StringBuilder对象和String对象，内存占用更大；如果进行GC，需要花费更多的额外时间。 ==改进优化== 在实际开发中，如果基本确定需要添加的字符串长度不高于某个限定值的情况下，建议使用StringBuilder s= new StringBuilder(hightLevel) ; 创建指定大小的StringBuilder，相当于创建一个 new char[hightLevel] 5.4、intern( ) 方法 关于intern（）的面试题 面试题一： 123String ab = new String(&quot;ab&quot;); //会创建几个对象？看字节码，就知道是两个。String ab = new String(&quot;a&quot;)+new String(&quot;b&quot;); //思考：会创建几个？ 答案 ： 2 、6 （JDK 8） 解析： 1234567891011121314/** * 题目： * String ab = new String(&quot;ab&quot;); 会创建几个对象？看字节码，就知道是两个。 * 0 new #2 &lt;java/lang/String&gt; * 3 dup * 4 ldc #3 &lt;ab&gt; * 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt; * 9 astore_1 * 10 return * * 对象一：new 关键字在堆空间创建的String类型的变量 * 对象二：字符串常量池中的对象&quot;ab&quot;. 字节码指令：ldc */ 1234567891011121314151617181920212223242526272829/** *思考：String ab = new String(&quot;a&quot;)+new String(&quot;b&quot;); 会创建几个？ * 0 new #2 &lt;java/lang/StringBuilder&gt; * 3 dup * 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt; * 7 new #4 &lt;java/lang/String&gt; * 10 dup * 11 ldc #5 &lt;a&gt; * 13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt; * 16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt; * 19 new #4 &lt;java/lang/String&gt; * 22 dup * 23 ldc #8 &lt;b&gt; * 25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt; * 28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt; * 31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt; * 34 astore_1 * 35 return * 对象一：new StringBuilder() * 对象二：new String(&quot;a&quot;) * 对象三：常量池中的 &quot;a&quot; * 对象四：new String(&quot;b&quot;) * 对象五：常量池中的 &quot;b&quot; * * 深入剖析： StringBuilder的toString()方法： * 对象六： new String(&quot;ab&quot;) * 强调一下：toString()的调用，在字符串常量池中，没有生成 “ab” * @param args */ 面试题二： intern() 1234567891011public static void main(String[] args) &#123; String s1 = new String(&quot;1&quot;); s1.intern(); String s2 = &quot;1&quot;; System.out.println(s1==s2); String s3 = new String(&quot;1&quot;)+new String(&quot;1&quot;); s3.intern(); String s4 = &quot;11&quot;; System.out.println(s3==s4); &#125; 答案： JDK6：fasle fasle JDK7：fasle true JDK8：fasle true 题解： 字节码指令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546470 new #2 &lt;java/lang/String&gt; 3 dup 4 ldc #3 &lt;1&gt; 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt; 9 astore_110 aload_111 invokevirtual #5 &lt;java/lang/String.intern&gt;14 pop15 ldc #3 &lt;1&gt;17 astore_218 getstatic #6 &lt;java/lang/System.out&gt;21 aload_122 aload_223 if_acmpne 30 (+7)26 iconst_127 goto 31 (+4)30 iconst_031 invokevirtual #7 &lt;java/io/PrintStream.println&gt;34 new #8 &lt;java/lang/StringBuilder&gt;37 dup38 invokespecial #9 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;41 new #2 &lt;java/lang/String&gt;44 dup45 ldc #3 &lt;1&gt;47 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;50 invokevirtual #10 &lt;java/lang/StringBuilder.append&gt;53 new #2 &lt;java/lang/String&gt;56 dup57 ldc #3 &lt;1&gt;59 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;62 invokevirtual #10 &lt;java/lang/StringBuilder.append&gt;65 invokevirtual #11 &lt;java/lang/StringBuilder.toString&gt;68 astore_369 aload_370 invokevirtual #5 &lt;java/lang/String.intern&gt;73 pop74 ldc #12 &lt;11&gt;76 astore 478 getstatic #6 &lt;java/lang/System.out&gt;81 aload_382 aload 484 if_acmpne 91 (+7)87 iconst_188 goto 92 (+4)91 iconst_092 invokevirtual #7 &lt;java/io/PrintStream.println&gt;95 return 1234567891011121314151617181920212223public static void main(String[] args) &#123; String s1 = new String(&quot;1&quot;); //调用此方法之前，字符串常量池中已经存在了 “1” 原因可看String的构造器，和字节码 s1.intern(); String s2 = &quot;1&quot;; System.out.println(s1==s2); //jdk6:false jdk7/8:false // s3变量记录地址为：new String(value, 0, count); // 此时并不会在字符串常量池中创建 &quot;11&quot; // 原因： // new String(&quot;11&quot;);会创建两个对象，其中一个是在常量池中创建一个“11”， // 是因为String的构造方法的参数是一个字符串（“11”）; // new String(value, 0, count) 中的value是一个 char[] ,并不会在 // 字符串常量池中创建一个“11”， String s3 = new String(&quot;1&quot;)+new String(&quot;1&quot;); s3.intern(); // 在字符串常量池中生成“11”。 // 如何理解： // JDK6：创建一个新的对象“11”，在字符串常量池中也创建一个 “11” // JDK7: 此时常量池中并没有创建常量“11”，而是创建一个指向堆空间中new String对象时创建的“11”的地址 // JDK8: 同JDK7 String s4 = &quot;11&quot;; //s4变量记录的地址：使用的是上一行代码执行时，在常量池中生成的“11”的地址 System.out.println(s3==s4); //jdk6 false jdk7/8 true &#125; intern（）方法（红色部分可以解释 JDK8 在常量池中创建指向new String（“11”）对象的引用） 题解总结： 5.5、G1的String去重操作 实现 命令行选项 6、垃圾收集6.1、什么是垃圾？垃圾收集：并不是Java语言的伴生产物， 1960年，第一门使用内存动态分配和垃圾收集技术的语言Lisp诞生 垃圾收集的三个问题： 那些内存需要回收？ 什么时候回收？ 如何回收？ 什么是垃圾？ 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是被回收的垃圾 如果不能对内存中的垃圾进行及时清理，这些垃圾对象就会一直存在至应用程序结束，被保留的空间无法被其他对象使用，就可能导致内存溢出。 6.2、大厂面试题 6.3、垃圾回收机制 自动内存管理 ，降低内存泄露和内存溢出的危险 自动内存管理，可以让程序员不用专注于内存的申请与释放，更专注于业务开发 垃圾回收器可以针对年轻代回收，也可以针对老年代回收，甚至是全堆或方法区的回收。（Java堆是垃圾收集器的工作重点） 收集次数 频繁收集Young区 较少收集old区 基本不动Perm区（元空间） 6.4、垃圾回收算法垃圾标记阶段：对象存活判断 在GC执行垃圾回收之前，需要先区分内存中哪些是存活对象，哪些是已经死亡的对象。只有标记已经死亡的对象，GC才会在执行垃圾回收时，释放掉其占用的内存。因此该阶段称为垃圾标记阶段 在JVM中，当一个对象不再被任何存活对象继续引用时，就是代表已经死亡。 判断对象存活的两种方式：引用计数算法、可达性分析算法 垃圾清除阶段：清除死亡对象 当成功区分出内存中存活和死亡对象后，GC接下来的任务就是垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存为新对象分配内存。 常用的三种垃圾收集算法 标记-清除算法（Mark-Sweep） 复制算法（Copying） 标记-压缩（整理）算法（Mark-Compact） 引用计数算法垃圾标记阶段的算法，对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。 解释： 有一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0，即表示对象A不可能被再使用，可进行回收 优点 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。 缺点 需要单独的字段存储计数器，增加了存储空间的开销 每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销 无法处理循环引用。 循环引用 Java没有使用引用计数，正是因为引用计数算法无法处理循环引用 Python用了引用计数算法 可达性分析算法 根搜索算法、追踪性垃圾收集 相对于引用计数算法，可达性分析算法不仅同样具备实现简单和执行高效等特点，还解决了引用计数算法中循环引用的问题，防止内存泄漏的发生 java 和 c# 使用 可达性分析算法 “GC Roots”根集合就是一组必须活跃的引用 理解： 图解： Java语言中，GC Roots 包括以下几类元素（重点） 技巧：由于Root 采用栈方式存放变量和指针，所以如果一个指针，他保存了堆内存里面的对象，但自己又不存放在堆内存中，那它就是一个Root 注意： finalization机制 对象终止（finalization）机制 允许开发人员提供对象被销毁之前的自定义处理逻辑 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，先调用这个对象的finalize()方法。 finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接 工作过程 判断对象是否可以回收，至少经历两次标记过程 标记清除算法背景 标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。 执行过程 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为Stop The World），然后进行两项工作，第一项是标记，第二项则是清除。 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 清除：Collector对堆内内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。 图解 缺点 效率不算高 在进行GC的时候，需要停止整个应用程序，导致用户体验差 这种方式清理出来的内存是不连续的，产生内存碎片，需要维护一个空闲列表； ==注意：==什么是清除？ 这里的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。下次用的时候直接覆盖 复制算法背景 为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA Lisp Garbage Collector Algorithm Using Serial Secondary Storage”。M.L.Minsky在论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功的引入到了Lisp语言的一个实现版本中。 核心思想 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。 图解 优点 没有标记，清除过程，实现简单，运行高效 复制过去以后保证空间的连续性，不会出现“碎片”空间 缺点 需要两倍的内存空间 对于G1这种分拆成大量region的GC，复制而不是移动，意味着维护region之间对象引用关系，不管是内存占用或者时间开销都不会少 如果系统中垃圾对象比较多，复制算法需要复制的存活对象数量并不会太大或者非常低，但是如果来及对象比较少，那复制存活对象代价就太大了 应用场景 标记整理\\压缩算法背景 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象多，复制成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其它的算法。 标记-清除算法确实可以应用在老年代中，但是，该算法不仅执行效率低下，而且在执行完内存收集后，还会产生内存碎片，所以JVM的设计者需要在此基础上进行改进。标记-压缩（Mark Compact）算法由此诞生。 1970年前后，G.L.Steel、C.J.Chene和D.S.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。 执行过程 第一阶段和标记-清除算法一样，从根节点开始标记所有被引用的对象 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放 然后，清理边界外所有的空间 图解 标记-压缩算法 与标记-清除算法 差异 标记-压缩算法 最终效果 相当于标记-清除算法执行之后再进行一次内存碎片整理，因此可以成为 标记-清除-压缩算法 本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的，是否移动回收后的存活对象是优缺点并存的风险决策 标记整理算法：标记存活的对象将被整理，按照内存地址依次排列，未被标记的内存会被清理。 所以，当我们需要给新对象分配内存时，JVM只需要持有一个内存起始地址即可，这比维护空闲列表少很多开销 优点 清除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。 消除了复制算法当中，内存减半的高额代价。 缺点 从效率上来说，标记-整理算法要低于复制算法。 移动对象的同时，如果对象被其它对象引用，则还需要调整引用 的地址。 移动过程中，需要全程暂停用户应用程序，即：STW。 对比三种算法 清除算法和压缩算法完整的过程是：识别-&gt;标记-&gt;遍历清除未标记对象；而复制算法是：识别-&gt;复制被GCroot引用的对象-&gt;直接置空原区域 分代收集算法 没有一种算法可以代替其它算法，他们都有自己独特的优势和特点。分代收集算法应运而生。 分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采用不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务有关，比如：http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是，还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变的特性，系统会产生大量的这些对象，有些对象甚至只用一次就可回收。 ==注意：==目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的。 在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代的特点。 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低、回收频繁；这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到解决。 老年代特点：区域较大，生命周期长，存活率高，回收频率不及年轻代。这种情况存在大量存活率高的对象，复制算法明显不合适，一般用标记-清除算法或者标记-清除和标记-压缩算法的混合实现。 mark阶段的开销与存活对象数量成正比； Sweep阶段的开销与管理区域大小成正比； Compact阶段的开销与存活对象成正比。 以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old 执行Full GC以达到对老年代整理的目的。 增量收集算法现有算法，在垃圾回收过程中，应用软件将处于一种Stop the World 的状态。在Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。 基本思想 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。 缺点 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 分区算法一般来说，在相同条件下，堆空间越大，一次GC所需要的时间越长，有关GC产生的停顿越长。为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC停顿的时间。 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。 图解 ==注意：== 目前发展中的前沿GC都是复合算法，且并行与并发兼备 6.5、垃圾回收相关概念6.5.1、System.gc( )的理解 默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显示的出发Full GC，同时对老年代与新生代进行回收，尝试释放被丢弃对象占用的内存 System.gc( ) 的底层就是Runtime.getRuntime().gc() System.gc( ) 调用附带一个免责声明，无法保证对垃圾收集器的调用。即仅仅是提醒，不能保证垃圾收集的具体执行时间 一般垃圾回收都是自动进行的，在一些特殊情况下才会手动通过System.gc() 调用垃圾回收。如 正在编写一个性能基准时 6.5.2、内存溢出和内存泄漏内存溢出（OOM）概述 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。 由于GC一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况； 大多数情况下，GC会进行各年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。 javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。 没有内存原因？ 首先说没有空闲内存的情况，Java虚拟机堆内存不够，原因有二： Java虚拟机的堆内存设置不够 比如：可能存在内存泄漏问题，也很有可能就是堆的大小不合理，比如我们要处理可观的数据量，但是，没有显示指定JVM堆大小或者指定数值偏小，我们可以通过-Xms、-Xmx来调整。 代码中创建了大量对象，并且长时间不能被垃圾收集器收集（存在引用）； 对于老版本的Oracle JDK,因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如：常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息会标记出来和永久代有关：“java.lang.OutOfMemeoryError:PermGen space” 随着元数据区的引入，方法区内存不再那么窘迫，所以相应的OOM有所改观，出现的异常信息变成了：“java.lang.OutOfMemoryError:Metaspace”。直接内存不足也会导致OOM。 这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理空间。 例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。 在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。 当然，也不是在任何情况下垃圾收集器都会被触发。 比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError. 内存泄漏概述 也称作“存储泄漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收它们的情况，才叫内存泄漏。 实际情况，很多时候一些不太友好的实践（或疏忽）会导致对象的生命周期变得很长，甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。 尽管内存泄漏并不会立刻引起程序崩溃，但是，一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。 注意：这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘区交换设定的大小。 图解 例 例一：单例模式 单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。 例二：一些提供close的资源未关闭导致内存泄漏 数据库连接（dataSource.getConnection()）,网络连接（socket）和IO连接必须手动Close（），否则是不能被回收的。 6.5.3、Stop The World Stop-The-World ，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何相应，有点像卡死的感觉，这个停顿称为STW。 可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。 分析工作必须在一个能确保一致性的快照中进行。 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上。 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成卡带一样，所以我们需要减少STW的发生。 ==注意：== STW和采用哪款GC无关，所有的GC都有这个事件。 哪怕是G1也不能完全避免Stop-The-World情况的发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。 STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常工作的线程全部停掉。 开发中不要用System.gc(),会导致Stop-The-World的发生。 6.5.4、垃圾回收的并行与并发并发 图解 并行 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行 ==注意：== 其实决定并行的因素并不是CPU的数量，而是CPU的核心数量，比如一个CPU多核也可以并行 适合科学计算，后台处理等弱交互场景 图解 并发/并行区别 垃圾回收的并发与并行并发与并行，在谈论垃圾收集器的上下文语境中，可以解释如下： 并行（Parallel）：指多条垃圾收集线程并行工作，但此用户线程仍处于等待状态。 如 ParNew、Parallel Scavenge、Parallel Old 串行（Serial） 相较于并行的概念，单线程执行 如果内存不足，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能是交替进行），垃圾回收线程在执行时不会停顿用户程序的运行 用户程序再继续运行，而垃圾收集程序线程 运行在另一个CPU上 如：CMS 、 G1 6.5.5、安全点与安全区域安全点 程序只能在特定的位置停顿下来开始GC，这些位置称为“安全点” Safe Point 选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂、通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。 安全区域SafePoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？如线程处于Sleep状态或Blocked状态，这时 候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。这种情况，就需要安全区域（Safe Region）来解决。 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。 实际执行时： 6.5.6、引用在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。 除强引用外，其他三种引用均可在java.lang.ref包中找到他们的身影。如图 强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Objectd）”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。 （内存不足，才回收） 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。（发现即回收） 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 强引用 （StrongReference）不死不回收 最常见的引用方式，（普通系统99%都是强引用），默认的引用类型。 当Java语言中使用new操作符创建一个对象，并将其赋值给一个变量时，这个变量就成为指向该对象的一个强引用。 强引用的对象时可触及的，垃圾收集器就永远不会回收掉被引用的对象。 对于一个普通的对象，如果没有其他的引用关系，只要超过引用的作用域或者显示地将相应（强）引用赋值为null，就可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。 软引用 （SoftReference）内存不足即回收 用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果此次回收仍然内存不足，才会抛出内存溢出异常 软引用通常用来实现内存敏感的缓存。比如：高速缓存，如果还用空闲内存，就可以暂时保留缓存，但内存不足时清理掉，保证了使用缓存的同时又不会耗尽内存 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列。 弱引用 （Weak Reference ）发现即回收 用来描述那些非必须对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象 但是，由于垃圾回收线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象，在这种情况下，弱引用对象可能存在较长的时间。 弱引用和软引用一样，在构造弱引用是，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通常这个队列可以跟踪对象的回收情况。 软引用、弱引用都非常适合来保存哪些可有可无的缓存数据。 虚引用 （Phantom Reference）对象回收跟踪 也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。 不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是nul1。 终接器引用它用以实现对象的finalize（）方法，也可以称为终结器引用。 无需手动编码，其内部配合引用队列使用。 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize（）方法，第二次Gc时才能回收被引用对象。 6.6、垃圾回收器概述 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。 由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。 从不同角度分析垃圾收集器，可以将GC分为不同的类型。 分类1、按线程数分：串行垃圾回收器和并行垃圾回收器 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。 2、按工作模式分：并发式垃圾回收器和独占式垃圾回收器 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。 独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。 3、按碎片处理方式分：压缩式垃圾回收器和非压缩式垃圾回收器 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。 再分配对象空间使用：指针碰撞 非压缩式的垃圾回收器不进行这步操作。 再分配对象空间使用：空闲列表 4、按工作内存区间分：年轻代垃圾回收器和老年代垃圾回收器 评估GC的性能指标 吞吐量：运行用户代码的时间占总运行时间的比例 总运行时间：用户代码运行时间 + 内存回收时间 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行的比例 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间 收集频率：相对于应用程序的执行，手机操作发生的频率 内存占用：Java堆区所占的内存大小 快速：一个对象从诞生到被回收所经历的时间 吞吐量(throu)指的是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 1吞吐量 &#x3D; 运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间） 比如：虚拟机总共运行了180分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4 暂停时间(pause time)指一个时间段内应用程序线程暂停，让Gc线程执行的状态 比如，GC期间100毫秒的暂停时间意味着在这1ee毫秒期间内没有应用程序线程是活动的。 暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1+0.1+0.1+0.1=0.5 吞吐量VS暂停时间 在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。 现在标准：在最大吞吐量优先的情况下，降低停顿时间。 7款经典的垃圾收集器 7款经典垃圾收集器与垃圾分代之间的关系 垃圾收集器的组合关系 如何查看默认的垃圾收集器?1、-XX:+PrintCommandLineFlags: 查看命令行参数（包含使用的垃圾收集器） 2、使用命令行指令: jinfo -flag 相关垃圾收集器参数 进程ID Serial和Serial Old回收器 Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。 Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。 Serial o1d是运行在client模式下默认的老年代的垃圾回收器 ==机制：== Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。 Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。 Serial old在Server模式下主要有两个用途： ①与新生代的Parallel Scavenge配合使用 ②作为老年代CMS收集器的后备垃圾收集方案 图示 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World） 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 运行在client模式下的虚拟机是个不错的选择。 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。 设置 在Hotspot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。 等价于新生代用SerialGC，且老年代用Serial old GC 总结 这种垃圾收集器大家了解就行，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。 对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。 ParNew回收器 并行回收 ParNew收集器相当于Serial收集器的多线程版本 Par 是 Parallel 的缩写，New：只能处理的是新生代 ParNew收集器除了采用并行回收的方式执行内存回收外，其他方面和Serial收集器几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、“Stop-the-World”机制。 ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。 对于新生代，回收次数频繁，使用并行方式高效 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换是线程，串行可以省去切换线程的资源） 面试题 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？ ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。 但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。 因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作 设置 -XX:+UseParNewGC指定使用ParNew收集器执行内存回收任务。表示年轻代使用ParNew并行收集器，不影响老年代 -XX:ParallelGCThreads限制线程数量，默认开启和CPU相同的线程数 Parallel Scavenge和Parallel Old回收器 Java 8中，默认的垃圾收集器 Parallel Scavenge回收器 吞吐量优先 Parallel Scavenge收集器和ParNew收集器一样是采用了复制算法、并行回收和“Stop the World”机制。 Parallel Old回收器 Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器，采用了标记-压缩算法，基于并行回收和”stop-the-World”机制。 既然有了ParNew，那么Parallel收集器的出现是否是多此一举？ 和ParNew收集器不同， parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），他也被称为吞吐量优先的垃圾收集器。 自适应调节策略也是Parrallel Scavenge与ParNew的一个重要区别 使用场景 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。 设置 -XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务 -XX:+UseParallelOldGC手动指定老年代使用并行回收收集器。 上面两个参数，默认开启一个，另一个也会被开启。（相互激活）。默认JDK8是开启的 -XX:+ParallelGCThreads设置年轻代并行收集器的线程数。一般的最好和CPU数相等，以避免过多的线程数影响垃圾收集的性能 默认情况下，当CPU数量小于8个，parallelGCThreads的值等于CPU数量 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8 -XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。 为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Paralle1，进行控制。 该参数使用需谨慎。 -XX:GCTimeRatio 垃圾收集时间占总时间的比例 1/(N+1)。 用于衡量吞吐量的大小。 取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1s。 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。 -XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMi11s），让虚拟机自己完成调优工作。","categories":[{"name":"jvm","slug":"jvm","permalink":"http://javacoderx.github.io/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://javacoderx.github.io/tags/jvm/"}]},{"title":"springboot零基础入门篇","slug":"springboot","date":"2021-04-23T16:53:11.000Z","updated":"2021-04-23T09:13:12.484Z","comments":true,"path":"2021/04/24/springboot/","link":"","permalink":"http://javacoderx.github.io/2021/04/24/springboot/","excerpt":"","text":"一、SpringBoot入门1.1、springboot 简介 springboot是什么？ 简化Spring应用开发的框架，spring技术栈的整合，J2EE开发的一站式解决方案 优点： 为所有spring开发者快速入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 1.2、微服务 是一种架构风格（服务微化） 要求在开发一个应用的时候，这个应用必须构建成一系列小服务的组合； 可以通过http的方式进行互通 单体应用 每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 1.3、快速开始 使用Spring Initializr创建一个springboot应用 创建一个主程序类，启动SpringBoot应用 编写Helloworld的Controller （在主程序类的同级目录下创建一个controller包，在其中写Controller类） 运行主程序 简化部署 123456789&lt;!‐‐ 这个插件，可以将应用打包成一个可执行的jar包；‐‐&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐maven‐plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 彩蛋 到项目下的 resources 目录下新建一个banner.txt文件就可以，将启动时显示的字符更改为自己想要的 12345678910111213141516171819202122 /\\/\\/\\ / \\ | \\ / | / \\ | \\/ | / \\ | /\\ |----------------------| /\\ | | / \\ | | / \\ | |/ \\| | / \\ | |\\ /| | | ( ) | | | \\ / | | | ( ) | | | \\/ | /\\ | | | | /\\ | /\\ | / \\ | | | | / \\ | / \\ | |----| | | | | |----| |/ \\|---------------| | | /| . |\\ | | | |\\ /| | | / | . | \\ | | | \\ / | | / | . | \\ | | \\/ | | / | . | \\ | | /\\ |---------------|/ | . | \\| | / \\ | / NASA | . | NASA \\ |/ \\| ( | | ) |/\\/\\/\\| | | |--| |--| | | ------------------------/ \\-----/ \\/ \\-----/ \\-------- \\\\// \\\\//\\\\// \\\\// \\/ \\/ \\/ \\/ 12345678910111213141516171819202122&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; _ooOoo_ &#x2F;&#x2F;&#x2F;&#x2F; o8888888o &#x2F;&#x2F;&#x2F;&#x2F; 88&quot; . &quot;88 &#x2F;&#x2F;&#x2F;&#x2F; (| ^_^ |) &#x2F;&#x2F;&#x2F;&#x2F; O\\ &#x3D; &#x2F;O &#x2F;&#x2F;&#x2F;&#x2F; ____&#x2F;&#96;---&#39;\\____ &#x2F;&#x2F;&#x2F;&#x2F; .&#39; \\\\| |&#x2F;&#x2F; &#96;. &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; \\\\||| : |||&#x2F;&#x2F; \\ &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; _||||| -:- |||||- \\ &#x2F;&#x2F;&#x2F;&#x2F; | | \\\\\\ - &#x2F;&#x2F;&#x2F; | | &#x2F;&#x2F;&#x2F;&#x2F; | \\_| &#39;&#39;\\---&#x2F;&#39;&#39; | | &#x2F;&#x2F;&#x2F;&#x2F; \\ .-\\__ &#96;-&#96; ___&#x2F;-. &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; ___&#96;. .&#39; &#x2F;--.--\\ &#96;. . ___ &#x2F;&#x2F;&#x2F;&#x2F; .&quot;&quot; &#39;&lt; &#96;.___\\_&lt;|&gt;_&#x2F;___.&#39; &gt;&#39;&quot;&quot;. &#x2F;&#x2F;&#x2F;&#x2F; | | : &#96;- \\&#96;.;&#96;\\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | | &#x2F;&#x2F;&#x2F;&#x2F; \\ \\ &#96;-. \\_ __\\ &#x2F;__ _&#x2F; .-&#96; &#x2F; &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;&#x2F;&#x2F; &#96;&#x3D;---&#x3D;&#39; &#x2F;&#x2F;&#x2F;&#x2F; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &#x2F;&#x2F;&#x2F;&#x2F; 佛祖保佑 永不宕机 永无BUG &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 二、自动装配原理2.1、POM文件分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--parent部分 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!--项目元数据信息部分--&gt; &lt;groupId&gt;com.xyc&lt;/groupId&gt; &lt;artifactId&gt;springboot-web&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-web&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!--dependencies部分 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--build部分 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 如上所示：POM文件分为四部分 项目元数据信息 ：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括：groupId、artifactId、version、name、description等 parent：继承spring-boot-starter-parent的依赖管理，控制版本与打包等内容 dependencies：项目具体依赖，这里包含了spring-boot-starter-web用于实现HTTP接口（该依赖中包含了Spring MVC），官网对它的描述是：使用Spring MVC构建Web（包括RESTful）应用程序的入门者，使用Tomcat作为默认嵌入式容器。；spring-boot-starter-test用于编写单元测试的依赖包。更多功能模块的使用我们将在后面逐步展开。 build：构建配置部分。默认使用了spring-boot-maven-plugin，配合spring-boot-starter-parent就可以把Spring Boot应用打包成JAR来直接运行。 我们的程序要想运行主要依赖一个父项目 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; Ctrl+鼠标左键 进入父项目 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt; 在这里定义着Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2.2、启动器12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;&lt;/dependency&gt; springboot-boot-starter：就是spring-boot的场景启动器 **spring-boot-starter-web **帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2.3、主程序类12345678910//@SpringBootApplication 来标注一个主程序类 ， 说明这是一个Spring Boot应用@SpringBootApplicationpublic class Springboot01HelloworldApplication &#123; public static void main(String[] args) &#123; //将SpringBoot应用启动起来 SpringApplication.run(Springboot01HelloworldApplication.class, args); &#125;&#125; 1. @SpringBootApplication 注解：来标注一个主程序类 ， 说明这是一个Spring Boot应用,在该类的main方法启动springboot应用 进入这个注解 ： 1234567891011121314151617@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; 2. @ComponentScan 注解 这个注解在Spring中很重要 ， 它对应XML配置中的元素。 @ComponentScan的功能就是自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 ； 3. @SpringBootConfiguration 注解: Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类； 进入这个注解 ： 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123; @Configuration:配置类上来标注这个注解，说明这是一个配置类。 配置类 &lt;--&gt; 配置文件； 进入这个注解： 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @Component :配置类也是容器中的一个组件；说明启动类也是容器的一个组件 4. @EnableAutoConfiguration： 开启自动配置功能； 以前我们需要配置的东西，Spring Boot帮我们自动配置； 进入这个注解： 12345678@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @import ：Spring底层注解 ， 给容器中导入一个组件 AutoConfigurationImportSelector.class： 自动配置导入选择器， 那么它会导入哪些组件的选择器呢？ 点击进入该类查看源码即可。 @AutoConfigurationPackage ： 自动配置包 进入这个注解： 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123; @import ：Spring底层注解 ， 给容器中导入一个组件 Registrar.class 将主配置类 【即@SpringBootApplication标注的类】的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； 自动配置真正实现是从classpath中搜寻所有的METINF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 结论： SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作； 以前我们需要自己配置的东西 ， 自动配置类都帮我们解决了 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中； 它将所有需要导入的组件以全类名的方式返回 ， 这些组件就会被添加到容器中 ； 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ； 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； 2.4、Run开启一个服务 1234567891011@SpringBootApplicationpublic class SpringbootDemo02Application &#123; public static void main(String[] args) &#123; //该方法返回一个ConfigurableApplicationContext对象 //参数一：应用入口的类 参数类：命令行参数 SpringApplication.run(SpringbootDemo02Application.class, args); &#125;&#125; SpringApplication.run分析 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； 2.5、SpringApplication这个类主要做了以下四件事情 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 三、配置文件3.1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； application.properties application.yml 作用：修改SpringBoot自动配置的默认值； （我们在配置文件中做的修改，SpringBoot在底层都给我们自动配置好） 3.2、yaml 是一种标记语言，不是一种标记语言。 语法：key:(空格)value 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级 12server: port: 8081 对象： 123456friends: lastName: zhangsan age: 20 行内写法： friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）： 1234567animals: - dog - cat - pid行内写法：animals: [cat,dog,pid] 3.3、配置文件占位符1、随机数 123$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值 123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 3.4、配置文件值的注入@Value和@ConfigurationProperties yaml： 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: ‐ lisi ‐ zhaoliu dog: name: 小狗 age: 12 javaBean: 12345678910111213141516171819/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供 * @ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 配置文件处理器 123456&lt;!‐‐导入配置文件处理器，配置文件进行绑定就会有提示‐‐&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐configuration‐ processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; @Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 Profile 多Profile文件 我们在主配置文件编写的时候，文件名可以是 application-&#123;profile&#125;.properties/yml 默认使用application.properties的配置； yml支持多文档块方式 123456789101112131415 server: port: 8081spring: profiles: active: prod‐‐‐server: port: 8083spring: profiles: dev‐‐‐server: port: 8084spring: profiles: prod #指定属于哪个环境 激活指定profile 1、在配置文件中指定 spring.profiles.active=dev 2、命令行： java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev； 可以直接在测试的时候，配置传入命令行参数 3、虚拟机参数； -Dspring.profiles.active=dev 3.5、配置文件的加载位置 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置 3.6、加载指定配置文件@PropertySource： 加载指定的配置文件 1@PropertySource(value &#x3D; &#123;&quot;classpath:person.properties&quot;&#125;) @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； 标注在一个配置类上 1@ImportResource(locations &#x3D; &#123;&quot;classpath:beans.xml&quot;&#125;) SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式1、配置类@Configuration——&gt;Spring配置文件2、使用@Bean给容器中添加组件 123456789101112131415 /** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;); return new HelloService(); &#125;&#125; 四、日志4.1、日志框架市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ==SpringBoot选用 SLF4j和logback；== 4.2、SLF4j使用如何在系统中使用SLF4j https://www.slf4j.org 日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); &#125;&#125; 图示： 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 遗留问题 a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 4.3、日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 2）、SpringBoot也把其他的日志都替换成了slf4j； 3）、中间替换包？ 123456@SuppressWarnings(&quot;rawtypes&quot;)public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = &quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;; static LogFactory logFactory = new SLF4JLogFactory(); 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4.4、日志使用默认设置 可直接使用 123456789101112131415161718//记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(&quot;这是trace日志...&quot;); logger.debug(&quot;这是debug日志...&quot;); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(&quot;这是info日志...&quot;); logger.warn(&quot;这是warn日志...&quot;); logger.error(&quot;这是error日志...&quot;); &#125; springboot修改日志的默认设置 1234567891011121314logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console =%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file =%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n 123456789日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 指定配置 给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 12345&lt;springProfile name=&quot;staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 4.5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 五、Web开发5.1、静态资源映射 所有**/webjars/**** ，都去classpath:/META-INF/resources/webjars/找资源； webjars：以jar包的方式引入静态资源； “/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射 12345&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;resources&#x2F;&quot;,&quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &quot;&#x2F;&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc 欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射； localhost:8080/ 找index页面 所有的 /favicon.ico 都是在静态资源文件下找； 5.2、模板引擎JSP、Velocity、Freemarker、Thymeleaf Springboot推荐Thymelea 引入thymeleaf1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!‐‐切换thymeleaf版本‐‐&gt; &lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!‐‐ 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 ‐‐&gt; &lt;!‐‐ thymeleaf2 layout1‐‐&gt; &lt;thymeleaf‐layout‐dialect.version&gt;2.2.2&lt;/thymeleaf‐layout‐dialect.version&gt; &lt;/properties&gt; thymeleaf使用只要我们把HTML页面放在classpath:/templates/下，thymeleaf就能自动渲染 1.导入thymeleaf的命名空间 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 2.使用语法 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF‐8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!‐‐th:text 将div里面的文本内容设置为 ‐‐&gt; &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache&#x3D;false 语法规则th:text；改变当前元素里面的文本内容； th：任意html属性；来替换原生属性的值 表达式: ${…}：获取变量值 #{…}：获取国际化内容 *{…}：选择表达式 和${}在功能上是一样 @{…}：定义URL ~{…}：片段引用表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象： #execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in thesame way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as aresult of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , ‐ , * , / , % Minus sign (unary operator): ‐Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If‐then: (if) ? (then) If‐then‐else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No‐Operation: _ 5.3、SpringMVC 自动配置auto-configurationSpring Boot 自动配置好了SpringMVC以下是SpringBoot对SpringMVC的默认配置:（WebMvcAutoConfiguration） Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？） ContentNegotiatingViewResolver：组合所有的视图解析器的； 如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来； Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter , GenericConverter , Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 123456789@Bean @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date‐format&quot;)//在文件中配置日期格式化的规则 public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat()); //日期格式化组件 &#125; 自己添加的格式化器转换器，我们只需要放在容器中即可 Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component） Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below).我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器） 12初始化WebDataBinder；请求数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； 扩展SpringMVC在config包下 编写一个配置类（@Configuration），实现WebMvcConfigurer接口 注意 ：不能标注@EnableWebMvc;标注后springmvc的自动配置就会失效，我们全面接管springmvc 1234567891011121314151617181920212223242526272829303132/** * 2020/2/13 14:32 * 文件说明：Mvc的自定义配置类 * * @author 薛云冲 * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123;// 视图解析器 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;main.html&quot;).setViewName(&quot;dashboard&quot;); &#125; //自定义的国际化组件 @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(&quot;/**&quot;）.excludePathPatterns (&quot;/index.html&quot;,&quot;/&quot;,&quot;/index&quot;,&quot;/user/login&quot;,&quot;/asserts/**&quot;); &#125;&#125; 5.4、修改springboot默认配置1） SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；2） 在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置3） 在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 5.5、CRUD操作后台Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.xyc.springbootweb.Controller;/** * 2020/2/14 21:37 * 文件说明： * * @author 薛云冲 * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Controller@RequestMapping(&quot;EMP&quot;)public class EmployeeController &#123; @Autowired private EmployeeService employeeService; @Autowired private DepartmentDao departmentDao; @RequestMapping(&quot;/findAll&quot;) public String findAll(Model model)&#123; Collection&lt;Employee&gt; employees = employeeService.findAll(); model.addAttribute(&quot;emps&quot;,employees); return &quot;list&quot;; &#125;// 跳转到添加员工的页面 @GetMapping(&quot;/add&quot;) public String toAddEmployee( Model model)&#123; model.addAttribute(&quot;depts&quot;,departmentDao.getDepartments()); return &quot;addEmp&quot;; &#125; @PostMapping(&quot;/add&quot;) public String addEmployee(Employee employee)&#123; if (employee!=null)&#123; employeeService.addEmp(employee); &#125; return &quot;redirect:findAll&quot;; &#125; @GetMapping(&quot;/toUpdate&quot;)// 跳转到修改员工信息的页面 public String toUpdateEmployee(String id,Model model)&#123; Employee employee = employeeService.findById(id); model.addAttribute(&quot;depts&quot;,departmentDao.getDepartments()); model.addAttribute(&quot;emp&quot;,employee); return &quot;updateEmp&quot;; &#125; @PostMapping(&quot;/update&quot;) public String updateEmployee(Employee employee)&#123; employeeService.updateEmployee(employee); return &quot;redirect:findAll&quot;; &#125; @RequestMapping(&quot;/delete&quot;) public String deleteEmployee(String id)&#123; employeeService.deleteEmployee(id); return &quot;redirect:findAll&quot;; &#125;&#125; 前端利用thymeleaf模板引擎进行数据回显，等等 5.6、国际化1.在resources文件夹下创建包 i18n，在i18n下编写国际化消息 2.在配置文件中添加消息文件的真实位置 123# 我们自定义的消息的配置文件的真实位置 messages: basename: i18n.login 3.根据请求切换国际化语言（只需在相关请求中加入相关参数） 12&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt; 4.创建国际化配置类放入容器（一定要放入容器） 1234567891011121314151617181920212223242526272829303132333435363738package com.xyc.springbootweb.config;/** * 2020/2/14 1:52 * 文件说明： * * @author 薛云冲 * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Componentpublic class MyLocaleResolver implements LocaleResolver &#123; //解析请求 @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; //获取请求中的语言参数 String language = httpServletRequest.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); // 如果没有就是用默认值 //如果请求中的链接携带了国际化参数 if (!StringUtils.isEmpty(language))&#123; //zh_CN String[] split = language.split(&quot;_&quot;); //国家地区 locale = new Locale(split[0], split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 4.去页面获取国际化的值； 12#&#123;login.tip&#125;#&#123;login.username&#125; 5.7、拦截器自定义拦截器 1234567891011121314151617181920212223242526/** * 2020/2/14 18:43 * 文件说明： * * @author 薛云冲 * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 登录成功之后，应该有用户的session Object username = request.getSession().getAttribute(&quot;username&quot;); if(username==null)&#123; request.setAttribute(&quot;msg&quot;,&quot;未登录，请先登录!&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; &#125;else&#123; return true; &#125; &#125;&#125; 在自定义MvcConfig类中的注册拦截器（必须） 123456@Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(&quot;/**&quot;).excludePathPatterns (&quot;/index.html&quot;,&quot;/&quot;,&quot;/index&quot;,&quot;/user/login&quot;,&quot;/asserts/**&quot;); &#125; 5.8、错误处理机制5.8.1、默认的错误处理机制默认效果： 1）、浏览器，返回一个默认的错误页面 原理 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(&quot;timestamp&quot;, new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = &quot;text/html&quot;)//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; 3、ErrorPageCustomizer： 12@Value(&quot;$&#123;error.path:/error&#125;&quot;)private String path = &quot;/error&quot;; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = &quot;error/&quot; + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; 步骤 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被**BasicErrorController**处理； 1）响应页面；去哪个页面是由**DefaultErrorViewResolver**解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 5.8.2、定制错误响应：定制错误的页面；1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； 页面能获取的信息； timestamp：时间戳 status：状态码 error：错误提示 exception：异常对象 message：异常消息 errors：JSR303数据校验的错误都在这里 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 定制错误的json数据；1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); return map; &#125;&#125;//没有自适应效果... 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(&quot;javax.servlet.error.status_code&quot;); */ request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); //转发到/error return &quot;forward:/error&quot;; &#125; 3）、将我们的定制数据携带出去； 出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(&quot;company&quot;,&quot;atguigu&quot;); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 六、整合JDBC配置 导入JDBC的启动器，以及mysql的相关依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 在springboot的配置中对数据源datasource进行配置 1234567891011spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/ems?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver #type 指定自定义数据源类型，以下是阿里的druid数据源 type: com.alibaba.druid.pool.DruidDataSource 配置好，就可以直接使用了，其余的springboot自动配置 com.zaxxer.hikari.HikariDataSource （Spring Boot 2.0 以上，默认使用此数据源） 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。默认情况下，它是从类路径自动检测的。 可以测试一下是否配置完成 在测试类中 123456789101112131415161718192021@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootDemoDataApplicationTests &#123; //DI注入数据源 @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException &#123; //看一下默认数据源 dataSource.getClass() System.out.println(dataSource.getClass()); //输出默认数据源：com.zaxxer.hikari.HikariDataSource //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); //关闭连接 connection.close(); &#125;&#125; 使用CRUD操作 方法： 配置好数据源（dataSource）后，就可以拿到数据库连接（Connection），使用连接和原生的JDBC就可以进行操作数据库 使用第三方框架，mybatis，hibernate等 使用Spring对原生JDBC的轻量级封装 ，即org.springframework.jdbc.core.JdbcTemplate。 在jdbcTemplate中，封装有数据库操作的所有CRUD方法 在springboot中已默认配置了jdbcTemplate，并放入容器中，直接自行注入即可使用。 jdbcTempalte提供的几类方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句； update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句； query方法及queryForXXX方法：用于执行查询相关语句； call方法：用于执行存储过程、函数相关语句。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@RestControllerpublic class JdbcController &#123; //JdbcTemplate 是 core 包的核心类，用于简化 JDBC操作，还能避免一些常见的错误，如忘记关闭数据库连接 //Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate //JdbcTemplate 中会自己注入数据源，使用起来也不用再自己来关闭数据库连接 @Autowired JdbcTemplate jdbcTemplate; //查询数据库的所有连接 //没有实体类，怎么取数据库的数据？用Map&lt;String,Object&gt; //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值 @GetMapping(&quot;findAll&quot;) //查询所有 public List&lt;Map&lt;String,Object&gt;&gt; findAll()&#123; String sql=&quot;select * from admin&quot;; //List 中的1个 Map 对应数据库的 1行数据 //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值 List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql); return maps; &#125; //增加信息 @GetMapping(&quot;add&quot;) public String add()&#123; String sql=&quot;insert into ems.admin values(&#x27;123142&#x27;,&#x27;root&#x27;,&#x27;991016&#x27;,&#x27;测试3&#x27;)&quot;; jdbcTemplate.update(sql); return &quot;update-ok&quot;; &#125; //删除数据 @GetMapping(&quot;delete&quot;) public String delete()&#123; String sql=&quot;delete from ems.admin where id=&#x27;123142&#x27;&quot;; jdbcTemplate.update(sql); return &quot;delete-ok&quot;; &#125; //修改数据 @GetMapping(&quot;update&quot;) public String update()&#123; String sql=&quot;update ems.admin set name=&#x27;测试&#x27; where id=&#x27;123142&#x27;&quot;; jdbcTemplate.update(sql); return &quot;update-ok&quot;; &#125;&#125; 七、整合Druid数据源简介： Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP、PROXOOL 等 DB 池的优点，同时加入了日志监控。 Druid 基本配置参数： 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 详情-点此处。 url 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 validationQueryTimeout 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 1分钟（1.0.14） 有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis 30分钟（1.0.14） 连接保持空闲而不被驱逐的最长时间 connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 导入依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--log4j--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 配置数据源12345678910111213141516171819202122232425262728293031323334spring: datasource: username: root password: 991016# 如果mysql关于时区报错，就在url中加一个参数 ：serverTimezeno=UTC url: JDBC:mysql://localhost:3306/ems?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver# 切换数据源 默认的数据源：com.zaxxer.hikari.HikariDataSource type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 druid: initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址： https://mvnrepository.com/artifact/log4j/log4j filters: stat,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 配置完成后可在测试类中，检测数据源是否配置完成 配置Druid数据监控Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。 所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; //后台监控 web.xml ServletRegistrationBean //因为springboot 内置了servlet容器，所以没有web.xml ，替代方法：servletRegistrationBean @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(),&quot;/druid/*&quot;); //后台需要有人登录，账号密码配置 HashMap&lt;String,String&gt; initParameters = new HashMap&lt;&gt;(); //增加配置 initParameters.put(&quot;loginUsername&quot;,&quot;admin&quot;);//登录key，是固定的 LoginUsername、LoginPassword initParameters.put(&quot;loginPassword&quot;,&quot;991016&quot;); //允许谁可以访问 initParameters.put(&quot;allow&quot;,&quot;&quot;); //禁止谁可以访问 initParameters.put(&quot;kuangsheng&quot;,&quot;192.168&quot;); bean.setInitParameters(initParameters); return bean; &#125; // filter public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); //可以过滤哪些请求？ HashMap&lt;String,String&gt; initParameters = new HashMap&lt;&gt;(); //这些东西不进行统计 initParameters.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParameters); return bean; &#125;&#125; 八、整合Mybatis1.导入整合mybatis所需依赖123456&lt;!-- 引入 myBatis，这是 MyBatis官方提供的适配 Spring Boot 的，而不是Spring Boot自己的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 2.配置数据源12345678spring: datasource: username: root password: 991016 url: jdbc:mysql://localhost:3306/ems?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver 测试类测试一下是否可以连接成功。。。 3.整合Mybatis在配置文件中加入 123456 #整合mybatismybatis: #对应实体类的路径 type-aliases-package: com.xyc.pojo #指定mybatis的核心配置文件与Mapper映射文件 mapper-locations: classpath:mybatis/mapper/*.xml 4.创建实体类：12345678910111213//lombok的注解标注这是一个实体类@Data//标注自动创建无参构造@NoArgsConstructor//标注自动创建有参构造@AllArgsConstructorpublic class Admin &#123;private String id;private String username;private String password;private String name;&#125; 5.配置Mapper接口类123456789101112131415161718//@Mapper : 表示本类是一个 MyBatis 的 Mapper，（dao层）// 等价于以前 Spring 整合 MyBatis 时的 Mapper 接口@Mapper//@Repository:将此类放入spring容器中@Repositorypublic interface AdminMapper &#123; //查询所有 public List&lt;Admin&gt; findAll(); //通过id查询 public Admin findById(String id); // 增加 public int add(Admin admin); // 修改 public int update(Admin admin); // 删除 public int delete(String id);&#125; 6.Mapper映射文件1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.xyc.mapper.AdminMapper&quot; &gt; &lt;select id=&quot;findAll&quot; resultType=&quot;Admin&quot; &gt; select * from admin; &lt;/select&gt; &lt;select id=&quot;findById&quot; resultType=&quot;Admin&quot;&gt; select * from admin where id = #&#123;id&#125;; &lt;/select&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;Admin&quot;&gt; insert into admin(id, username, password, name) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;name&#125;) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Admin&quot;&gt; update admin set id= #&#123;id&#125;, username= #&#123;username&#125;, password= #&#123;password&#125;, name =#&#123;name&#125; where id = #&#123;id&#125;; &lt;/update&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;String&quot;&gt; delete from admin where id = #&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 九、springSecurity1、SpringSecurity简介1.1、安全框架概述什么是安全框架 ? 解决系统安全问题的框架。如果没有安全框架,我们需要手动处理每个资源的访问控制,非常麻烦。使用安全框架,我们可以通过配置的方式实现对资源的访问限制。 1.2、常用安全框架Spring Security: Spring全家桶的一员。是一个能够为基于 Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean,充分利用了 Spring IoC、DI (控制反转 Inversion of Control；DI: Dependency Injection 依赖注入)和**AoP(面问切面编程)**功能,为应用系统提供声明式的安全访问控制功能,减少了为企业系统安全控制编写大量重复代码的工作。 Apache Shiro: 一个功能强大且易于使用的Java安全框架提供了认证、授权、加密和会话管理 1.3、简介Spring Security是一个高度自定义的安全框架。利用 Spring loC/D和AOP功能,为系统提供了声明式安全访问控制功能,减少了为系统安全而编写大量重复代码的工作。使用 Spring Secruity的原因有很多,但大部分都是发现了javaEE的 Servlet规范或EJB规范中的安全功能缺乏典型企业应用场景。同时认识到他们在WAR或EAR级别无法移植。因此如果你更换服务器环境,还有大量工作去重新配置你的应用程序。使用 Spring Security解决了这些问题也为你提供许多其他有用的、可定制的安全功能。正如你可能知道的两个应用程序的两个主要区域是“认证和授权”(或者访问控制)。这两点也是 Spring Security重要核心功能。 “认证“,是建立一个他声明的主体的过程(一个“主体”一般是指用户,设备或一些可以在你的应用程序中执行动作的其他系统),通俗点说就是系统认为用户是否能登录。 “授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情。 2、简单使用导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 前端页面 login.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 导入spring-boot-starter-security 启动器后，Spring Security 已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。 默认的 username 为 user，password 打印在控制台中。 3、UserDetailsService当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。 3.1、返回值返回值为 UserDetails 接口 的实例 UserDetails接口 123456789101112131415public interface UserDetails extends Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); // 获取密码 String getPassword(); // 获取用户名 String getUsername(); // 是否账号过期 boolean isAccountNonExpired(); // 是否账号被锁定 boolean isAccountNonLocked(); // 凭证（密码）是否过期 boolean isCredentialsNonExpired(); // 是否可用 boolean isEnabled();&#125; 想返回 UserDetails 的实例,只能返回接口的实现类。SpringSecurity 中提供了如下的实例。 我们只需要使用里面的 User 类即可。注意 User 的全限定路径是：org.springframework.security.core.userdetails.User 此处经常和系统中自己开发的 User 类弄混。 User 类的方法和属性 构造方法 1234567891011121314151617181920/** * username : 用户名 ，password : 密码，authorities ： 用户所具有的权限 （not null） */public User(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this(username, password, true, true, true, true, authorities); &#125; public User(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; if (username != null &amp;&amp; !&quot;&quot;.equals(username) &amp;&amp; password != null) &#123; this.username = username; this.password = password; this.enabled = enabled; this.accountNonExpired = accountNonExpired; this.credentialsNonExpired = credentialsNonExpired; this.accountNonLocked = accountNonLocked; this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities)); &#125; else &#123; throw new IllegalArgumentException(&quot;Cannot pass null or empty values to constructor&quot;); &#125; &#125; 此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。SpringSecurity 会根据 User 中的 password 和客户端传递过来的 password 进行比较。如果相同则表示认证通过，如果不相同表示认证失败。 authorities 里面包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现 403。通常都是通过AuthorityUtils.commaSeparatedStringToAuthorityList(“”) 来创建authorities 集合对象的。参数是一个字符串，多个权限使用逗号分隔。 3.2、方法参数方法参数为登录时传入的用户名 3.3、异常UsernameNotFoundException 用户名没有发现异常。在 loadUserByUsername 中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出UsernameNotFoundException ，系统就知道用户名没有查询到。 3.4、实现案例UserDetailsService接口的实现类 ：UserDetailsServiceImpl 12345678910111213141516171819202122232425262728293031@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; private static final Logger log = LoggerFactory.getLogger(UserDetailsServiceImpl.class); @Autowired private ISysUserService userService; @Autowired private SysPermissionService permissionService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; SysUser user = userService.selectUserByUserName(username); if (StringUtils.isNull(user)) &#123; log.info(&quot;登录用户：&#123;&#125; 不存在.&quot;, username); throw new UsernameNotFoundException(&quot;登录用户：&quot; + username + &quot; 不存在&quot;); &#125; else if (UserStatus.DELETED.getCode().equals(user.getDelFlag())) &#123; log.info(&quot;登录用户：&#123;&#125; 已被删除.&quot;, username); throw new BaseException(&quot;对不起，您的账号：&quot; + username + &quot; 已被删除&quot;); &#125; else if (UserStatus.DISABLE.getCode().equals(user.getStatus())) &#123; log.info(&quot;登录用户：&#123;&#125; 已被停用.&quot;, username); throw new BaseException(&quot;对不起，您的账号：&quot; + username + &quot; 已停用&quot;); &#125; return createLoginUser(user); &#125; public UserDetails createLoginUser(SysUser user) &#123; return new LoginUser(user, permissionService.getMenuPermission(user)); &#125;&#125; UserDetails接口的实现类 LoginUser 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public class LoginUser implements UserDetails &#123; private static final long serialVersionUID = 1L; /** * 用户唯一标识 */ private String token; /** * 登录时间 */ private Long loginTime; /** * 过期时间 */ private Long expireTime; /** * 登录IP地址 */ private String ipaddr; /** * 登录地点 */ private String loginLocation; /** * 浏览器类型 */ private String browser; /** * 操作系统 */ private String os; /** * 权限列表 */ private Set&lt;String&gt; permissions; /** * 用户信息 */ private SysUser user; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public LoginUser() &#123; &#125; public LoginUser(SysUser user, Set&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; @JsonIgnore @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; /** * 账户是否未过期,过期无法验证 */ @JsonIgnore @Override public boolean isAccountNonExpired() &#123; return true; &#125; /** * 指定用户是否解锁,锁定的用户无法进行身份验证 * * @return */ @JsonIgnore @Override public boolean isAccountNonLocked() &#123; return true; &#125; /** * 指示是否已过期的用户的凭据(密码),过期的凭据防止认证 * * @return */ @JsonIgnore @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; /** * 是否可用 ,禁用的用户不能身份验证 * * @return */ @JsonIgnore @Override public boolean isEnabled() &#123; return true; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125;&#125; 4、PasswordEncoderSpring Security 要求容器中必须有 PasswordEncoder 实例。所以当自定义登录逻辑时要求必须给容器注入 PaswordEncoder 的bean对象。 123456789101112131415161718public interface PasswordEncoder &#123; /** * 把参数按照特定的解析规则进行解析 */ String encode(CharSequence var1); /* * 验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配， * 则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存 * 储的密码。 */ boolean matches(CharSequence var1, String var2); /** * 如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回 false。默认返回 false。 */ default boolean upgradeEncoding(String encodedPassword) &#123; return false; &#125;&#125; 内置解析器 内置解析器有很多 ，BCryptPasswordEncoder 是官方推荐的密码解析器。 BCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认 10. 5、自定义登录逻辑当 进 行 自 定 义 登 录 逻 辑 时 需 要 用 到 之 前 讲 解 的 UserDetailsService 和PasswordEncoder 。但是 Spring Security 要求：当进行自定义登录逻辑时容器内必须有PasswordEncoder 实例。 5.1、配置类将PasswordEncoder注入到容器中 1234567@Configurationpublic class SecurityConfig &#123;@Beanpublic PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder();&#125;&#125; 5.2、自定义逻辑在 Spring Security 中实现 UserDetailService 就表示为用户详情服务。在这个类中编写用户认证逻辑。 1234567891011121314151617@Servicepublic class UserServiceImpl implements UserDetailsService &#123;@Autowiredprivate PasswordEncoder pw;@Overridepublic UserDetails loadUserByUsername(String username) throwsUsernameNotFoundException &#123; //1.查询数据库判断用户名是否存在，如果不存在抛出UsernameNotFoundException异常 if (!&quot;admin&quot;.equals(username))&#123; throw new UsernameNotFoundException(&quot;用户名不存在&quot;); &#125; //2.把查询出来的密码（注册时已经加密过）进行解析，或直接把密码放入构造方法中 String password = pw.encode(&quot;123&quot;); return new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,normal&quot;)); &#125;&#125; 6、自定义登录界面6.1、修改配置类主要是设置哪个页面是登录页面。配置类需要继承WebSecurityConfigurerAdapte,并重写 configure 方法。 successForwardUrl() ：登录成功后跳转地址 loginPage() ：登录页面 loginProcessingUrl() ：登录页面表单提交地址，此地址可以不真实存在。 antMatchers() ：匹配内容 permitAll() ：允许 12345678910111213141516171819202122232425262728@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //表单提交 http.formLogin() //自定义登录页面 .loginPage(&quot;/login.html&quot;) //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl .loginProcessingUrl(&quot;/login&quot;) //登录成功后跳转页面，POST请求 .successForwardUrl(&quot;/toMain&quot;); http.authorizeRequests() //login.html不需要被认证 .antMatchers(&quot;/login.html&quot;).permitAll() //所有请求都必须被认证，必须登录后被访问 .anyRequest().authenticated(); //关闭csrf防护 http.csrf().disable();&#125;@Beanpublic PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder();&#125;&#125; 7、认证过程中其他常用配置7.1、失败跳转设置失败跳转页面 12345678910//表单提交http.formLogin() //自定义登录页面 .loginPage(&quot;/login.html&quot;) //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl .loginProcessingUrl(&quot;/login&quot;) //登录成功后跳转页面，POST请求 .successForwardUrl(&quot;/toMain&quot;) //登录失败后跳转页面，POST请求 .failureForwardUrl(&quot;/toError&quot;); 设置失败页面不拦截 1234567http.authorizeRequests()//login.html不需要被认证.antMatchers(&quot;/login.html&quot;).permitAll()//error.html不需要被认证.antMatchers(&quot;/error.html&quot;).permitAll()//所有请求都必须被认证，必须登录后被访问.anyRequest().authenticated(); 7.2、设置请求账户和密码的参数名当进行登录时会执行 UsernamePasswordAuthenticationFilter 过滤器。在该过滤器中定义请求的用户名密码默认为 username和password。 修改默认用户名和密码参数名 12345678910111213//表单提交http.formLogin() //自定义登录页面 .loginPage(&quot;/login.html&quot;) //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl .loginProcessingUrl(&quot;/login&quot;) //登录成功后跳转页面，POST请求 .successForwardUrl(&quot;/toMain&quot;) //登录失败后跳转页面，POST请求 .failureForwardUrl(&quot;/toError&quot;) //修改默认用户名和密码参数名 .usernameParameter(&quot;myusername&quot;) .passwordParameter(&quot;mypassword&quot;) 7.3、自定义登录成功处理器使用successForwardUrl()时表示成功后转发请求到地址。内部是通过 successHandler() 方法进行控制成功后交给哪个类进行处理 ForwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了, 当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。 自定义类 12345678910111213141516171819public class MyAuthenticationSuccessHandler implementsAuthenticationSuccessHandler &#123; private String url; public MyAuthenticationSuccessHandler(String url) &#123; this.url = url; &#125; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; //Principal 主体，存放了登录用户的信息 User user = (User) authentication.getPrincipal(); System.out.println(user.getUsername()); //输出null System.out.println(user.getPassword()); System.out.println(user.getAuthorities()); response.sendRedirect(url); &#125;&#125; 修改配置 123456789101112131415/表单提交http.formLogin()//自定义登录页面.loginPage(&quot;/login.html&quot;)//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl.loginProcessingUrl(&quot;/login&quot;)//登录成功后跳转页面，POST请求// .successForwardUrl(&quot;/toMain&quot;)//和successForwardUrl不能共存.successHandler(newMyAuthenticationSuccessHandler(&quot;/login&quot;))//登录失败后跳转页面，POST请求.failureForwardUrl(&quot;/toError&quot;).usernameParameter(&quot;myusername&quot;).passwordParameter(&quot;mypassword&quot;); 7.4、自定义登录失败处理器failureForwardUrl()内部调用的是 failureHandler() 方法 ForwardAuthenticationFailureHandler 中也是一个请求转发，并在request 作用域中设置SPRING_SECURITY_LAST_EXCEPTION 的 key，内容为异常对象。 123456789101112131415public class ForwardAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; private final String forwardUrl; public ForwardAuthenticationFailureHandler(String forwardUrl) &#123; Assert.isTrue(UrlUtils.isValidRedirectUrl(forwardUrl), () -&gt; &#123; return &quot;&#x27;&quot; + forwardUrl + &quot;&#x27; is not a valid forward URL&quot;; &#125;); this.forwardUrl = forwardUrl; &#125; public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; request.setAttribute(&quot;SPRING_SECURITY_LAST_EXCEPTION&quot;, exception); request.getRequestDispatcher(this.forwardUrl).forward(request, response); &#125;&#125; 实现 12345678910111213public class MyForwardAuthenticationFailureHandler implementsAuthenticationFailureHandler &#123; private String url; public MyForwardAuthenticationFailureHandler(String url) &#123; this.url = url; &#125; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; response.sendRedirect(url); &#125;&#125; 配置 12345678910111213141516//表单提交http.formLogin()//自定义登录页面.loginPage(&quot;/login.html&quot;)//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl.loginProcessingUrl(&quot;/login&quot;)//登录成功后跳转页面，POST请求// .successForwardUrl(&quot;/toMain&quot;)//和successForwardUrl不能共存.successHandler(newMyAuthenticationSuccessHandler(&quot;http://www.baidu.com&quot;))//登录失败后跳转页面，POST请求// .failureForwardUrl(&quot;/toError&quot;).failureHandler(new MyForwardAuthenticationFailureHandler(&quot;/error.html&quot;)).usernameParameter(&quot;myusername&quot;).passwordParameter(&quot;mypassword&quot;); 8、访问控制url匹配在前面认证中所有常用配置，主要是对 http.formLogin() 进行操作。而在配置类中http.authorizeRequests() 主要是对url进行控制，也就是我们所说的授权（访问控制）。http.authorizeRequests() 也支持链式编程 8.1、anyRequest()在之前认证过程中我们就已经使用过 anyRequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。 1.anyRequest().authenticated(); 8.2、antMatcher()1public C antMatchers(String... antPatterns) 参数是不定向参数，每个参数是一个 ant 表达式，用于匹配 URL规则。 ? ： 匹配一个字符 * ：匹配 0 个或多个字符 ** ：匹配 0 个或多个目录 在实际项目中经常需要放行所有静态资源 1.antMatchers(&quot;/js/**&quot;,&quot;/css/**&quot;).permitAll() 或 12.antMatchers(&quot;/**/*.js&quot;).permitAll().antMatchers(&quot;/**/*.css&quot;).permitAll() 8.3、regexMatchers()使用正则表达式进行匹配。和 antMatchers() 主要的区别就是参数， antMatchers() 参数是 ant表达式， regexMatchers() 参数是正则表达式。 1.regexMatchers( &quot;.+[.]js&quot;).permitAll() 无论是 antMatchers() 还是 regexMatchers() 都具有两个参数的方法，其中第一个参数都是HttpMethod ，表示请求方式，当设置了 HttpMethod 后表示只有设定的特定的请求方式才执行对应的权限设置。 1234567891011121314151617181920public enum HttpMethod &#123; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE; private static final Map&lt;String, HttpMethod&gt; mappings = new HashMap&lt;&gt;(16); static &#123; for (HttpMethod httpMethod : values()) &#123; mappings.put(httpMethod.name(), httpMethod); &#125; &#125; @Nullable public static HttpMethod resolve(@Nullable String method) &#123; return (method != null ? mappings.get(method) : null); &#125; public boolean matches(String method) &#123; return (this == resolve(method)); &#125;&#125; 8.4、mvcMatchers()mvcMatchers()适用于配置了 servletPath 的情况。 servletPath 就是所有的 URL 的统一前缀。在 SpringBoot 整合SpringMVC 的项目中可以在application.properties 中添加下面内容设置 ServletPath 1spring.mvc.servlet.path = /system 在 Spring Security 的配置类中配置 .servletPath() 是 mvcMatchers()返回值特有的方法，antMatchers()和 regexMatchers()没有这个方法。在 servletPath() 中配置了 servletPath 后，mvcMatchers()直接写 SpringMVC 中@RequestMapping()中设置的路径即可。 1.mvcMatchers(&quot;/demo&quot;).servletPath(&quot;/xxxx&quot;).permitAll() 等价于 1.antMatchers(&quot;/xxxx/demo&quot;).permitAll() 9、内置访问控制方法Spring Security 匹配了 URL 后调用了 permitAll() 表示不需要认证，随意访问。在 Spring Security中提供了多种内置控制。 9.1、permitAll()permitAll()表示所匹配的 URL 任何人都允许访问。 9.2、authenticated()authenticated()表示所匹配的 URL 都需要被认证才能访问。 9.3、anonymous()anonymous()表示可以匿名访问匹配的URL。和permitAll()效果类似，只是设置为 anonymous()的 url会执行 filter 链中 9.4、denyAll()denyAll()表示所匹配的 URL 都不允许被访问。 9.5、rememberMe()被“remember me”的用户允许访问 9.6、fullyAuthenticated()如果用户不是被 remember me 的，才可以访问。 10、角色权限判断Spring Security 中还支持很多其他权限控制。这些方法一般都用于用户已经被认证后，判断用户是否具有特定的要求。 10.1、hasAuthority(String)判断用户是否具有特定的权限，用户的权限是在自定义登录逻辑中创建 User 对象时指定的。下图中admin和normal 就是用户的权限。admin和normal 严格区分大小写。 1.antMatchers(&quot;/main1.html&quot;).hasAuthority(&quot;admin&quot;) 10.2、hasAnyAuthority(String …)如果用户具备给定权限中某一个，就允许访问。 1.antMatchers(&quot;/main1.html&quot;).hasAnyAuthority(&quot;adMin&quot;,&quot;admiN&quot;) 10.3、hasRole(String)如果用户具备给定角色就允许访问。否则出现 403。 在给用户赋予角色时角色需要以： ROLE_开头 ，后面添加角色名称。例如：ROLE_abc 其中 abc 是角色名，ROLE_是固定的字符开头。 使用 hasRole()时参数也只写 abc 即可。否则启动报错。 1.antMatchers(&quot;/main1.html&quot;).hasRole(&quot;abc&quot;) 10.4、hasAnyRole(String …)如果用户具备给定角色的任意一个，就允许被访问 10.5、hasIpAddress(String)如果请求是指定的 IP 就运行访问。 1.antMatchers(&quot;/main1.html&quot;).hasIpAddress(&quot;127.0.0.1&quot;) 而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security 支持自定义权限受限。 11、自定义403处理方案使用 Spring Security 时经常会看见 403（无权限），默认情况下显示的效果如下： 新建类 实现 AccessDeniedHandler接口 1234567891011121314@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123;@Overridepublic void handle(HttpServletRequest request, HttpServletResponse response,AccessDeniedException accessDeniedException) throws IOException,ServletException &#123; response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); out.write(&quot;&#123;\\&quot;status\\&quot;:\\&quot;error\\&quot;,\\&quot;msg\\&quot;:\\&quot;权限不足，请联系管理员！\\&quot;&#125;&quot;); out.flush(); out.close();&#125;&#125; 配置类中添加 123//异常处理http.exceptionHandling().accessDeniedHandler(myAccessDeniedHandler); 12、基于表达式的访问控制12.1、access() 可以通过 access() 实现和之前学习的权限控制完成相同的功能。 12.2、使用自定义方法新建接口和实现类 MyService.java 1234public interface MyService &#123;boolean hasPermission(HttpServletRequest request, Authenticationauthentication);&#125; 1234567891011121314@Componentpublic class MyServiceImpl implements MyService &#123;@Overridepublic boolean hasPermission(HttpServletRequest request, Authenticationauthentication) &#123; Object obj = authentication.getPrincipal(); if (obj instanceof UserDetails)&#123; UserDetails userDetails = (UserDetails) obj; Collection&lt;? extends GrantedAuthority&gt; authorities =userDetails.getAuthorities(); return authorities.contains(newSimpleGrantedAuthority(request.getRequestURI())); &#125; return false;&#125;&#125; 修改配置 12345678//url拦截http.authorizeRequests()//login.html不需要被认证// .antMatchers(&quot;/login.html&quot;).permitAll().antMatchers(&quot;/login.html&quot;).access(&quot;permitAll&quot;)// .antMatchers(&quot;/main.html&quot;).hasRole(&quot;abc&quot;).antMatchers(&quot;/main.html&quot;).access(&quot;hasRole(&#x27;abc&#x27;)&quot;).anyRequest().access(&quot;@myServiceImpl.hasPermission(request,authentication)&quot;) 13、基于注解的访问控制在 Spring Security 中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过@EnableGlobalMethodSecurity 进行开启后使用。如果设置的条件允许，程序正常执行。如果不允许会报 500 这些注解可以写到 Service 接口或方法上，也可以写到 Controller或 Controller 的方法上。通常情况下都是写在控制器方法上的，控制接口URL是否允许被访问。 13.1、@Secured@Secured 是专门用于判断是否具有角色的。能写在方法或类上。参数要以 ROLE_开头。 12345@Secured(&quot;ROLE_abc&quot;)@RequestMapping(&quot;/toMain&quot;)public String toMain()&#123;return &quot;redirect:/main.html&quot;;&#125; 13.2、@PreAuthorize/@PostAuthorize@PreAuthorize 和@PostAuthorize 都是方法或类级别注解。 @PreAuthorize 表示访问方法或类在执行之前先判断权限，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。 @PostAuthorize 表示方法或类执行结束后判断权限，此注解很少被使用到。 123456789/*** 成功后跳转页面* @return*/@PreAuthorize(&quot;hasRole(&#x27;ROLE_abc&#x27;)&quot;)@RequestMapping(&quot;/toMain&quot;)public String toMain()&#123;return &quot;redirect:/main.html&quot;;&#125; 14、RememberMe功能实现Spring Security 中 Remember Me 为“记住我”功能，用户只需要在登录时添加 remember-me复选框，取值为true。Spring Security 会自动把用户信息存储到数据源中，以后就可以不登录进行访问 Spring Security 实 现 Remember Me 功 能 时 底 层 实 现 依 赖Spring-JDBC，所以需要导入 Spring-JDBC。以后多使用 MyBatis 框架而很少直接导入 spring-jdbc，所以此处导入 mybatis 启动器同时还需要添加 MySQL 驱动 123456789101112&lt;!-- mybatis 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql 数据库依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt; 配置数据源 12345spring.datasource.driver-class-name= com.mysql.cj.jdbc.Driverspring.datasource.url= jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.username= rootspring.datasource.password= root 编写配置 1234567891011121314@Configurationpublic class RememberMeConfig &#123;@Autowiredprivate DataSource dataSource;@Beanpublic PersistentTokenRepository getPersistentTokenRepository()&#123;JdbcTokenRepositoryImpl jdbcTokenRepository = newJdbcTokenRepositoryImpl();jdbcTokenRepository.setDataSource(dataSource);//自动建表，第一次启动时需要，第二次启动时注释掉jdbcTokenRepository.setCreateTableOnStartup(true);return jdbcTokenRepository;&#125;&#125; ==注意== : jdbcTokenRepository.setCreateTableOnStartup(true); :自动建表，第一次启动时需要，第二次启动时注释掉 修改SecurityConfig.java 在 configure 中添加下面配置内容。 1234567http.rememberMe() //失效时间，单位秒 .tokenValiditySeconds(120) //登录逻辑交给哪个对象 .userDetailsService(userService) // 持久层对象 .tokenRepository(persistentTokenRepository); 15、Thymeleaf中SpringSecurity的使用Spring Security 可以在一些视图技术中进行控制显示效果。例如： JSP 或 Thymeleaf 。在非前后端分离且使用 Spring Boot 的项目中多使用 Thymeleaf 作为视图展示技术。 Thymeleaf 对 Spring Security 的 支 持 都 放 在 thymeleaf-extras-springsecurityX 中，目前最新版本为 5。所以需要在项目中添加此 jar 包的依赖和 thymeleaf 的依赖。。 12345678910&lt;!--thymeleaf springsecurity5 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--thymeleaf依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在 html 页面中引入 thymeleaf 命名空间和 security 命名空间 123&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;xmlns:th=&quot;http://www.thymeleaf.org&quot;xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt; 获取属性 可以在html页面中通过 sec:authentication=”” 获取UsernamePasswordAuthenticationToken 中所有 getXXX 的内容，包含父类中的 getXXX 的内容。 根据源码得出下面属性： name ：登录账号名称 principal ：登录主体，在自定义登录逻辑中是 UserDetails credentials ：凭证 authorities ：权限和角色 details ：实际上是 WebAuthenticationDetails 的实例。可以获取 remoteAddress (客户端ip)和 sessionId (当前 sessionId) 新建demo.html在项目 resources 中新建 templates 文件夹，在 templates 中新建demo.html 页面 123456789101112131415&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登录账号:&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;&lt;br/&gt; 登录账号:&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;&lt;br/&gt; 凭证：&lt;span sec:authentication=&quot;credentials&quot;&gt;&lt;/span&gt;&lt;br/&gt; 权限和角色：&lt;span sec:authentication=&quot;authorities&quot;&gt;&lt;/span&gt;&lt;br/&gt; 客户端地址：&lt;span sec:authentication=&quot;details.remoteAddress&quot;&gt;&lt;/span&gt;&lt;br/&gt; sessionId：&lt;span sec:authentication=&quot;details.sessionId&quot;&gt;&lt;/span&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 权限判断 设置用户角色和权限 123return new User(username,password,AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,ROLE_abc,/insert,/delete&quot;)); 控制页面显示效果 1234567891011通过权限判断：&lt;button sec:authorize=&quot;hasAuthority(&#x27;/insert&#x27;)&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/delete&#x27;)&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/update&#x27;)&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/select&#x27;)&quot;&gt;查看&lt;/button&gt;&lt;br/&gt;通过角色判断：&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;查看&lt;/button&gt; 16、退出登录用户只需要向 Spring Security 项目中发送 /logout 退出请求即可 进入我们自定义的界面 123http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/login.html&quot;); logout其他常用配置源码解读 addLogoutHandler(LogoutHandler) 默认是 contextLogoutHandler 默认实例内容 clearAuthentication(boolean) 是否清除认证状态，默认为 true 是否销毁 HttpSession 对象，默认为 true logoutSuccessHandler(LogoutSuccessHandler) 退出成功处理器 也可以自己进行定义退出成功处理器。只要实现了 LogoutSuccessHandler 接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。 17、SpringSecurity中的CSRF17.1、什么是CSRF？CSRF（Cross-site request forgery）跨站请求伪造，也被称为“OneClick Attack” 或者 SessionRiding。通过伪造用户请求访问受信任站点的非法请求访问。 跨域：只要网络协议，ip 地址，端口中任何一个不相同就是跨域请求。 客户端与服务进行交互时，由于 http 协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id 可能被第三方恶意劫持，通过这个 session id 向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。 17.2、Spring Security中的CSRF从 Spring Security4开始CSRF防护默认开启。默认会拦截请求。进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为 _csrf 值为token(token 在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot; name=&quot;_csrf&quot; th:if=&quot;$&#123;_csrf&#125;&quot;/&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 18、Oauth2认证OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说OAUTH标准逐渐成为开放资源授权的标准。 一个Oauth2认证的例子，网站使用微信认证的过程： 用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者 点击“微信”出现一个二维码，此时用户扫描二维码，开始给网站授权。 资源拥有者同意给客户端授权 资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。 客户端获取到授权码，请求认证服务器申请令牌此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。 认证服务器向客户端响应令牌认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。 客户端请求资源服务器的资源客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。 资源服务器返回受保护资源资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。 注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。 客户端本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。资源拥有者通常为用户，也可以是应用程序，即该资源的拥有者。授权服务器（也称认证服务器）用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。资源服务器存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。 术语 客户凭证(client Credentials) ：客户端的clientId和密码用于认证客户令牌(tokens) ：授权服务器在接收到客户请求后，颁发的访问令牌作用域(scopes) ：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission) 令牌类型授权码 ：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌访问令牌 ：用于代表一个用户或服务直接去访问受保护的资源刷新令牌 ：用于去授权服务器获取一个刷新访问令牌BearerToken ：不管谁拿到Token都可以访问资源，类似现金Proof of Possession(PoP) Token ：可以校验client是否对Token有明确的拥有权 19、Spring Security Oauth2 Authorize Endpoint ：授权端点，进行授权Token Endpoint ：令牌端点，经过授权拿到对应的TokenIntrospection Endpoint ：校验端点，校验Token的合法性Revocation Endpoint ：撤销端点，撤销授权 Spring Security Oauth2架构 用户访问,此时没有Token。Oauth2RestTemplate会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重定向到认证服务器 认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端 客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端 客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。 使用 授权模式导入依赖 (导入spring-cloud的依赖使用时比较简单一些) 1234567891011121314151617&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置类 SecurityConfig 需要继承 WebSecurityConfigurerAdapter 12345678910111213141516171819202122@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Override public void configure(HttpSecurity http) throws Exception &#123; http.csrf() .disable() .authorizeRequests() .antMatchers(&quot;/oauth/**&quot;, &quot;/login/**&quot;, &quot;/logout/**&quot;) .permitAll() .anyRequest() .authenticated() .and() .formLogin() .permitAll(); &#125; 编写UserDetailsService接口的实现类，通过loadUserByUsername方法处理登录逻辑 123456789101112@Servicepublic class UserService implements UserDetailsService &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; String password = passwordEncoder.encode(&quot;123456&quot;); return new User(&quot;admin&quot;,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 可以实现UserDetails接口定义我们自己的登录用户类 授权服务器配置 AuthorizationServerConfig.java 12345678910111213141516171819202122232425@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() //配置client_id .withClient(&quot;admin&quot;) //配置client-secret .secret(passwordEncoder.encode(&quot;112233&quot;)) //配置访问token的有效期 .accessTokenValiditySeconds(3600) //配置刷新token的有效期 .refreshTokenValiditySeconds(864000) //配置redirect_uri，用于授权成功后跳转 .redirectUris(&quot;http://www.baidu.com&quot;) //配置申请的权限范围 .scopes(&quot;all&quot;) //配置grant_type，表示授权类型 .authorizedGrantTypes(&quot;authorization_code&quot;); &#125;&#125; 资源服务器配置 ResourceServerConfig.java 12345678910111213@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest() .authenticated() .and() .requestMatchers() .antMatchers(&quot;/user/**&quot;);//配置需要保护的资源路径 &#125;&#125; 编写Controller 12345678@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @GetMapping(&quot;/getCurrentUser&quot;) public Object getCurrentUser(Authentication authentication) &#123; return authentication.getPrincipal(); &#125;&#125; 测试： 获取授权码 http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=client&amp;redirect_uri=http://www.baidu.com&amp;scope=all 输入账户密码 ：—》 进入授权页面 点击授权获取授权码 xNx1zB 根据授权码获取令牌（POST请求） grant_type ：授权类型，填写authorization_code，表示授权码模式code ：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。client_id :客户端标识redirect_uri ：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。scope :授权范围。 认证失败服务端返回 401 Unauthorized注意：此时无法请求到令牌，访问服务器会报错 根据token去资源服务器拿资源 Spring Security Oauth2 密码模式SecurityConfig中添加 AuthenticationManager 12345@Bean@Overridepublic AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean();&#125; AuthorizationServerConfig.java中重写该方法，并添加授权类型 12345678910111213141516171819202122232425262728/*** 使用密码模式需要配置*/@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; endpoints.authenticationManager(authenticationManager) .userDetailsService(userService);&#125;@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throwsException &#123; clients.inMemory() //配置client_id .withClient(&quot;admin&quot;) //配置client-secret .secret(passwordEncoder.encode(&quot;112233&quot;)) //配置访问token的有效期 .accessTokenValiditySeconds(3600) //配置刷新token的有效期 .refreshTokenValiditySeconds(864000) //配置redirect_uri，用于授权成功后跳转 .redirectUris(&quot;http://www.baidu.com&quot;) //配置申请的权限范围 .scopes(&quot;all&quot;) //配置grant_type，表示授权类型 .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;); &#125; redis中存储token导入依赖 12345678910&lt;!--redis 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- commons-pool2 对象池依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; redisConfig 123456789@Configurationpublic class RedisConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; @Bean public TokenStore redisTokenStore()&#123; return new RedisTokenStore(redisConnectionFactory); &#125;&#125; 在认证服务器配置中指定令牌的存储策略为Redis 123456789/*** 使用密码模式需要配置*/@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123;endpoints.authenticationManager(authenticationManager).userDetailsService(userService).tokenStore(tokenStore);&#125; 20、JWT常见的认证机制HTTP Basic Auth HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth。 Cookie Auth Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。 OAuth 基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。 Token Auth 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）： 支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可. 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多. 不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）. JWT简介JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。 官网： https://jwt.io/ JWT 优点： jwt基于json，非常方便解析。 可以在令牌中自定义丰富的内容，易扩展。 通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。 资源服务使用JWT可不依赖认证服务即可完成授权。 缺点： JWT令牌较长，占存储空间比较大。 组成由三部分组成头部、负载与签名 头部：用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMACSHA256或RSA）等。 使用Base64编码 负载：存放有效信息。 分为三个部分 标准中注册的声明（建议但不强制使用） 1234567iss: jwt签发者sub: jwt所面向的用户aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 公共的声明：可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 私有的声明 ：提供者和消费者所共同定义的声明，不建议存放敏感信息，Base64编码是对称解密的 签名：一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret（盐，一定要保密） 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分 使用导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; 测试使用 12345678910111213141516171819202122232425262728@Testpublic void testCreatToken() &#123; //创建一个JwtBuilder对象 JwtBuilder jwtBuilder = Jwts.builder() //声明的标识&#123;&quot;jti&quot;:&quot;8848&quot;&#125; .setId(&quot;8848&quot;) //主体，用户&#123;&quot;sub&quot;:&quot;gailun&quot;&#125; .setSubject(&quot;gailun&quot;) //创建日期&#123;&quot;ita&quot;:&quot;xxxxxx&quot;&#125; .setIssuedAt(new Date()) //签名手段，参数1：算法，参数2：盐 .signWith(SignatureAlgorithm.HS256,&quot;xxxx&quot;) //设置过期时间 .setExpiration(new Date(exp)); // 自定义claim .claim(&quot;roles&quot;,&quot;admin&quot;) .claim(&quot;logo&quot;,&quot;shsxt.jpg&quot;) //获取jwt的token String token = jwtBuilder.compact(); System.out.println(token); //三部分的base64解密 System.out.println(&quot;--------------------&quot;); String[] split = token.split(&quot;\\\\.&quot;); System.out.println(Base64Codec.BASE64.decodeToString(split[0])); System.out.println(Base64Codec.BASE64.decodeToString(split[1])); //无法解密 System.out.println(Base64Codec.BASE64.decodeToString(split[2]));&#125; 验证JWT 12345678910111213141516@Testpublic void testParseToken()&#123;//tokenString token =&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE0MjUyfQ&quot; +&quot;.-FYFMHyfTcGzq900f_Drfdsges0ge2UjaWvPW9gCDto&quot;;//解析token获取负载中的声明对象Claims claims = Jwts.parser() .setSigningKey(&quot;xxxx&quot;) //加密时的 盐 .parseClaimsJws(token) .getBody();//打印声明的属性System.out.println(&quot;id:&quot;+claims.getId());System.out.println(&quot;subject:&quot;+claims.getSubject());System.out.println(&quot;issuedAt:&quot;+claims.getIssuedAt());&#125; 21、Spring Security Oauth2 整合JWT在之前Spring Security Oauth2的基础上进行修改 添加配置类 1234567891011121314@Configurationpublic class JwtTokenStoreConfig &#123;@Beanpublic TokenStore jwtTokenStore()&#123; return new JwtTokenStore(jwtAccessTokenConverter());&#125;@Beanpublic JwtAccessTokenConverter jwtAccessTokenConverter()&#123; JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter(); //配置JWT使用的秘钥 accessTokenConverter.setSigningKey(&quot;test_key&quot;); return jwtAccessTokenConverter();&#125;&#125; 在认证服务器配置中指定令牌的存储策略为JWT 12345678@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; endpoints.authenticationManager(authenticationManager) .userDetailsService(userService) //配置存储令牌策略 .tokenStore(tokenStore) .accessTokenConverter(jwtAccessTokenConverter);&#125; 扩展JWT中存储的内容，这里我们在JWT中扩展一个 key为enhance，value为enhance info 的数据。实现接口TokenEnhancer实现一个JWT内容增强器 123456789public class JwtTokenEnhancer implements TokenEnhancer &#123;@Overridepublic OAuth2AccessToken enhance(OAuth2AccessToken accessToken,OAuth2Authentication authentication) &#123; Map&lt;String,Object&gt; info = new HashMap&lt;&gt;(); info.put(&quot;enhance&quot;,&quot;enhance info&quot;); ((DefaultOAuth2AccessToken)accessToken).setAdditionalInformation(info); return accessToken;&#125;&#125; 创建一个JwtTokenEnhancer实例 1234@Beanpublic JwtTokenEnhancer jwtTokenEnhancer() &#123;return new JwtTokenEnhancer();&#125; 在认证服务器配置中配置JWT的内容增强器 123456789101112131415@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123;TokenEnhancerChain enhancerChain = new TokenEnhancerChain();List&lt;TokenEnhancer&gt; delegates = new ArrayList&lt;&gt;(); //配置JWT的内容增强器 delegates.add(jwtTokenEnhancer); delegates.add(jwtAccessTokenConverter); enhancerChain.setTokenEnhancers(delegates); endpoints.authenticationManager(authenticationManager) .userDetailsService(userService) //配置存储令牌策略 .tokenStore(tokenStore) .accessTokenConverter(jwtAccessTokenConverter) .tokenEnhancer(enhancerChain);&#125; 解析token 12345678910@GetMapping(&quot;/getCurrentUser&quot;)public Object getCurrentUser(Authentication authentication,HttpServletRequest request) &#123; String header = request.getHeader(&quot;Authorization&quot;); String token = header.substring(header.indexOf(&quot;bearer&quot;) + 7); return Jwts.parser() .setSigningKey(&quot;test_key&quot;.getBytes(StandardCharsets.UTF_8)) .parseClaimsJws(token) .getBody();&#125; 刷新令牌 在Spring Cloud Security 中使用oauth2时，如果令牌失效了，可以使用刷新令牌通过refresh_token的授权模式再次获取access_token。只需修改认证服务器的配置，添加refresh_token的授权模式即可。 1234//配置访问token的有效期.accessTokenValiditySeconds(3600)//配置刷新token的有效期.refreshTokenValiditySeconds(864000) 22、Spring Security Oauth2 整合单点登录（SSO）添加依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; 修改配置文件 123456789101112server.port=8081#防止Cookie冲突，冲突会导致登录验证不通过server.servlet.session.cookie.name=OAUTH2-CLIENT-SESSIONID01#授权服务器地址oauth2-server-url: http://localhost:8080#与授权服务器对应的配置security.oauth2.client.client-id=adminsecurity.oauth2.client.client-secret=112233security.oauth2.client.user-authorization-uri=$&#123;oauth2-server-url&#125;/oauth/authorizesecurity.oauth2.client.access-token-uri=$&#123;oauth2-server-url&#125;/oauth/tokensecurity.oauth2.resource.jwt.key-uri=$&#123;oauth2-server-url&#125;/oauth/token_key 启动类添加@EnableOAuth2Sso注解 1234567@SpringBootApplication@EnableOAuth2Ssopublic class Oauth2client01demoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Oauth2client01demoApplication.class, args); &#125;&#125; 修改认证服务器配置 123456789101112131415161718192021222324252627@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;clients.inMemory() //配置client_id .withClient(&quot;admin&quot;) //配置client-secret .secret(passwordEncoder.encode(&quot;112233&quot;)) //配置访问token的有效期 .accessTokenValiditySeconds(3600) //配置刷新token的有效期 .refreshTokenValiditySeconds(864000) //配置redirect_uri，用于授权成功后跳转 // .redirectUris(&quot;http://www.baidu.com&quot;) //单点登录时配置 .redirectUris(&quot;http://localhost:8081/login&quot;) //配置申请的权限范围 .scopes(&quot;all&quot;) //自动授权配置 .autoApprove(true) //配置grant_type，表示授权类型 .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;,&quot;refresh_token&quot;);&#125;@Overridepublic void configure(AuthorizationServerSecurityConfigurer security) &#123; // 获取密钥需要身份认证，使用单点登录时必须配置 security.tokenKeyAccess(&quot;isAuthenticated()&quot;);&#125; 十、整合Shiro安全框架整合 Shiro 环境搭建Shiro 三大对象Subject 当前用户SecurityManager 管理所有用户Realm 连接数据 一、在pom文件中导入shiro的坐标依赖 12345678910&lt;!-- Shiro 三大对象 Subject 用户 SecurityManager 管理用户 Realm 连接数据 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; 二、创建Shiro的配置类一个ShiroConfig类: 该类有三大核心组件： getShiroFilterFactoryBean getDefaultWebSecrityManager userRealm 三大组件相互关联： DefaultWebSecrityManager与userRealm相关联 ShiroFilterFactoryBean与DefaultWebSecrityManager相关联 1234567891011121314151617181920212223242526272829303132333435//ShiroFilterFactoryBean : 3 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean ( @Qualifier(&quot;SecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); return bean; &#125; //DefaultWebSecrityManager :2 @Bean(name=&quot;SecurityManager&quot;) public DefaultWebSecurityManager getDefaultWebSecrityManager ( @Qualifier(&quot;userRealm&quot;) UserRealm userRealm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联UserRealm securityManager.setRealm(userRealm); return securityManager; &#125; //创建realm对象 ，需要自定义类 : 1 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125; 三、创建UserRealm类 并继承AuthorizingRealm类，重写其方法 重写的方法有两个： 1.授权-&gt;doGetAuthorizationInfo 2.认证-&gt;doGetAuthenticationInfo 12345678910111213141516171819202122232425//自定义的UserRealm extends AuthorizingRealmpublic class UserRealm extends AuthorizingRealm &#123; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo (PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行了—&gt; 授权doGetAuthorizationInfo&quot; ); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo (AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了—&gt; 认证doGetAuthorizationInfo&quot; ); return null; &#125;&#125; 实现登录拦截在getShiroFilterFactoryBean组件中 添加shiro的内置过滤器 该过滤器有五大权限: anon：无需认证就可以访问 authc：必需认证才能访问 user：必须拥有 记住我 功能才能用 perms：拥有对某个资源的权限才能访问 role：拥有某个角色权限才能访问 1234567891011121314151617181920212223242526272829303132333435//ShiroFilterFactoryBean : 3 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean ( @Qualifier(&quot;SecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置安全管理器 //defaultWebSecurityManager为 //DefaultWebSecurityManager组件的对象 bean.setSecurityManager(defaultWebSecurityManager); //添加shiro的内置过滤器 /* * anon：无需认证就可以访问 * authc：必需认证才能访问 * user：必须拥有 记住我 功能才能用 * perms：拥有对某个资源的权限才能访问 * role：拥有某个角色权限才能访问 * */ //登录拦截 Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); //添加需要拦截（未登录）的请求 filterChainDefinitionMap.put(&quot;/user/add&quot;,&quot;authc&quot;); filterChainDefinitionMap.put(&quot;/user/update&quot;,&quot;authc&quot;); //filterChainDefinitionMap.put(&quot;/user/*&quot;,&quot;authc&quot;); bean.setFilterChainDefinitionMap(filterChainDefinitionMap); //设置登录页面的路径(当拦截到未登录的请求时，跳转到该页面) bean.setLoginUrl(&quot;/toLogin&quot;); return bean; &#125; 实现用户认证 在登陆的controller中接收用户信息，并封装成一个token（令牌） 1234 UsernamePasswordToken token = new UsernamePasswordToken (username, password);//设置记住我//token.setRememberMe(true); 用当前用户进行登录 1234567891011121314151617181920212223@RequestMapping(&quot;/login&quot;) public String login(String username,String password,Model model)&#123; //获取当前的用户 Subject subject = SecurityUtils.getSubject(); //封装用户的登陆数据 UsernamePasswordToken token = new UsernamePasswordToken (username, password); try&#123; subject.login(token);//执行登录方法，如果没有异常就说明ok &#125;catch (UnknownAccountException e)&#123; model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;); return &quot;login&quot;; &#125;catch (IncorrectCredentialsException e)&#123; model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;); return &quot;login&quot;; &#125; return &quot;index&quot;; &#125; 然后 在userRealm类中的 认证—&gt;方法中对用户名进行认证。。 shiro不用验证密码，shiro自动认证 12345678910111213141516171819202122232425//认证 @Override protected AuthenticationInfo doGetAuthenticationInfo (AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了—&gt; 认证doGetAuthorizationInfo&quot; ); //用户名，密码 数据库中取 String username=&quot;root&quot;;//伪造数据 String password=&quot;123456&quot;; UsernamePasswordToken usertoken = (UsernamePasswordToken) authenticationToken; if(!usertoken.getUsername().equals(username))&#123; return null;//抛出用户名错误异常 UnknownAccountException &#125; //密码认证：shiro做 ,加密了 //该构造方法中三个参数： // 第一个参数为向授权方法中传递的用户信息， // 第二个参数为从数据库中查找的用户的密码，用于shiro验证登录的密码是否正确 return new SimpleAuthenticationInfo (admin,admin.getPassword(),&quot;&quot;); &#125; 整合mybatis的认证首先导入mybatis， mysql，jdbc的相关依赖坐标 在对数据源和mybatis进行配置 写好与登录所需查找用户表相关的mapper 以及其映射文件，及service类 然后 在userRealm类中的 认证—&gt;方法中，通过前端传来的username从数据库中获取 用户信息；并进行认证 1234567891011121314151617181920212223242526 @Autowired private AdminService service; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了—&gt; 认证doGetAuthorizationInfo&quot; ); UsernamePasswordToken usertoken = (UsernamePasswordToken) authenticationToken; //用户名，密码 数据库中取 Admin admin = service.findByUsername(usertoken.getUsername()); if (admin==null)&#123; return null; //UnknowAccountExeception 抛出用户名错误异常 &#125; //密码认证：shiro做 ,加密了 //该构造方法中三个参数： // 第一个参数为向授权方法中传递的用户信息， // 第二个参数为从数据库中查找的用户的密码，用于shiro验证登录的密码是否正确 return new SimpleAuthenticationInfo (admin,admin.getPassword(),&quot;&quot;); &#125;&#125; 实现权限设置在shiroConfig类中可以 对访问某个资源页面所需权限 进行设置 //拦截未拥有对/user/add资源的权限的请求，跳转到未授权页面 filterChainDefinitionMap.put(“/user/add”,”perms[user:add]”); 显示未授权信息的页面也可自己设置 //设置未授权页面的路径bean.setUnauthorizedUrl(“/noauth”); 12345678910111213141516171819202122232425262728293031323334353637 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean ( @Qualifier(&quot;SecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置安全管理器 bean.setSecurityManager(defaultWebSecurityManager); //添加shiro的内置过滤器 /* * anon：无需认证就可以访问 * authc：必需认证才能访问 * user：必须拥有 记住我 功能才能用 * perms：拥有对某个资源的权限才能访问 * role：拥有某个角色权限才能访问 * */ //设置权限 //登录拦截 Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); //拦截未拥有对/user/add资源的权限的请求，跳转到未授权页面 filterChainDefinitionMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); //拦截user下所有未认证请求 filterChainDefinitionMap.put(&quot;/user/*&quot;,&quot;authc&quot;);// filterChainDefinitionMap.put(&quot;/user/add&quot;,&quot;authc&quot;);// filterChainDefinitionMap.put(&quot;/user/update&quot;,&quot;authc&quot;); bean.setFilterChainDefinitionMap(filterChainDefinitionMap); //设置登录页面的路径 bean.setLoginUrl(&quot;/toLogin&quot;); //设置未授权页面的路径 bean.setUnauthorizedUrl(&quot;/noauth&quot;); return bean; &#125; 实现用户授权在UserRealm类的 授权-&gt;doGetAuthorizationInfo方法中对当前用户所拥有 用户权限进行授权 123456789101112131415//授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行了—&gt; 授权doGetAuthorizationInfo&quot; ); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //拿到当前登录的对象,该对象为 认证方法返回值的第一个参数 Subject subject = SecurityUtils.getSubject(); Admin admin = (Admin) subject.getPrincipal(); //给用户添加在ShiroConfig类中设置的相关权限。 //(参数为admin用户所拥有的权限) info.addStringPermission ( admin.getPerms() ); return info; &#125; shiro整合thymeleaf 导入相关依赖 123456&lt;!-- shiro整合thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 在shiroConfig中将ShiroDialect配置到容器中 用来整合shiro 和 thymeleaf 12345//整合ShiroDialect ：用来整合shiro 和 thymeleaf @Bean public ShiroDialect getShiroDialect()&#123; return new ShiroDialect(); &#125; 最后 使用 在拥有该权限时，显示该模块 1234567&lt;div shiro:hasPermission=&quot;user:add&quot;&gt; &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt; &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;&lt;/div&gt; 十一、整合Swagger简介 号称世界上最流行的Api框架 RestFul Api文档在线生成工具-&gt;Api文档与API定义同步更新 直接运行，可以在线测试API接口； 支持多种语言 springboot集成Swagger 新建一个springboot项目 导入相关依赖 1234567891011&lt;!-- swagger依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 创建SwaggerConfig类，@EnableSwagger2注解开启Swagger2 此时Swagger2已经可以使用，（设置为默认配置） 1234@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123;&#125; 测试运行： localhost:8080//swagger-ui.html 配置Swagger 再SwaggerConfig类中配置了Swagger的Docket的bean实例 123456789101112131415161718192021222324252627282930313233@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; //配置了Swagger的Docket的bean实例 @Bean public Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) //配置Swagger信息 .select() //RequestHandlerSelectors :配置要扫描接口的方式 //basePackage 指定要扫描的包 .apis(RequestHandlerSelectors.basePackage(&quot;com.xyc&quot;)) //.paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;))) //.paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;))) .build(); &#125; //配置Swagger信息 private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() .title(&quot;谷粒学院-SwaggerAPI文档&quot;) .description(&quot;本文档描述了课程中心微服务接口定义&quot;) .version( &quot;v1.0&quot;) .contact(new Contact(&quot;java&quot;,&quot;http://www.baidu.com&quot;,&quot;452662481@qq.com&quot;)) .build(); &#125;&#125; 十二、任务1、异步任务常规使用异步任务，我们需要自定义多线程，通过开启线程来处理异步任务 springboot使用异步任务，只需用@EnableAsync 注解开启异步任务功能，并在指定方法上使用@Async注解标注该方法为异步任务。 案例： 用一个AsyncService类模拟数据处理， 如果不使用异步任务，在提交请求后，系统会把数据处理完成后，才进行响应。 service 123456789101112131415161718192021222324252627282930package com.xyc.service;import org.springframework.stereotype.Service;/** * 2020/5/1 22:39 * 文件说明：模拟一个service 需要进行处理一个耗时时间长的任务 * * @author xyc * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Servicepublic class AsyncService &#123; public void hello()&#123; System.out.println(&quot;数据正在处理。。。&quot;); try &#123; System.out.println(&quot;数据3秒后处理完成。。。&quot;); Thread.sleep(1000); System.out.println(&quot;数据2秒后处理完成。。。&quot;); Thread.sleep(1000); System.out.println(&quot;数据1秒后处理完成。。。&quot;); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;数据处理完成。。。&quot;); &#125;&#125; controller 12345678910111213141516171819202122232425262728293031package com.xyc.controller;import com.xyc.service.AsyncService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * 2020/5/1 22:43 * 文件说明： * * @author xyc * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@EnableAsync@RestControllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @Async @RequestMapping(&quot;/hello&quot;) public String hello()&#123; asyncService.hello(); return &quot;hello&quot;; &#125;&#125; 2、定时任务主要的类与注解 12345678910TaskScheduler 任务调度者TaskExecutor 任务执行者@EnableScheduling &#x2F;&#x2F;开启定时功能的注解&#x2F;&#x2F;在特定时间执行这个方法&#x2F;&#x2F; 秒 分 时 日 月 周几@Scheduled(cron &#x3D; &quot;10 31 20 * * ?&quot;)cron表达式 使用案例 1234567891011@EnableScheduling//开启定时功能的注解@Servicepublic class ScheduledService &#123; //在特定时间执行这个方法 // 秒 分 时 日 月 周几 @Scheduled(cron = &quot;10 31 20 * * ?&quot;) public void hello()&#123; System.out.println(&quot;hello ya~&quot;); &#125;&#125; 3、邮件任务javaWeb原生的发送邮件需要手动配置好多的东西，使用springboot发送邮件，只需要在配置文件中配置邮件相关信息，并 new一个JavaMailSenderImpl类，并调用send方法即可。 在springboot中存在一个 MailSenderAutoConfiguration类，在里面面定义了对mail的自动配置。 在MailProperties.class类中定义了电子邮件支持的配置属性，即在application.yml配置文件中需要配置的相关属性 1234567891011121314151617181920@ConfigurationProperties(prefix = &quot;spring.mail&quot;)public class MailProperties &#123; private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8; /** SMTP server host. For instance, `smtp.example.com`.*/ private String host;//主机 smtp.XXX.com /** SMTP server port.*/ private Integer port;//端口 /** Login user of the SMTP server.*/ private String username;//用户名 /** Login password of the SMTP server.*/ private String password;//密码 /** Protocol used by the SMTP server.*/ private String protocol = &quot;smtp&quot;;//协议 /** Default MimeMessage encoding.*/ private Charset defaultEncoding = DEFAULT_CHARSET; /** Additional JavaMail Session properties.*/ private Map&lt;String, String&gt; properties = new HashMap&lt;&gt;(); /** Session JNDI name. When set, takes precedence over other Session settings.*/ private String jndiName; 并导入了MailSenderJndiConfiguration.class和MailSenderPropertiesConfiguration.class对邮件发送人进行自动配置，使我们在需要发送邮件时只需要直接调用JavaMailSenderImpl即可 1@Import(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;) javaMailSenderImpl实现了JavaMailSender接口，并同时支持JavaMail &#123;@link MimeMessage MimeMessages&#125;和Spring &#123;@link SimpleMailMessage SimpleMailMessages&#125;可以仅仅当做mailSender的实现类使用， 允许将所有设置本地定义为Bean属性。或者，可以指定一个预先配置的JavaMail {@link javax.mail.Session}，可以从应用程序服务器的JNDI环境中提取。 javaMailSenderImpl中发送邮件需要的的一些方法实现， 123456789101112131415161718192021 //--------------------------------------------------------------------- // Implementation of MailSender //--------------------------------------------------------------------- //发送简单邮件消息 public void send(SimpleMailMessage simpleMessage) throws MailException &#123;&#125; public void send(SimpleMailMessage... simpleMessages) throws MailException &#123; &#125; //--------------------------------------------------------------------- // Implementation of JavaMailSender //---------------------------------------------------------------------//返回一个MimeMessage类，此类用于定义发送邮件消息的相关信息 public MimeMessage createMimeMessage() &#123;&#125; public MimeMessage createMimeMessage(InputStream contentStream) throws MailException &#123;&#125;//发送复杂的邮件//包括支持html和可以发送附件，在使用时需要借助MimeMessageHelper类 public void send(MimeMessage mimeMessage) throws MailException &#123;&#125; public void send(MimeMessage... mimeMessages) throws MailException &#123;&#125; public void send(MimeMessagePreparator mimeMessagePreparator) throws MailException &#123;&#125; public void send(MimeMessagePreparator... mimeMessagePreparators) throws MailException &#123;&#125; 使用 导入坐标依赖 在yml文件中配置相关信息 编写邮件并发送 坐标依赖 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 配置信息 12345678spring: mail: username: 13072667463@163.com password: XYC123456 host: smtp.163.com #qq邮箱需要开启加密验证 使用 实例化 JavaMailSenderImpl类 发送简单邮件时，实例化SimpleMailMessage对象，并在里面配置所发送邮件的相关信息 发送复杂邮件时，通过JavaMailSenderImp的实例化对象，调用createMimeMessage()方法创建MimeMessage对象，并通过MimeMessageHelper对象配置所发送邮件的相关信息 可以通过Ctrl+左键点击类中，来查看发送邮件信息所需要的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.xyc.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import org.springframework.mail.javamail.MimeMailMessage;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Service;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import javax.xml.soap.MimeHeader;import java.io.File;/** * 2020/5/4 10:20 * 文件说明： * * @author xyc * 梦可以到的地方，只要努力，总有一天，自己也可以达到！ */@Servicepublic class MailService &#123; @Autowired private JavaMailSenderImpl mailSender; //简单的邮件 public void simpleSend()&#123; //创建简单邮件信息 SimpleMailMessage simpleMailMessage =new SimpleMailMessage(); //设置标题 simpleMailMessage.setSubject(&quot;你好啊！&quot;); //设置内容 simpleMailMessage.setText(&quot;哈哈哈哈哈&quot;); simpleMailMessage.setTo(&quot;452662481@qq.com&quot;); simpleMailMessage.setFrom(&quot;13072667463@163.com&quot;); mailSender.send(simpleMailMessage); &#125; public void mimeSend() throws MessagingException &#123; MimeMessage mimeMessage = mailSender.createMimeMessage(); // @param mimeMessage the mime message to work on // @param multipart whether to create a multipart message that // supports alternative texts, inline elements and attachments MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage,true); messageHelper.setSubject(&quot;你好啊&quot;); messageHelper.setText(&quot;&lt;p style=&#x27;color:red&#x27;&gt;薛云冲，&lt;br&gt;你订购的软件的验证码123123&lt;/p&gt;&quot;,true); messageHelper.setTo(&quot;452662481@qq.com&quot;); messageHelper.setFrom(&quot;13072667463@163.com&quot;); //添加附件 messageHelper.addAttachment(&quot;&quot;,new File(&quot;&quot;)); mailSender.send(mimeMessage); &#125;&#125; 十三、整合Redisspringboot在 RedisAutoConfiguration 中为我们自动配置了Redis RedisAutoConfiguration类 123456789101112131415161718192021222324252627282930@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)public class RedisAutoConfiguration &#123; @Bean //当redisTemplate不存在时使用下面的配置，即当我们需要自己定制redisTemplate时， //可以自行定义redisTemplate来替换这个默认值 @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; //默认的RedisTemplate没有过多的设置，redis对象都需要序列化 //两个泛型都是Object，Object的类型，使用时需要强制类型转换&lt;String ,Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean //由于string类型是redis最常用的类型，所以特别提出了一个类 public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 在application.yml配置文件中需要配置的相关属性在RedisProperties.class类中定义 RedisProperties.class类 12345678910111213141516171819202122@ConfigurationProperties(prefix = &quot;spring.redis&quot;)public class RedisProperties &#123; /** Database index used by the connection factory.*/ private int database = 0; /** Connection URL. Overrides host, port, and password. User is ignored. */ private String url; /** Redis server host.*/ private String host = &quot;localhost&quot;; /** Login password of the redis server.*/ private String password; /** Redis server port.*/ private int port = 6379; /**Whether to enable SSL support.*/ private boolean ssl; /** Connection timeout.*/ private Duration timeout; /** Client name to be set on connections with CLIENT SETNAME.*/ private String clientName; private Sentinel sentinel; private Cluster cluster; private final Jedis jedis = new Jedis(); private final Lettuce lettuce = new Lettuce(); 使用1、导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置连接 12345spring: redis: host: 127.0.0.1 post: 6379 3.测试 12345678910111213141516@Autowired RedisTemplate redisTemplate; @Test void contextLoads() &#123; // opsForValue() // opsForList() // opsForSet() // opsForHash() // opsForZSet() // opsForGeo() // opsForHyperLogLog() redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;myValue&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;)); &#125; 十四、消息队列rabbitmq简介RabbitMQ是一个erlang开发的AMQP（Advanved Message Queue Protoco）的开源实现 核心概念Message：消息，消息不是具体名，它是由消息头和消息体组成，消息体是不透明的，而消息头则是由一系列的可选的属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher：消息生产着，也是一个向交换器发布消息的客户端应用程序。 Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange（四种类型）：1、direct（默认），fanout，topic，headers，不同类型的Exchange的转发消息的策略有区别 Queue：消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走 Binding：绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 Exchange和Queue之间绑定是多对多的关系。 Conection：网络连接 Channel：信道，多路复用链接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息，订阅队列还是接受信息都是通过信道完成。 Consumer：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序 Virtual Host：虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。 Broker：表示消息队列服务器实体 RabbitMQ运行图解 Exchange（四种类型） 1、direct（默认）：（单播模式）完全匹配，点对点 2、fanout：（广播模式，发布订阅）fanout交换器不会处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。 3、topic：通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定在一个模式上。他将路由键和绑定键的字符串分为多个单词，这些单词之间用点隔开。他同样也会识别两个通配符：符号“#”：匹配0个或多个单词，“*”匹配一个单词。 4、headers，headers匹配的是消息头而不是路由键，和direct一样完全匹配，点对点，性能不行，不怎么用 rabbitMQ使用使用Docker安装RabbitMQ 12345# 拉取镜像docker pull rabbitmq:3-management# 启动镜像 docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 镜像id 可以通过 15672端口访问Web界面 Web界面的登录密码 默认用户：guest 密码：guest 添加Exchange 添加queue Exchange bind queue 发送消息 接收消息 整合RabbitMQ自动装配 探究Springboot自动装配RabbitMQ 我们先搜索 RabbitAutoConfiguration 该类为RabbitMQ自动配置类 里面有三个静态内部类 1、RabbitConnectionFactoryCreator类中的rabbitConnectionFactory方法将rabbit的连接对象注入容器，rabbitConnectionFactory方法的参数RabbitProperties中封装了配置RabbitMQ的所有配置，即我们在配置文件中写的配置信息. RabbitProperties类,为获取配置文件内容的类 2、RabbitTemplateConfiguration类中配置了RabbitTemplate，amqpAdmin RabbitTemplate: RabbitMQ发送消息和接受消息 AmqpAdmin：RabbitMQ系统管理功能组件 使用1、导入pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置文件中配置rabbitmq 12345spring.rabbitmq.host=47.94.45.85spring.rabbitmq.port=5672#端口号不写默认是 5672#用户密码不写，默认是 guest#虚拟主机不写默认是 &quot;/&quot; 3、测试使用 发送信息 12345//Message需要自己构造一个:定义消息体和消息头//rabbitTemplate.send(exchange,routeKey,message);//object默认当做message，只需要传入要发送的对象，自动序列化发送给RabbitMQ//rabbitTemplate.convertAndSend(exchange,routeKey,object); 单播模式（direct） 12345678910111213141516@Autowired RabbitTemplate rabbitTemplate; /* * 1、单播（点对点） * */ @Test void contextLoads() &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,&quot;这是第一个&quot;); map.put(&quot;data&quot;, Arrays.asList(&quot;helloworld&quot;,123,true)); //对象被默认序列化以后发送出去 rabbitTemplate.convertAndSend (&quot;exchange.direct&quot;,&quot;atguigu.news&quot;,map); &#125; 广播模式（fanout） 12345678910/** * 广播 */ @Test public void sendMsg() &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,&quot;这是第二个&quot;); map.put(&quot;name&quot;,&quot;西游记&quot;); rabbitTemplate.convertAndSend(&quot;exchange.fanout&quot;,&quot;&quot;,map); &#125; 此时，无论单播、广播，所使用的MessageConverter都是默认的，在序列化时使用的Java的序列化，在消息队列中的是通过Java的序列化编码的格式 而我们一般都会发送Json格式的数据，此时就需要我们自己配置MessageConverter 123456789101112@Configurationpublic class MyAmqpConfig &#123; /** * 配置Json格式的MessageConverter * 当我们自己配置过MessageConverter之后， * 会使用我们配置的MessageConverter * */ @Bean public MessageConverter messageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125;&#125; 当我们配置好Json格式的MessageConverter之后，再发送消息 接受消息 1234567891011/** * 接受数据， */ @Test public void receive()&#123; //接受指定的消息队列中的消息，并返回一个Message //Message receive = rabbitTemplate.receive(&quot;atguigu.news&quot;); Object o = rabbitTemplate.receiveAndConvert(&quot;atguigu.news&quot;); System.out.println(o.getClass()); System.out.println(o); &#125; 结果： 消息监听 用来监听消息队列中收到的消息 只需要两个注解@EnableRabbit + @RabbitListener 监听消息队列的内容 @EnableRabbit；开启基于注解的RabbitMQ模式 @RabbitListener ：监听指定的消息队列 案例： 开启注解 12345678910//开启基于注解的RabbitMQ模式@EnableRabbit@SpringBootApplicationpublic class SpringbootAmqpApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootAmqpApplication.class, args); &#125;&#125; 启动监听 123456789101112131415@Servicepublic class BookService &#123; @RabbitListener(queues = &quot;atguigu.news&quot;) public void receive01(Book book)&#123; System.out.println(&quot;收到消息：&quot;+book); &#125; @RabbitListener(queues = &quot;atguigu&quot;) public void receive02(Message message)&#123; System.out.println(message.getBody()); System.out.println(message.getMessageProperties()); &#125;&#125; 当使用这两个注解之后，每次向指定该消息队列中发送消息时，这两个方法就会自动从该消息队列中获取消息。 结果展示： 管理RabbitMQ的组件 AmqpAdmin：RabbitMQ系统管理功能组件,可以创建、删除 queue Exchange Binding 使用案例 12345678910111213141516171819202122232425@Autowired AmqpAdmin amqpAdmin; @Test public void createExchange()&#123; //以declare***开头的 一般都是 amqpAdmin.declareExchange(new DirectExchange(&quot;amqpadmin.exchange&quot;)); System.out.println(&quot;创建成功&quot;); amqpAdmin.declareQueue(new Queue(&quot;amqpadmin.queue&quot;,true)); System.out.println(&quot;创建成功&quot;); amqpAdmin.declareBinding(new Binding(&quot;amqpadmin.queue&quot;, Binding.DestinationType.QUEUE, &quot;amqpadmin.exchange&quot;,&quot;amqp.haha&quot;,null)); //以delete或remove开头的一般都是删除 amqpAdmin.removeBinding(new Binding(&quot;amqpadmin.queue&quot;, Binding.DestinationType.QUEUE, &quot;amqpadmin.exchange&quot;,&quot;amqp.haha&quot;,null)); amqpAdmin.deleteQueue(&quot;amqpadmin.queue&quot;); amqpAdmin.deleteExchange(&quot;amqpadmin.exchange&quot;); &#125; 十五、ElasticSearchElasticsearch概述Elasticsearch是一个分布式、高度可扩展的开源全文本搜索和分析引擎。它使您可以快速，近乎实时地存储，搜索和分析大量数据。它通常用作支持具有复杂搜索功能和要求的应用程序的基础引擎/技术。 Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene基础之上,Lucene 仅仅只是一个库。 Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎, Elasticsearch 是 一个分布式的实时文档存储，每个字段 可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据 安装123456# 拉取镜像docker pull docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.9.3# 运行docker run -d -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS&#x3D;&quot;-Xms512m -Xmx512m&quot; -e -Des.scripting.exception_for_missing_value&#x3D;true --name elasticsearch 镜像ID 安装成功标志 简介Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档。Elasticsearch 不仅存储文档，而且 索引 每个文档的内容，使之可以被检索。在 Elasticsearch 中，我们对文档进行索引、检索、排序和过滤—而不是对行列数据。 Elasticsearch 使用 JSON 作为文档的序列化格式。 例：这就代表一个User对象 1234567891011&#123; &quot;email&quot;: &quot;john@smith.com&quot;, &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;info&quot;: &#123; &quot;bio&quot;: &quot;Eco-warrior and defender of the weak&quot;, &quot;age&quot;: 25, &quot;interests&quot;: [ &quot;dolphins&quot;, &quot;whales&quot; ] &#125;, &quot;join_date&quot;: &quot;2014/05/01&quot;&#125; 一个 Elasticsearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。 索引（名词）：如前所述，一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes 。 索引（动词）：索引一个文档 就是存储一个文档到一个 索引 （名词）中以便被检索和查询。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时，新文档会替换旧文档情况之外。 入门使用新增（索引）员工PUT请求 ==注意：== 新增是发PUT请求 路径 /megacorp/employee/1 包含了三部分的信息： megacorp 索引名称 employee 类型名称 1 特定雇员的ID 请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息， 他的名字叫 John Smith ，今年 25 岁，喜欢攀岩。 响应 修改员工和新增时的操作是一样的，都是PUT请求 此次对ID为1的员工进行修改 响应结果： ==注意==：和上面 第一次添加时进行对比，可以发现_version变为了 2 检索（查找）员工get请求 响应 查找成功 查找失败 轻量搜索数据依然是get请求，但是此时并没有指定文档ID，而是使用_search.返回结果放在一个hits数组中，默认一个搜索返回十条数据 _search 无参数返回结果放在一个hits数组中，默认一个搜索返回十条数据 _search 带参数 将查询本身赋值给参数q=，返回所有last_name为Smith的员工 查询表达式搜索领域特定语言 （DSL）， 使用 JSON 构造了一个请求。 案例1 响应和上面查询的结果一样 案例2 查询姓氏为Smith ，年龄大于30 的员工 全文搜索查询所有喜欢攀岩（rock climbing）的员工 响应结果： 查询结果不但返回了John Smith 还返回了Jane Smith ，Jane Smith的about中只有rock albums 而没有 rock climbing 。 原因 Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。 短语搜索找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者_短语_ 。 为此对 match 查询稍作调整，使用一个叫做 match_phrase 的查询 高亮查询在查询时，增加一个新的 highlight 参数 响应 当执行该查询时，返回结果与之前一样，与此同时结果中还多了一个叫做 highlight 的部分。这个部分包含了 about 属性匹配的文本片段，并以 HTML 标签 &lt;em&gt;&lt;/em&gt; 封装： 深入学习《Elasticsearch: 权威指南》 https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html","categories":[{"name":"springboot","slug":"springboot","permalink":"http://javacoderx.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://javacoderx.github.io/tags/springboot/"}]},{"title":"docker","slug":"docker","date":"2021-04-23T09:35:55.000Z","updated":"2021-04-23T01:38:27.829Z","comments":true,"path":"2021/04/23/docker/","link":"","permalink":"http://javacoderx.github.io/2021/04/23/docker/","excerpt":"","text":"","categories":[{"name":"docker","slug":"docker","permalink":"http://javacoderx.github.io/categories/docker/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://javacoderx.github.io/tags/spring/"},{"name":"docker","slug":"docker","permalink":"http://javacoderx.github.io/tags/docker/"}]}],"categories":[{"name":"openjdk","slug":"openjdk","permalink":"http://javacoderx.github.io/categories/openjdk/"},{"name":"jvm","slug":"jvm","permalink":"http://javacoderx.github.io/categories/jvm/"},{"name":"springboot","slug":"springboot","permalink":"http://javacoderx.github.io/categories/springboot/"},{"name":"docker","slug":"docker","permalink":"http://javacoderx.github.io/categories/docker/"}],"tags":[{"name":"openjdk","slug":"openjdk","permalink":"http://javacoderx.github.io/tags/openjdk/"},{"name":"jvm","slug":"jvm","permalink":"http://javacoderx.github.io/tags/jvm/"},{"name":"springboot","slug":"springboot","permalink":"http://javacoderx.github.io/tags/springboot/"},{"name":"spring","slug":"spring","permalink":"http://javacoderx.github.io/tags/spring/"},{"name":"docker","slug":"docker","permalink":"http://javacoderx.github.io/tags/docker/"}]}