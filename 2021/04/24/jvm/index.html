<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>深入理解JVM虚拟机---类加载、内存区域、GC | 太阳以西？</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="太阳以西？,Java,javaweb,Spring,SpringBoot" />
  
  <meta name="description" content="Java是跨平台语言，图示  1、类加载器 类加载器子系统：从文件系统或网络中加载class文件，class文件在文件开头有特定的文件标识 CAFEBABE   类加载器加载的类信息，会放在方法区的内存空间。 1.1、类加载的过程加载阶段： 1、通过类的全限定类名获取此类的二进制流 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3、在内存中生成一个代表这个类的java.lang">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解JVM虚拟机---类加载、内存区域、GC">
<meta property="og:url" content="http://javacoderx.github.io/2021/04/24/jvm/index.html">
<meta property="og:site_name" content="太阳以西？">
<meta property="og:description" content="Java是跨平台语言，图示  1、类加载器 类加载器子系统：从文件系统或网络中加载class文件，class文件在文件开头有特定的文件标识 CAFEBABE   类加载器加载的类信息，会放在方法区的内存空间。 1.1、类加载的过程加载阶段： 1、通过类的全限定类名获取此类的二进制流 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3、在内存中生成一个代表这个类的java.lang">
<meta property="og:locale">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126202809298.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20200912165603993.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20200913152847582.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20200914183457440.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20200914172118426.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20200924160452119.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20200924163935515.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20200925164559876.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/code-snapshot.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201009172447450.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201009175551410.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201010162742612.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201010172328192.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201015202440889.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201017205822018.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201017211945612.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201102195002805.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201102195228725.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201102195611286.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201102195735794.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201102201925840.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201102202807906.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201109192046550.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201109192738361.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201109195159168.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201109212758546.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201109213330064.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201109214224370.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201109202543712.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110125342683.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110125650108.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110130516276.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110130730241.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110132130250.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110142424421.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110143208836.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110143113660.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110145233781.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110154456278.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110154617842.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110154737061.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110155055349.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110155319261.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110155507948.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110160331301.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110160218483.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201111202332794.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201111203941261.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201111210312197.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201111210549329.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201111211529894.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201111211707815.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201125132932716.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201125133354817.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201125132227362.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201125132453908.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201125132712335.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126201652048.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126203120106.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126203902325.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126204306772.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126204451262.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126210712686.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126210905356.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126211044255.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126211311512.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126211339671.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126211736601.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126204831674.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126205239135.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126210128587.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201127172845584.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201127213035609.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201127213057784.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201127210329568.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201127214153352.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201130164354069.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201130164934767.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201130165652074.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201130195351926.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201130202642140.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201202130932576.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110125342683.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201110125650108.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201202133915267.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201202140116916.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201202141122888.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201202142227675.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201202201858934.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201202201040221.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201202204219705.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201203132929128.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201203205300528.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201203205959175.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201203210734565.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201203211529764.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201204132441989.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201204132904615.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201204132959999.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201204135413684.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201204135510965.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201208100034333.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201208105811408.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201208105657120.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201208110456556.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201208110634652.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201208111121313.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201208133618776.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201208134213579.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201209202851516.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201209204809938.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201209210600025.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201209211700592.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201209213604959.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211161610113.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211173159360.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211202000137.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211202015897.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211202712630.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211202911595.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211203838984.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211203851368.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211204517387.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211210127002.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201211211016183.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201214103147146.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201214110226917.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201226150313229.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201226161021888.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201226161806507.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227151136642.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227151207233.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227151756253.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227153424398.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227154131529.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227154300730.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227155058820.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227162953548.png">
<meta property="og:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201227195843161.png">
<meta property="article:published_time" content="2021-04-23T21:24:21.000Z">
<meta property="article:modified_time" content="2021-04-23T13:30:54.952Z">
<meta property="article:author" content="xyc">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://javacoderx.github.io/2021/04/24/jvm/image-20201126202809298.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">太阳以西？</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        太阳以西？
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个专注 WEB 开发的技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Home" target="_blank" href="//javacoderx.github.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/javacoderx">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="13072667463"  ">
                            <i class="fa fa-weixin fa-2x"></i></a>
                    
                        <a title="452662481"  ">
                            <i class="fa fa-qq fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-jvm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      深入理解JVM虚拟机---类加载、内存区域、GC
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/jvm/">jvm</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2021-04-23
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <p>Java是跨平台语言，图示</p>
<p><img src="/2021/04/24/jvm/image-20201126202809298.png" alt="image-20201126202809298"></p>
<h2 id="1、类加载器"><a href="#1、类加载器" class="headerlink" title="1、类加载器"></a>1、类加载器</h2><blockquote>
<p><strong>类加载器子系统</strong>：从文件系统或网络中加载class文件，class文件在文件开头有特定的文件标识 <strong>CAFEBABE</strong></p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20200912165603993.png" alt="image-20200912165603993"></p>
<p>类加载器加载的类信息，会放在方法区的内存空间。</p>
<h3 id="1-1、类加载的过程"><a href="#1-1、类加载的过程" class="headerlink" title="1.1、类加载的过程"></a>1.1、类加载的过程</h3><p><strong>加载阶段</strong>：</p>
<p>1、通过类的全限定类名获取此类的二进制流</p>
<p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<p><strong>链接阶段</strong></p>
<ul>
<li><p><strong>验证</strong>（Verify）：</p>
<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，确保被加载类的正确性。不会危害虚拟机自身安全</li>
<li>四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ul>
</li>
<li><p><strong>准备</strong></p>
<ul>
<li>为<strong>类变量</strong>分配内存并设置该类的默认初始化值。</li>
<li>不包含用final修饰的static ，因为final在编译的时候就会分配了，准备阶段会显示初始化；</li>
<li>不会为实例变量分配初始化，类变量会分配在方法区，实例变量会随着对象一起分配到Java堆中。</li>
</ul>
</li>
<li><p><strong>解析</strong></p>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。直接引用就是指向目标的指针、相对偏移量或者一个间接定位到目标的句柄</li>
<li><strong>解析动作</strong>主要针对 类或接口、字段、类方法、方法类型等</li>
</ul>
</li>
</ul>
<p><strong>初始化阶段</strong></p>
<ul>
<li>初始化阶段就是执行类构造方法<clinit>的过程</clinit></li>
<li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令是按照语句在文件中出现的顺序执行</li>
<li><code>&lt;Clinit&gt;( )</code>不同于类的构造器。（注意：类构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li>
<li>若该类有super类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，super类的<code>&lt;clinit&gt;</code>已经执行完毕<ul>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;</code>方法在多线程下被同步加锁</li>
</ul>
</li>
</ul>
<h3 id="1-2、类加载器的分类"><a href="#1-2、类加载器的分类" class="headerlink" title="1.2、类加载器的分类"></a>1.2、类加载器的分类</h3><p>总的来说类加载器分为两大类：引导类加载器，用户自定义类加载器</p>
<p>如图所示：</p>
<p>在图中除了Bootstrap Class Loader以外，其他的类加载器都<strong>直接或间接</strong>的继承ClassLoader</p>
<p><img src="/2021/04/24/jvm/image-20200913152847582.png" alt="image-20200913152847582"></p>
<h4 id="1-2-1、引导类加载器"><a href="#1-2-1、引导类加载器" class="headerlink" title="1.2.1、引导类加载器"></a><strong>1.2.1、引导类加载器</strong></h4><blockquote>
<p><strong>（启动类加载器 Bootstrap Class Loader）</strong></p>
</blockquote>
<ul>
<li><p>c/c++实现，嵌套在JVM内部</p>
</li>
<li><p>用来加载JAVA核心库（jre/lib/rt.jar 、resource.jar 或者sun.boot.class.path路径下的内容，用于提供JVM自身需要的类）</p>
</li>
<li><p>没有继承 ClassLoader</p>
</li>
<li><p>加载 扩展类和应用程序类加载器，并指定他们的父类加载器</p>
</li>
<li><p>只加载java、javax、sun开头的类</p>
</li>
</ul>
<h4 id="1-2-2、扩展类加载器"><a href="#1-2-2、扩展类加载器" class="headerlink" title="1.2.2、扩展类加载器"></a><strong>1.2.2、扩展类加载器</strong></h4><blockquote>
<p><strong>（Extension ClassLoader）</strong></p>
</blockquote>
<ul>
<li><p><strong>java编写的</strong></p>
</li>
<li><p><strong>派生于ClassLoader类</strong></p>
</li>
<li><p>是由引导类加载器 加载的</p>
</li>
<li><p>从java.ext.dirs系统属性所制定的目录下加载类库，或者从JDK的安装目录jre/lib/ext子目录下加载类库。<strong>用户创建的JAR放在此位置，也会自动由扩展类加载器加载</strong></p>
</li>
</ul>
<h4 id="1-2-3、应用程序类加载器"><a href="#1-2-3、应用程序类加载器" class="headerlink" title="1.2.3、应用程序类加载器"></a><strong>1.2.3、应用程序类加载器</strong></h4><blockquote>
<p><strong>（系统类加载器 AppClassLoader）</strong></p>
</blockquote>
<ul>
<li>java编写</li>
<li>派生于ClassLader</li>
<li>由扩展类加载器 加载</li>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载程序中默认的类加载器</li>
<li>通过ClassLoader.getSystemClassLoader()方法可以获取该类加载器</li>
</ul>
<h4 id="1-2-4、用户自定义类加载器"><a href="#1-2-4、用户自定义类加载器" class="headerlink" title="1.2.4、用户自定义类加载器"></a><strong>1.2.4、用户自定义类加载器</strong></h4><p><strong>为什么要自定义类加载器？</strong></p>
<ul>
<li><p>隔离加载类</p>
</li>
<li><p>修改类加载的方式</p>
</li>
<li><p>扩展加载源</p>
</li>
<li><p>防止源码泄露</p>
</li>
</ul>
<p><strong>自定义类加载器实现步骤</strong></p>
<p>1、可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</p>
<p>2、在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载器，但是在JDK1.2之后，不建议覆盖loadClass（）方法，而是建议把自定义的类加载逻辑写在findClass（）方法中</p>
<p>3、在编写自定义类加载器时，如果没有太复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass（）方法及其获取字节码流的方式。</p>
<h3 id="1-3、ClassLoader类的常用方法"><a href="#1-3、ClassLoader类的常用方法" class="headerlink" title="1.3、ClassLoader类的常用方法"></a>1.3、ClassLoader类的常用方法</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getParent（）</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass（String name）</td>
<td>加载名称为name的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass（String name）</td>
<td>使用指定的二进制名称查找类。</td>
</tr>
<tr>
<td>findLoadedClass（String name）</td>
<td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>defineClass（String name ，byte[] b , int off , int len）</td>
<td>将一个 byte 数组转换为java.lang.Class类的实例。</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个java类</td>
</tr>
</tbody></table>
<blockquote>
<p>获取ClassLoader的方法</p>
</blockquote>
<p>1、class.getClassLoader() ：获取当前类的类加载器</p>
<p>2、Thread.currentThread().getContextClassLoader(); 获取当前线程上下文的ClassLoader</p>
<p>3、ClassLoader.getSystemClassLoader();获取当前系统的ClassLoader</p>
<p>4、DriverManager.getCallerClassLoader()  获取调用者的ClassLoager000</p>
<h3 id="1-4、双亲委派机制"><a href="#1-4、双亲委派机制" class="headerlink" title="1.4、双亲委派机制"></a>1.4、双亲委派机制</h3><p><strong>工作原理</strong></p>
<p>1、如果一个类加载器收到了类加载得请求，他并不会自己去加载，而是把这个请求委托给父类加载器去执行</p>
<p>2、如果父类加载器还存在父类加载器，则进一步向上委托，依次递归请求，最终将到达引导类加载器</p>
<p>3、如果父类加载器可以完成加载任务，就成功返回，若父类加载器无法完成加载任务，子类加载器才会尝试自己去加载</p>
<p>==注意：==这里说的父类加载器，指的是加载该类加载器的类加载器</p>
<p><strong>优势</strong></p>
<p>1、避免类的重复加载</p>
<p>2、保护程序安全，防止核心api被篡改。</p>
<h3 id="1-5、类的使用方式"><a href="#1-5、类的使用方式" class="headerlink" title="1.5、类的使用方式"></a>1.5、类的使用方式</h3><blockquote>
<p>类的使用方式分为主动使用和被动使用</p>
</blockquote>
<p><strong>主动使用</strong></p>
<p>1、创建类的实例</p>
<p>2、访问某个类或借口的静态变量，或者对静态变量赋值</p>
<p>3、调用类的静态方法</p>
<p>4、反射</p>
<p>5、初始化一个类的子类</p>
<p>6、Java虚拟机启动时被标明为启动类的类</p>
<p>7、JDK7开始提供的动态语言支持</p>
<p>其他的使用JAVA类的方式都是类的<strong>被动使用</strong>，都不会进行类的初始化</p>
<h2 id="2、运行时数据区"><a href="#2、运行时数据区" class="headerlink" title="2、运行时数据区"></a>2、运行时数据区</h2><blockquote>
<p>Java虚拟机定义了部分程序运行期间会使用运行时数据区，其中一部分随虚拟机的创建销毁而创建销毁，一部分是跟线程对应的</p>
</blockquote>
<p><strong>运行时数据区内存模型</strong></p>
<p><img src="/2021/04/24/jvm/image-20200914183457440.png" alt="image-20200914183457440"></p>
<p><img src="/2021/04/24/jvm/image-20200914172118426.png" alt="image-20200914172118426"></p>
<h3 id="2-1、程序计数器"><a href="#2-1、程序计数器" class="headerlink" title="2.1、程序计数器"></a>2.1、程序计数器</h3><blockquote>
<p>(<strong>program Counter Register</strong>) <strong>程序计数寄存器</strong> 又称<strong>PC寄存器</strong></p>
</blockquote>
<p><strong>作用</strong>：<strong>PC寄存器用来存储当前线程指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</strong></p>
<ul>
<li>是一块较小的内存空间</li>
<li>每一条Java虚拟机线程都有自己的pc寄存器。</li>
<li>可看作当前线程所执行的字节码的行号指示器</li>
<li>任意时刻，一条Java虚拟机线程只会运行一个方法，该方法被称为当前方法</li>
<li>若该方法不是native的，那pc寄存器就保存Java虚拟机正在执行的字节码指令的地址</li>
</ul>
<p>若是native的，那么pc寄存器的值是undefined。</p>
<ul>
<li>pc寄存器的容量，至少可以存一个returnAddress类型的数据或者一个与平台相关的</li>
</ul>
<p>本地指针的值</p>
<ul>
<li>此区域是唯一一个在Java虚拟机规范中没有规定任何OurOfMemoryError情况的区域</li>
</ul>
<p><img src="/2021/04/24/jvm/image-20200924160452119.png" alt="image-20200924160452119"></p>
<h3 id="2-2、Java虚拟机栈"><a href="#2-2、Java虚拟机栈" class="headerlink" title="2.2、Java虚拟机栈"></a>2.2、Java虚拟机栈</h3><p><strong>Java虚拟机栈是什么？</strong></p>
<blockquote>
<p>java虚拟机栈（Java Virtual Machine Stack），早期也叫java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
</blockquote>
<p>一个栈帧对应着一个方法</p>
<p><img src="/2021/04/24/jvm/image-20200924163935515.png" alt="image-20200924163935515"></p>
<p><strong>生命周期</strong></p>
<p>随着线程的创建而创建，消失而消失。</p>
<p><strong>作用</strong></p>
<p>主管Java程序的运行，他保存方法的局部变量、部分结果、并参与方法的调用和返回。</p>
<p><strong>异常</strong></p>
<blockquote>
<p>Java虚拟机规范允许栈的大小是动态的或者固定不变的</p>
</blockquote>
<ul>
<li>如果线程请求的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机抛出StackOverflowError异常</li>
<li>如果Java虚拟机栈可以动态扩展，在尝试扩展时无法申请足够内存，或创建新的线程时没有足够内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出OutOfMemoryError异常</li>
</ul>
<h4 id="2-2-1、栈的存储单位"><a href="#2-2-1、栈的存储单位" class="headerlink" title="2.2.1、栈的存储单位"></a>2.2.1、栈的存储单位</h4><p>每个线程都有私有的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在的</p>
<p>在线程中正在执行的每个方法都各自对应一个栈帧（Frame）</p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中各种数据信息</p>
<p><strong>注意</strong>：不同线程中所包含的栈帧是不允许存在相互引用的，既不可能 在一个栈帧之中引用另外一个线程的栈帧。</p>
<p><strong>Java方法的两种返回函数的方式</strong></p>
<p>一种是通过return指令进行正常的函数返回，另外一种是抛出异常，不管使用哪种方式，都会导致栈帧被弹出。</p>
<h4 id="2-2-2、栈帧的存储结构"><a href="#2-2-2、栈帧的存储结构" class="headerlink" title="2.2.2、栈帧的存储结构"></a>2.2.2、栈帧的存储结构</h4><p>在栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2021/04/24/jvm/image-20200925164559876.png" alt="image-20200925164559876"></p>
<h5 id="1、局部变量表"><a href="#1、局部变量表" class="headerlink" title="1、局部变量表"></a>1、局部变量表</h5><ul>
<li><p>定义为一个数组，用于存储方法参数和定义在方法体内的局部变量，包括基本数据类型、对象引用、returnAddress类型</p>
</li>
<li><p>局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong>。</p>
</li>
<li><p><strong>局部变量表的大小是在编译期确定下来的。</strong>方法运行期间不会改变局部变量表的大小</p>
</li>
<li><p><strong>局部变量表随着方法栈帧的销毁而销毁</strong></p>
</li>
</ul>
<blockquote>
<p>局部变量表的基本存储单位：<strong>Slot（变量槽</strong>）</p>
</blockquote>
<p>在局部变量表里，32位以内的类型只占用一个Slot（包括returnAddress类型），64位的类型（long或double）占用两个Slot。</p>
<p>==非静态方法栈帧的局部变量表中索引为零的位置上会多一个this（对当前对象的引用）==</p>
<blockquote>
<p>局部变量与成员变量在赋值时的区别</p>
</blockquote>
<p><strong>变量的分类</strong>：按照数据类型分：1、基本数据类型；2、引用数据类型</p>
<pre><code>                   按照在类中声明的位置分：1、成员变量（类变量，实例变量）；2、局部变量
</code></pre>
<p><strong>成员变量</strong>：在使用前，都默认的初始化赋值</p>
<pre><code>    类变量 ：lingking的prepare阶段：给类变量默认赋值 —&gt; inital阶段：给类变量显示赋值；

    实例变量：随着对象的创建，在堆空间中分配实例变量空间，并进行默认赋值
</code></pre>
<p><strong>局部变量</strong>：在使用前，必须显示赋值，否则编译不通过。</p>
<h5 id="2、操作数栈"><a href="#2、操作数栈" class="headerlink" title="2、操作数栈"></a>2、操作数栈</h5><blockquote>
<p>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，及入栈（push）、出栈（pop）。</p>
</blockquote>
<p>主要保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p>
<p><strong>操作数栈的最大深度在编译期就定义好了</strong>，保存在方法的Code属性中，为max_stack的值。</p>
<p>在操作数栈里，32位以内的类型只占用一个栈单位深度，64位的类型（long或double）占用两个栈单位深度。</p>
<p><strong>通过i++和++i理解 操作数栈</strong></p>
<p><img src="/2021/04/24/jvm/code-snapshot.png" alt="code-snapshot"></p>
<h5 id="3、动态链接"><a href="#3、动态链接" class="headerlink" title="3、动态链接"></a>3、动态链接</h5><blockquote>
<p>指向运行时常量池的方法引用</p>
</blockquote>
<p>每个栈帧内部都包含一个指向<strong>运行时常量池</strong>中==该栈帧所属方法的引用==。包含这个引用的目的就是为了就是为了支持当前方法的代码能够实现<strong>动态链接</strong>。</p>
<p><strong>动态链接的作用</strong></p>
<blockquote>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用被保存在class文件的常量池中。</p>
<p>描述一个方法调用另外其他方法时，就是通过常量池中指向方法的符号引用来表示的，<strong>动态链接</strong>就是为了将这些符号引用转换为调用方法的直接引用。</p>
</blockquote>
<h5 id="4、方法的调用"><a href="#4、方法的调用" class="headerlink" title="4、方法的调用"></a>4、方法的调用</h5><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<p>（以下内容理解时想想多态）</p>
<p><strong>静态链接</strong>：</p>
<p>当一个字节码文件被转载进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<p><strong>动态链接</strong></p>
<p>如果被调用的方法在编译期无法被确定下来，即只能在程序运行期将调用方法的符号引用转换为直接引用。由于这种引用转换的过程具备动态性，因此也就被称之为动态链接</p>
<p><strong>方法的绑定机制</strong></p>
<p>对应的方法的绑定机制：<strong>早期绑定和晚期绑定。绑定是一个字段，方法或者类在符号引用被替换为直接引用弄个的过程，这仅仅发生一次</strong></p>
<p><strong>虚方法和非虚方法</strong></p>
<ul>
<li><strong>普通调用指令</strong><ul>
<li><strong>invokestatic</strong>：调用静态方法，解析阶段确定唯一方法版本</li>
<li><strong>invokespecial</strong>：调用<init>方法，私有及父类方法，解析阶段确定唯一方法版本</init></li>
<li><strong>invokevirtual</strong>：调用所有虚方法</li>
<li><strong>invokeinterface</strong>：调用接口方法</li>
</ul>
</li>
<li><strong>动态调用指令</strong><ul>
<li><strong>invokedynamic</strong>：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</strong></p>
<p><strong>方法重写的本质</strong></p>
<p>1、找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</p>
<p>2、如果在类型C中找到与常量池中的描述符和简单名称都符合的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</p>
<p>3、否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</p>
<p>4、如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常</p>
<p><strong>虚方法表</strong></p>
<p>在面向对象的编程中，会频繁的使用动态分派，如果每次动态分派的过程都要重新在类的方法元数据中搜索合适的目标的话就会影响到执行效率。</p>
<p>为了提高性能，JVM采用在类的方法区建立一个<strong>虚方法表</strong>来实现。使用索引表来替代查找。</p>
<p><strong>每个类都有一个虚方法表，表中存放着各种方法的实际入口。</strong></p>
<blockquote>
<p>虚方法表的创建时间</p>
</blockquote>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
<h5 id="5、方法返回地址"><a href="#5、方法返回地址" class="headerlink" title="5、方法返回地址"></a>5、方法返回地址</h5><blockquote>
<p>存放调用该方法的pc寄存器的值。</p>
</blockquote>
<p><strong>方法的结束方式</strong></p>
<p>1、正常执行完成</p>
<p>2、出现未处理的异常，非正常退出</p>
<p>正常退出，调用者的PC寄存器的值作为返回地址，</p>
<p>异常退出，返回地址是通过异常表来确定的，栈帧中不会存储这部分信息</p>
<h5 id="6、附加信息"><a href="#6、附加信息" class="headerlink" title="6、附加信息"></a>6、附加信息</h5><p>栈帧中还允许携带一些与Java虚拟机实现相关的一些附加信息。<strong>不一定有</strong></p>
<h3 id="2-3、本地方法栈"><a href="#2-3、本地方法栈" class="headerlink" title="2.3、本地方法栈"></a>2.3、本地方法栈</h3><blockquote>
<p>Native Method 是一个Java调用非Java代码的接口。</p>
</blockquote>
<ul>
<li>用于支持native方法（指使用java以外的其他语言写的方法）的执行。</li>
<li>如果虚拟机支持该栈，则该栈在线程创建时创建</li>
<li>可固定大小，也可根据计算动态扩展和收缩</li>
<li>可能的异常与Java虚拟机栈一样</li>
</ul>
<p><strong>当某个线程调用一个本地方法时，他就不在受虚拟机限制，和虚拟机有相同的权限</strong></p>
<h3 id="2-4、堆"><a href="#2-4、堆" class="headerlink" title="2.4、堆"></a>2.4、堆</h3><h4 id="2-4-1、概述"><a href="#2-4-1、概述" class="headerlink" title="2.4.1、概述"></a>2.4.1、概述</h4><ul>
<li>一个JVM实例只存在一个堆内存，在JVM启动的时候即被创建，其空间大小也被确定。是JVM管理的最大的一块内存空间<ul>
<li>堆内存大小可调节</li>
</ul>
</li>
<li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上视为连续的</li>
<li>所有线程都共享Java堆，还可以划分线程私有的缓冲区。</li>
<li>《Java虚拟机规范》描述：所有的对象实例以及数组都应当在运行时分配在堆上。<ul>
<li>“几乎”所有的对象实例都在这里分配内存。</li>
</ul>
</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li>
</ul>
<p><strong>栈、堆、方法区的联系</strong></p>
<p><img src="/2021/04/24/jvm/image-20201009172447450.png" alt="image-20201009172447450"></p>
<h4 id="2-4-2、堆内存细分"><a href="#2-4-2、堆内存细分" class="headerlink" title="2.4.2、堆内存细分"></a>2.4.2、堆内存细分</h4><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<ul>
<li>JDK7及之前：堆内存逻辑上分为新生区，养老区，永久区。</li>
<li>JDK8及以后：堆内存逻辑上分为新生区，养老区，元空间。</li>
</ul>
<p><strong>约定</strong>：</p>
<p>新生区&lt;=&gt;新生代&lt;=&gt;年轻代；</p>
<p>养老区&lt;=&gt;老年区&lt;=&gt;老年代</p>
<p>永久区&lt;=&gt;永久代</p>
<p><strong>堆内存结构示意图</strong></p>
<p><img src="/2021/04/24/jvm/image-20201009175551410.png" alt="image-20201009175551410"></p>
<h4 id="2-4-3、设置堆空间大小"><a href="#2-4-3、设置堆空间大小" class="headerlink" title="2.4.3、设置堆空间大小"></a>2.4.3、设置堆空间大小</h4><p>可以通过<code>-Xmx</code>,<code>-Xms</code>来进行设置堆空间大小</p>
<ul>
<li><code>-Xms</code>：用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li>
<li><code>-Xmx</code>：用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li>
</ul>
<p>一旦堆区中的内存大小超过<code>-Xmx</code>所指定的最大内存时，将会抛出OutOfMemoryError异常</p>
<p>通常将 <code>-Xms</code>和<code>Xmx</code>两个参数配置相同的值，其目<strong>的是为了能够在java垃圾回收机制清理完堆区后不需要重新分割计算堆区的大小，从而提高性能</strong></p>
<p>默认情况下，初始内存大小：物理内存大小的 1/64</p>
<pre><code>                 最大内存大小：物理内存大小的 1/4
</code></pre>
<p><strong>查看设置的参数：</strong></p>
<p>方式一：cmd中<code>jps</code>， <code>jstat -gc 进程id</code></p>
<p>方式二：加参数<code>-XX:+PrintGCDeTails</code></p>
<h4 id="2-4-4、新生代与老年代"><a href="#2-4-4、新生代与老年代" class="headerlink" title="2.4.4、新生代与老年代"></a>2.4.4、新生代与老年代</h4><p>存储在JVM中的Java对象分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常快</li>
<li>一类是生命周期非常长的对象</li>
</ul>
<p>堆可细分为年轻代、老年代</p>
<p>年轻代又可以划分为 Eden空间，Survivor0（from区），Survivor1空间（t<strong>o区）</strong></p>
<p><strong>配置新生代与老年代在堆结构的占比</strong></p>
<p>默认 <code>-XX:NewRatio=2</code>,表示新生代占1，老年代占2，新生代占整个堆得1/3</p>
<p>修改为<code>-XX:NewRatio=4</code>,表示新生代占1，老年代占4，新生代占整个堆得1/5</p>
<p><strong>设置新生代中Eden区与Survivor区比例</strong></p>
<p>HotSpot中，新生代的Eden空间和另外两个Survivor空间所占比例，默认为<strong>8:1:1</strong>（官网）</p>
<p>但是事实上通过JVisualVM发现，并不是8:1:1，而是6:1:1；这是因为开启了自适应的内存分配策略。</p>
<p>可以通过<code>-XX:SurvivorRatio=8</code>来调整这个空间比例为8:1:1。</p>
<p>==几乎所有的对象都是从“Eden”区new出来的==，绝大部分的Java对象的销毁都在新生代进行</p>
<p><code>-Xmn</code>：设置新生代的空间大小，一般使用默认值</p>
<h4 id="2-4-5、图解对象分配过程"><a href="#2-4-5、图解对象分配过程" class="headerlink" title="2.4.5、图解对象分配过程"></a>2.4.5、图解对象分配过程</h4><p><img src="/2021/04/24/jvm/image-20201010162742612.png" alt="image-20201010162742612"></p>
<p><strong>总结</strong>：</p>
<ul>
<li>针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to。</li>
<li>关于垃圾回收：频繁在新生代收集，很少在老年代收集，机会不在永久代/元空间收集</li>
</ul>
<p><strong>对象分配的特殊情况</strong></p>
<p><img src="/2021/04/24/jvm/image-20201010172328192.png" alt="image-20201010172328192"></p>
<h4 id="2-4-6、区分Minor-GC-Y-GC-、Major-GC、Full-GC"><a href="#2-4-6、区分Minor-GC-Y-GC-、Major-GC、Full-GC" class="headerlink" title="2.4.6、区分Minor GC(Y GC) 、Major GC、Full GC"></a>2.4.6、区分<strong>Minor GC(Y GC) 、Major GC、Full GC</strong></h4><blockquote>
<p>在JVM进行GC时，并非每一次都会对（新生代、老年代、方法区）进行一起回收，一般回收的都是新生代</p>
</blockquote>
<p>针对HotSpot VM的实现，里面的GC按照回收区域划分为两种类型：<strong>部分收集（Partial GC）</strong>，一种是<strong>整堆收集（Full GC）</strong>；</p>
<p>部分收集：不是对整个Java堆进行垃圾回收</p>
<ul>
<li><strong>新生代（Minor GC / Young GC）收集</strong>：只是新生代的垃圾收集</li>
<li><strong>老年代（Major GC / Old GC）收集</strong>: 只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC 会有单独收集老年代的行为</li>
<li><strong>注意</strong>：很多时候Major GC 和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆收集</li>
</ul>
</li>
<li><strong>混合收集（Mixed GC）</strong>：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
<li><strong>整堆收集（Full GC）</strong>：收集整个Java堆和方法区的垃圾收集。</li>
</ul>
<h4 id="2-4-7、内存分配策略"><a href="#2-4-7、内存分配策略" class="headerlink" title="2.4.7、内存分配策略"></a>2.4.7、内存分配策略</h4><p>针对不同年龄段的对象分配原则：</p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配老年代<ul>
<li>尽量避免程序中出现大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保 :<ul>
<li><code>-XX：HandlePromotionFailure</code></li>
</ul>
</li>
</ul>
<h4 id="2-4-8、对象分配过程-TLAB"><a href="#2-4-8、对象分配过程-TLAB" class="headerlink" title="2.4.8、对象分配过程 TLAB"></a>2.4.8、对象分配过程 TLAB</h4><blockquote>
<p>为什么有TLAB（Thread Local Allocation Buffer）？</p>
</blockquote>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为可避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<blockquote>
<p>什么是<strong>TLAB</strong>？</p>
</blockquote>
<ul>
<li>从内存模型的角度，对Eden区进行划分，<strong>JVM为每个线程分配一个私有缓存区域</strong>，它包含在Eden空间</li>
<li>多线程同时分配时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此可以将这种内存分配方式称之为<strong>快速分配策略</strong></li>
<li>由OpenJDK衍生出来的JVM都提供TLAB。</li>
</ul>
<p><strong>详细说明TLAB</strong></p>
<ul>
<li><p>尽管不是所有的对象实力都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong></p>
</li>
<li><p>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间，默认开启。</p>
</li>
<li><p>默认情况下，**TLAB空间内存非常小，仅占“Eden”区的1%**；</p>
</li>
</ul>
<p><strong>图解</strong></p>
<p><img src="/2021/04/24/jvm/image-20201015202440889.png" alt="image-20201015202440889"></p>
<h4 id="2-4-9、堆空间常用参数"><a href="#2-4-9、堆空间常用参数" class="headerlink" title="2.4.9、堆空间常用参数"></a>2.4.9、堆空间常用参数</h4><ul>
<li><p><code>-Xms</code>：用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></p>
</li>
<li><p><code>-Xmx</code>：用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></p>
</li>
<li><p><code>-Xmn</code>：设置新生代的空间大小，一般使用默认值</p>
</li>
<li><p><code>-XX:+PrintFlagsInitial</code>:查看所有的参数的默认初始值</p>
</li>
<li><p><code>-XX:+PrintFlagsFinal</code>:查看所有的参数的最终值（可能存在修改，不再是初始值）</p>
</li>
<li><p>具体查看某进程中某个参数的指令：</p>
<ul>
<li>步骤1、<code>jps</code>:查看当前运行的java程序进程</li>
<li>步骤2、<code>jinfo -flag 参数名称 进程id</code></li>
</ul>
</li>
<li><p><code>-XX:NewRatio=2</code>：配置老年代新生代在堆结构的占比 （Old：Young = 2:1）</p>
</li>
<li><p><code>-XX:SurvivorRatio=8</code>：配置新生代中Eden区和s1 /s0区的比例</p>
</li>
<li><p><code>-XX:MaxTenuringThreshold</code>:设置新生代垃圾的最大年龄</p>
</li>
<li><p><code>-XX:+PrintGCDetails</code>:输出详细的GC处理日志</p>
</li>
<li><p><code>-XX:+PrintGC</code>或<code>-verbose:gc</code>:打印gc简要信息</p>
</li>
<li><p><code>-XX:HandlePromotionFailure</code>是否设置空间分配担保</p>
</li>
</ul>
<h4 id="2-4-10、逃逸分析"><a href="#2-4-10、逃逸分析" class="headerlink" title="2.4.10、逃逸分析"></a>2.4.10、逃逸分析</h4><blockquote>
<p>1、堆是分配对象的唯一选择吗？</p>
</blockquote>
<pre><code> 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识，但是，有一种特殊情况，就是**经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，就有可能被优化成栈上分配**。这样就无需对上分配内存，也无需进行垃圾回收了。这是常见的**堆外存储技术**。
</code></pre>
<p>  基于OpenJDK深度定制的TaobaoVM、其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GC内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<p><strong>逃逸分析</strong>概述</p>
<blockquote>
<p><strong>逃逸分析</strong>：一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
</blockquote>
<ul>
<li><p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例：作为调用参数传递到其他地方</li>
</ul>
</li>
<li><p>判断是否发生逃逸：</p>
<ul>
<li>就看new的对象实体是否有可能在方法外被调用。</li>
</ul>
</li>
<li><p>在JDK 6u23版本之后，Hotspot中默认就已经开启了逃逸分析。</p>
<ul>
<li>显示开启逃逸分析： <code>-XX:+DoEscapeAnalysis</code></li>
<li>查看逃逸分析的筛结果：<code>-XX:+PrintEscapeAnalysis</code></li>
</ul>
</li>
</ul>
<p><strong>逃逸分析：代码优化</strong>：</p>
<p>使用逃逸分析，编译器可以对代码进行优化</p>
<ul>
<li><p>一、<strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要是指向对象的指针永不逃逸，对象可能是栈分配的候选，而不是堆分配</p>
</li>
<li><p>二、<strong>同步省略</strong>：如果一个对象被发现只能在从一个线程被访问到，那么对于这个对象的操作可以不考虑同步（<strong>锁消除</strong>）</p>
</li>
<li><p>三、<strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</p>
<ul>
<li><strong>标量</strong>：指一个无法分解成更小的数据的数据。Java中的原始数据类型就是标量。</li>
<li><strong>聚合量</strong>：还可以分解的数据</li>
<li><strong>参数</strong>：<code>-XX:+EliminateAllocations</code>,Jdk7之后默认开启。</li>
</ul>
</li>
</ul>
<p>开启逃逸分析之后，使性能得到提升的主要还是标量替换，而不是栈上分配，其实Oracle的jdk并没有实现栈上分配，而是利用标量替换，存储在cpu寄存器中。</p>
<h3 id="2-5、方法区"><a href="#2-5、方法区" class="headerlink" title="2.5、方法区"></a>2.5、方法区</h3><p>从线程共享与否分析内存示意图</p>
<p><img src="/2021/04/24/jvm/image-20201017205822018.png" alt="image-20201017205822018"></p>
<p><strong>堆、栈、方法区的交互关系图解</strong></p>
<p><img src="/2021/04/24/jvm/image-20201017211945612.png" alt="image-20201017211945612"></p>
<h4 id="2-5-1、理解方法区"><a href="#2-5-1、理解方法区" class="headerlink" title="2.5.1、理解方法区"></a>2.5.1、理解方法区</h4><blockquote>
<p>Java虚拟机具有一个在<strong>所有Java虚拟机线程之间共享的<em>方法区域</em></strong>。该方法区域类似于常规语言的编译代码的存储区域，或者类似于操作系统过程中的“文本”段。它存储每个类的结构，例如运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括用于类和实例初始化以及接口初始化的特殊方法。</p>
<p><strong>方法区域是在虚拟机启动时创建的</strong>。尽管方法区域在逻辑上是堆的一部分，但是简单的实现可以选择不进行垃圾回收或压缩。该规范没有规定方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，如果不需要更大的方法区域，则可以缩小。方法区域的内存不必是连续的。</p>
<p><strong>Java虚拟机实现可以为程序员或用户提供对方法区域初始大小的控制，并且在方法区域大小可变的情况下，可以控制最大和最小方法区域大小。</strong></p>
<p>以下异常条件与方法区域相关联：</p>
<ul>
<li>如果无法提供方法区域中的内存来满足分配请求，则Java虚拟机将抛出一个<code>OutOfMemoryError</code>。</li>
</ul>
</blockquote>
<p><strong>方法区在哪里？</strong></p>
<p>在《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区有一个别名叫做“Non-Heap”（非堆），目的就是要和堆分开。</p>
<p>所以，<strong>方法区是一块独立于Java堆的内存空间</strong>。</p>
<p><strong>永久代和元空间</strong></p>
<ul>
<li><p>在JDK8之前方法区的实现是永久代，JDK8之后，完全废弃永久代的概念而用元空间对方法区的进行实现</p>
</li>
<li><p>元空间与永久代的本质区别：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</p>
</li>
</ul>
<h4 id="2-5-2、设置方法区"><a href="#2-5-2、设置方法区" class="headerlink" title="2.5.2、设置方法区"></a>2.5.2、设置方法区</h4><p>设置方法区的大小</p>
<p>在JDK7及以前：</p>
<ul>
<li><p><code>-XX:PermSize</code>：来设置永久代初始分配空间，默认20.75M</p>
</li>
<li><p><code>-XX:MaxPermSize</code>: 来设定永久代最大可分配空间。32位默认是64M，63位默认是82M</p>
</li>
<li><p>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space.</p>
</li>
</ul>
<p>在JDK8及以后：</p>
<ul>
<li><p><code>-XX:MetaspaceSize</code>: 来设置元空间初始分配空间,64位默认是21M</p>
</li>
<li><p><code>-XX:MaxMetaspaceSize</code> : 的值是 -1, 即没有上限限制</p>
</li>
<li><p>如果元空间发生了溢出，也会报OutOfMemoryError：Metaspace</p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC 多次调用。为了避免频繁地GC，建议将</p>
<p><code> -XX:MetaspaceSize</code>设置为一个相对较高的值</p>
</li>
</ul>
<h4 id="2-5-3、内部结构"><a href="#2-5-3、内部结构" class="headerlink" title="2.5.3、内部结构"></a>2.5.3、内部结构</h4><p><img src="/2021/04/24/jvm/image-20201102195002805.png" alt="image-20201102195002805"></p>
<blockquote>
<p><strong>方法区存储什么？</strong></p>
</blockquote>
<p><strong>类型信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码缓存</strong>，域<strong>信息</strong>，<strong>方法信息</strong>等。</p>
<p><img src="/2021/04/24/jvm/image-20201102195228725.png" alt="image-20201102195228725"></p>
<h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><p><img src="/2021/04/24/jvm/image-20201102195611286.png" alt="image-20201102195611286"></p>
<h5 id="域（field）信息"><a href="#域（field）信息" class="headerlink" title="域（field）信息"></a>域（field）信息</h5><p><img src="/2021/04/24/jvm/image-20201102195735794.png" alt="image-20201102195735794"></p>
<h5 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h5><p><img src="/2021/04/24/jvm/image-20201102201925840.png" alt="image-20201102201925840"></p>
<h5 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h5><ul>
<li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li>
<li>类变量被类的所有实例共享</li>
</ul>
<p><strong>全局常量static final</strong></p>
<p>被声明为final的类变量在编译的时候就会被分配</p>
<blockquote>
<p>探究字节码层面类变量（static） 与 全局常量（static final）的区别：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;        <span class="comment">//类变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>; <span class="comment">//全局常量</span></span><br></pre></td></tr></table></figure>

<p>下图是，编译为字节码文件之后：</p>
<p><img src="/2021/04/24/jvm/image-20201102202807906.png" alt="image-20201102202807906"></p>
<p>明显可以发现</p>
<p>  <strong>类变量</strong>在编译期没有赋值，<strong>全局常量</strong>在编译期已被赋值</p>
<h5 id="class文件中常量池"><a href="#class文件中常量池" class="headerlink" title="class文件中常量池"></a>class文件中常量池</h5><p><img src="/2021/04/24/jvm/image-20201109192046550.png" alt="image-20201109192046550"></p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域、和方法的符号引用。</p>
<blockquote>
<p>为什么需要常量池？</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201109192738361.png" alt="image-20201109192738361"></p>
<p>常量池，可以看做是一张表，虚拟机指令根据这种常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p><img src="/2021/04/24/jvm/image-20201109195159168.png" alt="image-20201109195159168"></p>
<h5 id="从字节码文件理解方法区"><a href="#从字节码文件理解方法区" class="headerlink" title="从字节码文件理解方法区"></a>从字节码文件理解方法区</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println( a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后的字节码文件</p>
<p><img src="/2021/04/24/jvm/image-20201109212758546.png" alt="image-20201109212758546"></p>
<p><img src="/2021/04/24/jvm/image-20201109213330064.png" alt="image-20201109213330064"></p>
<p><img src="/2021/04/24/jvm/image-20201109214224370.png" alt="image-20201109214224370"></p>
<p>main方法的执行过程</p>
<p><img src="/2021/04/24/jvm/image-20201109202543712.png" alt="image-20201109202543712"></p>
<h4 id="方法区的演变"><a href="#方法区的演变" class="headerlink" title="方法区的演变"></a>方法区的演变</h4><p><img src="/2021/04/24/jvm/image-20201110125342683.png" alt="image-20201110125342683"></p>
<p><img src="/2021/04/24/jvm/image-20201110125650108.png" alt="image-20201110125650108"></p>
<blockquote>
<p>永久代为什么要被元空间替换？</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201110130516276.png" alt="image-20201110130516276"></p>
<blockquote>
<p>方法区的垃圾回收</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201110130730241.png" alt="image-20201110130730241"></p>
<blockquote>
<p>Stirng Table为什么要调整？</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201110132130250.png" alt="image-20201110132130250"></p>
<h3 id="2-6、总结"><a href="#2-6、总结" class="headerlink" title="2.6、总结"></a>2.6、总结</h3><p><img src="/2021/04/24/jvm/image-20201110142424421.png" alt="image-20201110142424421"></p>
<h3 id="2-7、常见面试题"><a href="#2-7、常见面试题" class="headerlink" title="2.7、常见面试题"></a>2.7、常见面试题</h3><p><img src="/2021/04/24/jvm/image-20201110143208836.png" alt="image-20201110143208836"></p>
<p><img src="/2021/04/24/jvm/image-20201110143113660.png" alt="image-20201110143113660"></p>
<h2 id="3、对象的实例化、内存布局与访问定位"><a href="#3、对象的实例化、内存布局与访问定位" class="headerlink" title="3、对象的实例化、内存布局与访问定位"></a>3、对象的实例化、内存布局与访问定位</h2><h3 id="3-1、对象的实例化"><a href="#3-1、对象的实例化" class="headerlink" title="3.1、对象的实例化"></a>3.1、对象的实例化</h3><blockquote>
<p>创建对象的方式</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201110145233781.png" alt="image-20201110145233781"></p>
<blockquote>
<p>创建对象的步骤</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201110154456278.png" alt="image-20201110154456278"></p>
<p><strong>详细步骤</strong></p>
<p>1、判断对象对应的类是否加载、链接、初始化</p>
<p><img src="/2021/04/24/jvm/image-20201110154617842.png" alt="image-20201110154617842"></p>
<p>2、为对象分配内存</p>
<p><img src="/2021/04/24/jvm/image-20201110154737061.png" alt="image-20201110154737061"></p>
<ul>
<li><p>如果内存规整</p>
<ul>
<li><p>指针碰撞</p>
<p><img src="/2021/04/24/jvm/image-20201110155055349.png" alt="image-20201110155055349"></p>
</li>
</ul>
</li>
<li><p>如果内存不规整</p>
<ul>
<li>虚拟机需要维护一个列表</li>
<li>空闲列表分配<img src="/2021/04/24/jvm/image-20201110155319261.png" alt="image-20201110155319261"></li>
</ul>
</li>
<li><p>说明</p>
<p><img src="/2021/04/24/jvm/image-20201110155507948.png" alt="image-20201110155507948"></p>
</li>
</ul>
<p>3、处理并发安全问题</p>
<ul>
<li>采用CAS失败重试、区域加锁保证更新的原子性</li>
<li>每个线程预先分配一块TLAB - 通过 <code>-XX:+/-UseTLAB</code>参数来设定</li>
</ul>
<p>4、初始化分配到的空间</p>
<ul>
<li>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</li>
</ul>
<p>5、设置对象的对象头</p>
<p><img src="/2021/04/24/jvm/image-20201110160331301.png" alt="image-20201110160331301"></p>
<p>6、执行init方法进行初始化</p>
<p><img src="/2021/04/24/jvm/image-20201110160218483.png" alt="image-20201110160218483"></p>
<h3 id="3-2、对象的内存布局"><a href="#3-2、对象的内存布局" class="headerlink" title="3.2、对象的内存布局"></a>3.2、对象的内存布局</h3><p><img src="/2021/04/24/jvm/image-20201111202332794.png" alt="image-20201111202332794"></p>
<p><strong>小结</strong>：图示所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Customer cust = <span class="keyword">new</span> Customer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/04/24/jvm/image-20201111203941261.png" alt="image-20201111203941261"></p>
<h3 id="3-3、对象的访问定位"><a href="#3-3、对象的访问定位" class="headerlink" title="3.3、对象的访问定位"></a>3.3、对象的访问定位</h3><p><img src="/2021/04/24/jvm/image-20201111210312197.png" alt="image-20201111210312197"></p>
<blockquote>
<p>对象访问方式（两种）：</p>
</blockquote>
<p><strong>1、句柄访问</strong></p>
<p><img src="/2021/04/24/jvm/image-20201111210549329.png" alt="image-20201111210549329"></p>
<p>好处：</p>
<p><img src="/2021/04/24/jvm/image-20201111211529894.png" alt="image-20201111211529894"></p>
<p>坏处：需要在对空间额外申请内存，速度慢</p>
<p><strong>2、直接指针（hotspot采用）</strong></p>
<p><img src="/2021/04/24/jvm/image-20201111211707815.png" alt="image-20201111211707815"></p>
<p>好处：不用再额外申请内存，速度快</p>
<p>坏处：不稳定，对象移动时，需要改变reference类型的值</p>
<h3 id="3-4、直接内存"><a href="#3-4、直接内存" class="headerlink" title="3.4、直接内存"></a>3.4、直接内存</h3><ul>
<li><p>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p>
</li>
<li><p>直接内存是在Java堆外的、直接向系统申请的内存空间</p>
</li>
<li><p>来源于NIO，通过存在堆中的DirectByteBuffer操作native内存</p>
</li>
<li><p>通常，访问直接内存的速度会优于Java堆。即读写性能高</p>
<ul>
<li>因此出于性能考虑，读写频率频繁的场合可能会考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。</li>
</ul>
</li>
<li><p>也可能导致OutOfMemoryError异常</p>
</li>
<li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li><p>直接内存大小可通过MaxDirectMemorySize设置</p>
</li>
<li><p>如果不指定，默认与堆的最大值-Xmx参数值一致。</p>
</li>
</ul>
<p>简单理解：</p>
<p>Java process memory = java heap + native memory</p>
<p><strong>直接缓冲区与非直接缓冲区的区别</strong>：</p>
<p>（即io/nio的区别）</p>
<p>图解  io</p>
<p><img src="/2021/04/24/jvm/image-20201125132932716.png" alt="image-20201125132932716"></p>
<p>nio</p>
<p><img src="/2021/04/24/jvm/image-20201125133354817.png" alt="image-20201125133354817"></p>
<blockquote>
<p>通过案例 测试程序使用本地直接内存</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看直接内存的占用与释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接分配本地内存</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存分配完毕,请指示&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>运行结果：</strong></p>
<p>运行之前本地内存使用情况：</p>
<p><img src="/2021/04/24/jvm/image-20201125132227362.png" alt="image-20201125132227362"></p>
<p>分配直接内存之后本地内存使用情况：</p>
<p><img src="/2021/04/24/jvm/image-20201125132453908.png" alt="image-20201125132453908"></p>
<p>内存释放之后，本地内存使用情况：</p>
<p><img src="/2021/04/24/jvm/image-20201125132712335.png" alt="image-20201125132712335"></p>
<h2 id="4、执行引擎"><a href="#4、执行引擎" class="headerlink" title="4、执行引擎"></a>4、执行引擎</h2><h3 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h3><p>执行引擎是Java虚拟机核心的组成部分之一</p>
<p><img src="/2021/04/24/jvm/image-20201126201652048.png" alt="image-20201126201652048"></p>
<p>JVM的主要任务是负责<strong>装载字节码到其内部</strong>。</p>
<p>字节码并不能直接运行在操作系统之上，因为字节码指令并不是等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他的辅助信息。</p>
<p>一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令。</strong></p>
<h3 id="4-2、工作过程"><a href="#4-2、工作过程" class="headerlink" title="4.2、工作过程"></a>4.2、工作过程</h3><p><img src="/2021/04/24/jvm/image-20201126203120106.png" alt="image-20201126203120106"></p>
<p><strong>Java代码编译/执行过程</strong></p>
<p><img src="/2021/04/24/jvm/image-20201126203902325.png" alt="image-20201126203902325"></p>
<p>大部分程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都要</p>
<p>经过上图中的各个步骤。</p>
<p>java代码编译流程图</p>
<p><img src="/2021/04/24/jvm/image-20201126204306772.png" alt="image-20201126204306772"></p>
<p>Java字节码执行流程图</p>
<p><img src="/2021/04/24/jvm/image-20201126204451262.png" alt="image-20201126204451262"></p>
<h3 id="4-3、机器码、指令、汇编、高级语言理解"><a href="#4-3、机器码、指令、汇编、高级语言理解" class="headerlink" title="4.3、机器码、指令、汇编、高级语言理解"></a>4.3、机器码、指令、汇编、高级语言理解</h3><h4 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h4><p><img src="/2021/04/24/jvm/image-20201126210712686.png" alt="image-20201126210712686"></p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><img src="/2021/04/24/jvm/image-20201126210905356.png" alt="image-20201126210905356"></p>
<h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><p><img src="/2021/04/24/jvm/image-20201126211044255.png" alt="image-20201126211044255"></p>
<h4 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h4><p><img src="/2021/04/24/jvm/image-20201126211311512.png" alt="image-20201126211311512"></p>
<p><strong>对应关系</strong></p>
<p><img src="/2021/04/24/jvm/image-20201126211339671.png" alt="image-20201126211339671"></p>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p><img src="/2021/04/24/jvm/image-20201126211736601.png" alt="image-20201126211736601"></p>
<h3 id="4-4、解释器"><a href="#4-4、解释器" class="headerlink" title="4.4、解释器"></a>4.4、解释器</h3><p><strong>什么是解释器？什么是JIT编译器？</strong></p>
<p><img src="/2021/04/24/jvm/image-20201126204831674.png" alt="image-20201126204831674"></p>
<p><strong>为什么Java是半编译半解释型语言？</strong></p>
<p><img src="/2021/04/24/jvm/image-20201126205239135.png" alt="image-20201126205239135"></p>
<p>图解解释器和JIT编译器</p>
<p><img src="/2021/04/24/jvm/image-20201126210128587.png" alt="image-20201126210128587"></p>
<p><strong>解释器工作机制</strong></p>
<ul>
<li>将字节码文件中内容“翻译”为对应平台的本地机器指令执行</li>
<li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作 。</li>
</ul>
<p><strong>解释器分类</strong></p>
<blockquote>
<p>字节码解释器，模板解释器</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201127172845584.png" alt="image-20201127172845584"></p>
<p><strong>基于解释器执行已经沦落为低效的代名词</strong></p>
<h3 id="4-5、JIT编译器"><a href="#4-5、JIT编译器" class="headerlink" title="4.5、JIT编译器"></a>4.5、JIT编译器</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>虚拟机将源代码直接编译为和本地机器相关的机器语言。</p>
</blockquote>
<p>为了解决 解释器执行低效的问题，JVM平台支持一种即时编译的技术。</p>
<p>==目的==是<strong>为了避免函数被解释执行，而是将整个函数体编译成为机器码，。每次函数执行时，只执行编译后的机器码即可</strong>。</p>
<hr>
<p><strong>概念解释</strong></p>
<p><img src="/2021/04/24/jvm/image-20201127213035609.png" alt="image-20201127213035609"></p>
<p><strong>编译器：</strong></p>
<p><img src="/2021/04/24/jvm/image-20201127213057784.png" alt="image-20201127213057784"></p>
<p><strong>HotSpot JVM的执行方式</strong></p>
<p><img src="/2021/04/24/jvm/image-20201127210329568.png" alt="image-20201127210329568"></p>
<h4 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h4><p>一个被多次调用的方法，或者是一个方法内部循环次数较多循环体都可称为“<strong>热点代码</strong>”。都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也称为<strong>栈上替换</strong>。简称<strong>OSR（On Stack Replacement ）编译</strong>。</p>
<p><strong>热点探测功能</strong></p>
<p>用来探测那些代码为热点代码。</p>
<p>HotSpot VM采用 热点探测方式是 <strong>基于计数器的热点探测</strong>。</p>
<p><img src="/2021/04/24/jvm/image-20201127214153352.png" alt="image-20201127214153352"></p>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>用于统计方法被调用的次数，它的默认阈值在Client模式下是1500下，在Server模式下是10000次，超过这个阈值，就会出发JIT编译。</p>
<p>这个阈值可以通过虚拟机参数“-XX:CompileThreshold”来设定。</p>
<p><strong>具体描述</strong></p>
<p>当一个方法被调用时，会先检查方法是否存在JIT编译版本，优先执行编译后的代码。如果不存在被JIT编译过的版本，则此方法的调用计数器+1.然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值，如果超过将向即时编译器提交一个该方法的代码编译请求。</p>
<p><strong>图解</strong></p>
<p><img src="/2021/04/24/jvm/image-20201130164354069.png" alt="image-20201130164354069"></p>
<p><strong>热度衰减</strong></p>
<p><img src="/2021/04/24/jvm/image-20201130164934767.png" alt="image-20201130164934767"></p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p><img src="/2021/04/24/jvm/image-20201130165652074.png" alt="image-20201130165652074"></p>
<h2 id="5、StringTable"><a href="#5、StringTable" class="headerlink" title="5、StringTable"></a>5、StringTable</h2><h3 id="5-1、String的基本特性"><a href="#5-1、String的基本特性" class="headerlink" title="5.1、String的基本特性"></a>5.1、String的基本特性</h3><ul>
<li>String ：字符串，使用“”引起来表示。</li>
<li>String声明为final的，不可被继承。</li>
<li>String<ul>
<li>实现了Serializable接口：表示字符串是支持序列化的。</li>
<li>实现了Comparable接口：表示string可以比较大小。</li>
</ul>
</li>
<li>String在Jdk8以前内部定义了final char[] value 用于存储字符串数据。jdk9时改为了byte[] value .</li>
</ul>
<p><img src="/2021/04/24/jvm/image-20201130195351926.png" alt="image-20201130195351926"></p>
<p><img src="/2021/04/24/jvm/image-20201130202642140.png" alt="image-20201130202642140"></p>
<h3 id="5-2、String的内存分配"><a href="#5-2、String的内存分配" class="headerlink" title="5.2、String的内存分配"></a>5.2、String的内存分配</h3><p><img src="/2021/04/24/jvm/image-20201202130932576.png" alt="image-20201202130932576"></p>
<p><img src="/2021/04/24/jvm/image-20201110125342683.png" alt="image-20201110125342683"></p>
<p><img src="/2021/04/24/jvm/image-20201110125650108.png" alt="image-20201110125650108"></p>
<p><img src="/2021/04/24/jvm/image-20201202133915267.png" alt="image-20201202133915267"></p>
<p><img src="/2021/04/24/jvm/image-20201202140116916.png" alt="image-20201202140116916"></p>
<h3 id="5-3、String的拼接操作"><a href="#5-3、String的拼接操作" class="headerlink" title="5.3、String的拼接操作"></a>5.3、String的拼接操作</h3><p>1、常量与常量的拼接结果在常量池，原理：编译期优化</p>
<p>2、常量池不会存在相同内存的常量</p>
<p>3、只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</p>
<p>4、如果拼接的结果调用intern( )方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</p>
<p><strong>案例1、</strong></p>
<p>常量与常量拼接</p>
<p><img src="/2021/04/24/jvm/image-20201202141122888.png" alt="image-20201202141122888"></p>
<p><strong>案例2、</strong></p>
<p>只要其中有一个为变量，结果就在堆中</p>
<p><img src="/2021/04/24/jvm/image-20201202142227675.png" alt="image-20201202142227675"></p>
<p><strong>案例3、</strong></p>
<p>变量与变量相加，底层原理</p>
<p><img src="/2021/04/24/jvm/image-20201202201858934.png" alt="image-20201202201858934"></p>
<p><strong>案例4、</strong></p>
<p>当两个被标记final关键字的字符串相加时</p>
<p><img src="/2021/04/24/jvm/image-20201202201040221.png" alt="image-20201202201040221"></p>
<blockquote>
<p>String 拼接 + 和 append方法效率对比</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201202204219705.png" alt="image-20201202204219705"></p>
<p>==结论：==通过StringBuilder的append（）方式添加字符串的效率要<strong>远高于</strong>使用String的+拼接方式。</p>
<p>==详情==</p>
<p>1、StringBuilder的append（）方式：自始至终只创建一个StringBuilder对象</p>
<p>  String的+字符串拼接方式：每次相加都会创建新的StringBuilder对象</p>
<p>2、String的+字符串拼接方式：内存中由于创建了较多的StringBuilder对象和String对象，内存占用更大；如果进行GC，需要花费更多的额外时间。</p>
<p>==改进优化==</p>
<p>在实际开发中，如果基本确定需要添加的字符串长度不高于某个限定值的情况下，建议使用<code>StringBuilder s= new StringBuilder(hightLevel) ; </code>创建指定大小的StringBuilder，相当于创建一个 <code>new  char[hightLevel]</code></p>
<h3 id="5-4、intern-方法"><a href="#5-4、intern-方法" class="headerlink" title="5.4、intern( ) 方法"></a>5.4、intern( ) 方法</h3><p><img src="/2021/04/24/jvm/image-20201203132929128.png" alt="image-20201203132929128"></p>
<blockquote>
<p>关于intern（）的面试题</p>
</blockquote>
<p>面试题一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String ab = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">//会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line">String ab = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>); <span class="comment">//思考：会创建几个？</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>答案 ： 2 、6  （JDK 8）</p>
<p>解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：</span></span><br><span class="line"><span class="comment">     * String ab = new String(&quot;ab&quot;); 会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment">     *  0 new #2 &lt;java/lang/String&gt;</span></span><br><span class="line"><span class="comment">     *  3 dup</span></span><br><span class="line"><span class="comment">     *  4 ldc #3 &lt;ab&gt;</span></span><br><span class="line"><span class="comment">     *  6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span></span><br><span class="line"><span class="comment">     *  9 astore_1</span></span><br><span class="line"><span class="comment">     * 10 return</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  对象一：new 关键字在堆空间创建的String类型的变量</span></span><br><span class="line"><span class="comment">     *  对象二：字符串常量池中的对象&quot;ab&quot;. 字节码指令：ldc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  *思考：String ab = new String(&quot;a&quot;)+new String(&quot;b&quot;); 会创建几个？</span></span><br><span class="line"><span class="comment">    * 0 new #2 &lt;java/lang/StringBuilder&gt;</span></span><br><span class="line"><span class="comment">    * 3 dup</span></span><br><span class="line"><span class="comment">    * 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span></span><br><span class="line"><span class="comment">    * 7 new #4 &lt;java/lang/String&gt;</span></span><br><span class="line"><span class="comment">    * 10 dup</span></span><br><span class="line"><span class="comment">    * 11 ldc #5 &lt;a&gt;</span></span><br><span class="line"><span class="comment">    * 13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span></span><br><span class="line"><span class="comment">    * 16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span></span><br><span class="line"><span class="comment">    * 19 new #4 &lt;java/lang/String&gt;</span></span><br><span class="line"><span class="comment">    * 22 dup</span></span><br><span class="line"><span class="comment">    * 23 ldc #8 &lt;b&gt;</span></span><br><span class="line"><span class="comment">    * 25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span></span><br><span class="line"><span class="comment">    * 28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span></span><br><span class="line"><span class="comment">    * 31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span></span><br><span class="line"><span class="comment">    * 34 astore_1</span></span><br><span class="line"><span class="comment">    * 35 return</span></span><br><span class="line"><span class="comment">    *  对象一：new StringBuilder()</span></span><br><span class="line"><span class="comment">    *  对象二：new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">    *  对象三：常量池中的 &quot;a&quot;</span></span><br><span class="line"><span class="comment">    *  对象四：new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">    *  对象五：常量池中的 &quot;b&quot;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  深入剖析： StringBuilder的toString()方法：</span></span><br><span class="line"><span class="comment">    *      对象六： new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">    *         强调一下：toString()的调用，在字符串常量池中，没有生成 “ab”</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>



<p>面试题二： intern()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String s1 =  <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       s1.intern();</span><br><span class="line">       String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">       System.out.println(s1==s2); </span><br><span class="line">    </span><br><span class="line">       String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       s3.intern();</span><br><span class="line">       String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">       System.out.println(s3==s4);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>答案：</p>
<p>JDK6：fasle    fasle</p>
<p>JDK7：fasle    true</p>
<p>JDK8：fasle    true</p>
<p>题解：</p>
<p>字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> 4 ldc #3 &lt;1&gt;</span><br><span class="line"> 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #5 &lt;java/lang/String.intern&gt;</span><br><span class="line"><span class="number">14</span> pop</span><br><span class="line">15 ldc #3 &lt;1&gt;</span><br><span class="line"><span class="number">17</span> astore_2</span><br><span class="line">18 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">21</span> aload_1</span><br><span class="line"><span class="number">22</span> aload_2</span><br><span class="line"><span class="number">23</span> if_acmpne <span class="number">30</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">26</span> iconst_1</span><br><span class="line"><span class="number">27</span> goto <span class="number">31</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">30</span> iconst_0</span><br><span class="line">31 invokevirtual #7 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">34 new #8 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">37</span> dup</span><br><span class="line">38 invokespecial #9 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">41 new #2 &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">44</span> dup</span><br><span class="line">45 ldc #3 &lt;1&gt;</span><br><span class="line">47 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">50 invokevirtual #10 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">53 new #2 &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">56</span> dup</span><br><span class="line">57 ldc #3 &lt;1&gt;</span><br><span class="line">59 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">62 invokevirtual #10 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">65 invokevirtual #11 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">68</span> astore_3</span><br><span class="line"><span class="number">69</span> aload_3</span><br><span class="line">70 invokevirtual #5 &lt;java/lang/String.intern&gt;</span><br><span class="line"><span class="number">73</span> pop</span><br><span class="line">74 ldc #12 &lt;11&gt;</span><br><span class="line"><span class="number">76</span> astore <span class="number">4</span></span><br><span class="line">78 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">81</span> aload_3</span><br><span class="line"><span class="number">82</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">84</span> if_acmpne <span class="number">91</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">87</span> iconst_1</span><br><span class="line"><span class="number">88</span> goto <span class="number">92</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">91</span> iconst_0</span><br><span class="line">92 invokevirtual #7 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">95</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 =  <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//调用此方法之前，字符串常量池中已经存在了 “1”  原因可看String的构造器，和字节码</span></span><br><span class="line">        s1.intern();</span><br><span class="line">        String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s1==s2);  <span class="comment">//jdk6:false  jdk7/8:false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3变量记录地址为：new String(value, 0, count);</span></span><br><span class="line">        <span class="comment">// 此时并不会在字符串常量池中创建 &quot;11&quot;</span></span><br><span class="line">        <span class="comment">// 原因：</span></span><br><span class="line">        <span class="comment">// new String(&quot;11&quot;);会创建两个对象，其中一个是在常量池中创建一个“11”，</span></span><br><span class="line">        <span class="comment">//      是因为String的构造方法的参数是一个字符串（“11”）;</span></span><br><span class="line">        <span class="comment">// new String(value, 0, count) 中的value是一个 char[] ,并不会在</span></span><br><span class="line">        <span class="comment">//      字符串常量池中创建一个“11”，</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s3.intern(); <span class="comment">//  在字符串常量池中生成“11”。</span></span><br><span class="line">                     <span class="comment">// 如何理解：</span></span><br><span class="line">                     <span class="comment">//     JDK6：创建一个新的对象“11”，在字符串常量池中也创建一个 “11”</span></span><br><span class="line">                     <span class="comment">//     JDK7: 此时常量池中并没有创建常量“11”，而是创建一个指向堆空间中new String对象时创建的“11”的地址</span></span><br><span class="line">                     <span class="comment">//     JDK8: 同JDK7</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>; <span class="comment">//s4变量记录的地址：使用的是上一行代码执行时，在常量池中生成的“11”的地址</span></span><br><span class="line">        System.out.println(s3==s4);  <span class="comment">//jdk6 false   jdk7/8  true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/24/jvm/image-20201203205300528.png" alt="image-20201203205300528"></p>
<p>intern（）方法（红色部分可以解释 JDK8  在常量池中创建指向new String（“11”）对象的引用）</p>
<p><img src="/2021/04/24/jvm/image-20201203205959175.png" alt="image-20201203205959175"></p>
<p>题解总结：</p>
<p><img src="/2021/04/24/jvm/image-20201203210734565.png" alt="image-20201203210734565"></p>
<p><img src="/2021/04/24/jvm/image-20201203211529764.png" alt="image-20201203211529764"></p>
<h3 id="5-5、G1的String去重操作"><a href="#5-5、G1的String去重操作" class="headerlink" title="5.5、G1的String去重操作"></a>5.5、G1的String去重操作</h3><p><img src="/2021/04/24/jvm/image-20201204132441989.png" alt="image-20201204132441989"></p>
<p>实现</p>
<p><img src="/2021/04/24/jvm/image-20201204132904615.png" alt="image-20201204132904615"></p>
<p>命令行选项</p>
<p><img src="/2021/04/24/jvm/image-20201204132959999.png" alt="image-20201204132959999"></p>
<h2 id="6、垃圾收集"><a href="#6、垃圾收集" class="headerlink" title="6、垃圾收集"></a>6、垃圾收集</h2><h3 id="6-1、什么是垃圾？"><a href="#6-1、什么是垃圾？" class="headerlink" title="6.1、什么是垃圾？"></a>6.1、什么是垃圾？</h3><p><strong>垃圾收集</strong>：并不是Java语言的伴生产物， 1960年，第一门使用内存动态分配和垃圾收集技术的语言Lisp诞生</p>
<p><strong>垃圾收集的三个问题：</strong></p>
<ul>
<li>那些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p><strong>什么是垃圾？</strong></p>
<p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是被回收的垃圾</p>
<p>如果不能对内存中的垃圾进行及时清理，这些垃圾对象就会一直存在至应用程序结束，被保留的空间无法被其他对象使用，就可能<strong>导致内存溢出。</strong></p>
<h3 id="6-2、大厂面试题"><a href="#6-2、大厂面试题" class="headerlink" title="6.2、大厂面试题"></a>6.2、大厂面试题</h3><p><img src="/2021/04/24/jvm/image-20201204135413684.png" alt="image-20201204135413684"></p>
<p><img src="/2021/04/24/jvm/image-20201204135510965.png" alt="image-20201204135510965"></p>
<h3 id="6-3、垃圾回收机制"><a href="#6-3、垃圾回收机制" class="headerlink" title="6.3、垃圾回收机制"></a>6.3、垃圾回收机制</h3><ul>
<li>自动内存管理 ，<strong>降低内存泄露和内存溢出的危险</strong></li>
<li>自动内存管理，可以让程序员不用专注于内存的申请与释放，更专注于业务开发</li>
</ul>
<p>垃圾回收器可以针对年轻代回收，也可以针对老年代回收，甚至是全堆或方法区的回收。（<strong>Java堆是垃圾收集器的工作重点</strong>）</p>
<p><strong>收集次数</strong></p>
<ul>
<li>频繁收集Young区</li>
<li>较少收集old区</li>
<li>基本不动Perm区（元空间）</li>
</ul>
<h3 id="6-4、垃圾回收算法"><a href="#6-4、垃圾回收算法" class="headerlink" title="6.4、垃圾回收算法"></a>6.4、垃圾回收算法</h3><p><strong>垃圾标记阶段</strong>：对象存活判断</p>
<ul>
<li><p><strong>在GC执行垃圾回收之前，需要先区分内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有标记已经死亡的对象，GC才会在执行垃圾回收时，释放掉其占用的内存。因此该阶段称为<strong>垃圾标记阶段</strong></p>
</li>
<li><p>在JVM中，当一个对象不再被任何存活对象继续引用时，就是代表已经死亡。</p>
</li>
<li><p>判断对象存活的两种方式：<strong>引用计数算法</strong>、<strong>可达性分析算法</strong></p>
</li>
</ul>
<p><strong>垃圾清除阶段</strong>：清除死亡对象</p>
<ul>
<li>当成功区分出内存中存活和死亡对象后，GC接下来的任务就是垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存为新对象分配内存。</li>
<li>常用的三种垃圾收集算法<ul>
<li>标记-清除算法（Mark-Sweep）</li>
<li>复制算法（Copying）</li>
<li>标记-压缩（整理）算法（Mark-Compact）</li>
</ul>
</li>
</ul>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>垃圾标记阶段的算法，对每个对象保存一个整型的引用计数器属性，<strong>用于记录对象被引用的情况。</strong></p>
<p><strong>解释：</strong></p>
<p>有一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0，即表示对象A不可能被再使用，可进行回收</p>
<p><strong>优点</strong></p>
<p>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p><strong>缺点</strong></p>
<ul>
<li>需要单独的字段存储计数器，<strong>增加了存储空间的开销</strong></li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，<strong>增加了时间开销</strong></li>
<li><strong>无法处理循环引用。</strong></li>
</ul>
<p><strong>循环引用</strong></p>
<p><img src="/2021/04/24/jvm/image-20201208100034333.png" alt="image-20201208100034333"></p>
<p>Java没有使用引用计数，正是因为引用计数算法<strong>无法处理循环引用</strong></p>
<p>Python用了引用计数算法</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>根搜索算法、追踪性垃圾收集</p>
</blockquote>
<p>相对于引用计数算法，可达性分析算法不仅同样具备实现简单和执行高效等特点，还解决了引用计数算法中循环引用的问题，防止内存泄漏的发生</p>
<p>java 和  c# 使用 可达性分析算法</p>
<p>“GC Roots”根集合就是一组必须活跃的引用</p>
<p><strong>理解：</strong></p>
<p><img src="/2021/04/24/jvm/image-20201208105811408.png" alt="image-20201208105811408"></p>
<p><strong>图解：</strong></p>
<p><img src="/2021/04/24/jvm/image-20201208105657120.png" alt="image-20201208105657120"></p>
<p><strong>Java语言中，GC Roots 包括以下几类元素</strong>（重点）</p>
<p><img src="/2021/04/24/jvm/image-20201208110456556.png" alt="image-20201208110456556"></p>
<p><img src="/2021/04/24/jvm/image-20201208110634652.png" alt="image-20201208110634652"></p>
<p><strong>技巧</strong>：由于Root 采用栈方式存放变量和指针，所以如果一个指针，他保存了堆内存里面的对象，但自己又不存放在堆内存中，那它就是一个Root</p>
<p><strong>注意：</strong><br><img src="/2021/04/24/jvm/image-20201208111121313.png" alt="image-20201208111121313"></p>
<h5 id="finalization机制"><a href="#finalization机制" class="headerlink" title="finalization机制"></a>finalization机制</h5><blockquote>
<p>对象终止（finalization）机制 允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong></p>
</blockquote>
<p>  当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，先调用这个对象的finalize()方法。</p>
<p>  finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接</p>
<p><img src="/2021/04/24/jvm/image-20201208133618776.png" alt="image-20201208133618776"></p>
<p><strong>工作过程</strong></p>
<p>判断对象是否可以回收，至少经历两次标记过程</p>
<p><img src="/2021/04/24/jvm/image-20201208134213579.png" alt="image-20201208134213579"></p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p><strong>背景</strong></p>
<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。</p>
<p><strong>执行过程</strong></p>
<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为Stop The World），然后进行两项工作，第一项是标记，第二项则是清除。</p>
<ul>
<li><strong>标记</strong>：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li>
<li><strong>清除</strong>：Collector对堆内内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ul>
<p><strong>图解</strong></p>
<p><img src="/2021/04/24/jvm/image-20201209202851516.png" alt="image-20201209202851516"></p>
<p><strong>缺点</strong></p>
<ul>
<li><p>效率不算高</p>
</li>
<li><p>在进行GC的时候，需要停止整个应用程序，导致用户体验差</p>
</li>
<li><p>这种方式清理出来的内存是不连续的，产生内存碎片，需要维护一个空闲列表；</p>
</li>
</ul>
<p><strong>==注意：==什么是清除？</strong></p>
<p><strong>这里的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里</strong>。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。<strong>下次用的时候直接覆盖</strong></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><strong>背景</strong></p>
<blockquote>
<p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA Lisp Garbage Collector Algorithm Using Serial Secondary Storage”。M.L.Minsky在论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功的引入到了Lisp语言的一个实现版本中。</p>
</blockquote>
<p><strong>核心思想</strong></p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><strong>图解</strong></p>
<p><img src="/2021/04/24/jvm/image-20201209204809938.png" alt="image-20201209204809938"></p>
<p><strong>优点</strong></p>
<ul>
<li>没有标记，清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”空间</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>需要两倍的内存空间</p>
</li>
<li><p>对于G1这种分拆成大量region的GC，复制而不是移动，意味着维护region之间对象引用关系，不管是内存占用或者时间开销都不会少</p>
</li>
<li><p>如果系统中垃圾对象比较多，复制算法需要复制的存活对象数量并不会太大或者非常低，但是如果来及对象比较少，那复制存活对象代价就太大了</p>
</li>
</ul>
<p><strong>应用场景</strong></p>
<p><img src="/2021/04/24/jvm/image-20201209210600025.png" alt="image-20201209210600025"></p>
<h4 id="标记整理-压缩算法"><a href="#标记整理-压缩算法" class="headerlink" title="标记整理\压缩算法"></a>标记整理\压缩算法</h4><p><strong>背景</strong></p>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象多，复制成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其它的算法</strong>。</p>
<p>标记-清除算法确实可以应用在老年代中，但是，该算法不仅执行效率低下，而且在执行完内存收集后，还会产生内存碎片，所以JVM的设计者需要在此基础上进行改进。<strong>标记-压缩（Mark Compact）算法</strong>由此诞生。</p>
<p>1970年前后，G.L.Steel、C.J.Chene和D.S.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<p><strong>执行过程</strong></p>
<ul>
<li>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用的对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放</li>
<li>然后，清理边界外所有的空间</li>
</ul>
<p><strong>图解</strong></p>
<p><img src="/2021/04/24/jvm/image-20201209211700592.png" alt="image-20201209211700592"></p>
<blockquote>
<p><strong>标记-压缩算法 与标记-清除算法 差异</strong></p>
</blockquote>
<ul>
<li><p><strong>标记-压缩算法</strong> 最终效果 相当于<strong>标记-清除算法</strong>执行之后再进行一次内存碎片整理，因此可以成为 <strong>标记-清除-压缩算法</strong></p>
</li>
<li><p>本质差异在于<strong>标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的</strong>，是否移动回收后的存活对象是优缺点并存的风险决策</p>
</li>
<li><p>标记整理算法：<strong>标记存活的对象将被整理，按照内存地址依次排列，未被标记的内存会被清理。</strong> 所以，当我们需要给新对象分配内存时，JVM只需要持有一个内存起始地址即可，这比维护空闲列表少很多开销</p>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>清除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其它对象引用，则还需要调整引用 的地址。</li>
<li>移动过程中，需要全程暂停用户应用程序，即：STW。</li>
</ul>
<h4 id="对比三种算法"><a href="#对比三种算法" class="headerlink" title="对比三种算法"></a>对比三种算法</h4><p><img src="/2021/04/24/jvm/image-20201209213604959.png" alt="image-20201209213604959"></p>
<p>清除算法和压缩算法完整的过程是：识别-&gt;标记-&gt;遍历清除未标记对象；而复制算法是：识别-&gt;复制被GCroot引用的对象-&gt;直接置空原区域</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><blockquote>
<p>没有一种算法可以代替其它算法，他们都有自己独特的优势和特点。分代收集算法应运而生。</p>
</blockquote>
<p>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采用不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务有关，比如：<strong>http请求中的Session对象、线程、Socket连接</strong>，<strong>这类对象跟业务直接挂钩，因此生命周期比较长</strong>。但是，还有一些对象，主要是<strong>程序运行过程中生成的临时变量，这些对象生命周期会比较短</strong>，比如：<strong>String对象，由于其不变的特性，系统会产生大量的这些对象，有些对象甚至只用一次就可回收。</strong></p>
<p>==注意：==目前<strong>几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的</strong>。</p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代的特点。</p>
<ul>
<li><p><strong>年轻代特点</strong>：<strong>区域相对老年代较小，对象生命周期短、存活率低、回收频繁；这种情况复制算法的回收整理，速度是最快的。</strong>复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到解决。</p>
</li>
<li><p><strong>老年代特点</strong>：<strong>区域较大，生命周期长，存活率高，回收频率不及年轻代。</strong>这种情况存在大量存活率高的对象，复制算法明显不合适，<strong>一般用标记-清除算法或者标记-清除和标记-压缩算法的混合实现</strong>。</p>
<ul>
<li>mark阶段的开销与存活对象数量成正比；</li>
<li>Sweep阶段的开销与管理区域大小成正比；</li>
<li>Compact阶段的开销与存活对象成正比。</li>
</ul>
</li>
</ul>
<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old 执行Full GC以达到对老年代整理的目的。</p>
<h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>现有算法，在垃圾回收过程中，应用软件将处于一种<strong>Stop the World</strong> 的状态。<strong>在Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。</strong>如果垃圾回收时间过长，应用程序会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p><strong>基本思想</strong></p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</strong></p>
<p><strong>缺点</strong></p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，<strong>因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</strong></p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次GC所需要的时间越长，有关GC产生的停顿越长。为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC停顿的时间。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，<strong>分区算法将整个堆空间划分成连续的不同小区间。</strong></p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是<strong>可以控制一次回收多少个小区间。</strong></p>
<p><strong>图解</strong></p>
<p><img src="/2021/04/24/jvm/image-20201211161610113.png" alt="image-20201211161610113"></p>
<p>==注意：== 目前发展中的前沿GC都是复合算法，且并行与并发兼备</p>
<h3 id="6-5、垃圾回收相关概念"><a href="#6-5、垃圾回收相关概念" class="headerlink" title="6.5、垃圾回收相关概念"></a>6.5、垃圾回收相关概念</h3><h4 id="6-5-1、System-gc-的理解"><a href="#6-5-1、System-gc-的理解" class="headerlink" title="6.5.1、System.gc( )的理解"></a>6.5.1、System.gc( )的理解</h4><blockquote>
<p>默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显示的出发Full GC，同时对老年代与新生代进行回收，尝试释放被丢弃对象占用的内存</p>
</blockquote>
<p><strong>System.gc( ) 的底层就是Runtime.getRuntime().gc()</strong></p>
<p>System.gc( ) 调用附带一个免责声明，无法保证对垃圾收集器的调用。即仅仅是提醒，不能保证垃圾收集的具体执行时间</p>
<p>一般垃圾回收都是自动进行的，在一些特殊情况下才会手动通过System.gc() 调用垃圾回收。如 正在编写一个性能基准时</p>
<h4 id="6-5-2、内存溢出和内存泄漏"><a href="#6-5-2、内存溢出和内存泄漏" class="headerlink" title="6.5.2、内存溢出和内存泄漏"></a>6.5.2、内存溢出和内存泄漏</h4><h5 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h5><p><strong>概述</strong></p>
<ul>
<li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li>
</ul>
<ul>
<li>由于GC一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况；</li>
</ul>
<ul>
<li>大多数情况下，GC会进行各年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li>
</ul>
<ul>
<li>javadoc中对OutOfMemoryError的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</li>
</ul>
<p><strong>没有内存原因？</strong></p>
<blockquote>
<p>首先说没有空闲内存的情况，Java虚拟机堆内存不够，原因有二：</p>
</blockquote>
<ul>
<li><p><strong>Java虚拟机的堆内存设置不够</strong></p>
</li>
<li><p>比如：可能存在内存泄漏问题，也很有可能就是堆的大小不合理，比如我们要处理可观的数据量，但是，没有显示指定JVM堆大小或者指定数值偏小，我们可以通过-Xms、-Xmx来调整。</p>
</li>
<li><p><strong>代码中创建了大量对象，并且长时间不能被垃圾收集器收集（存在引用）；</strong></p>
<ul>
<li><p>对于老版本的Oracle JDK,因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如：常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息会标记出来和永久代有关：<code>“java.lang.OutOfMemeoryError:PermGen space”</code></p>
</li>
<li><p>随着元数据区的引入，方法区内存不再那么窘迫，所以相应的OOM有所改观，出现的异常信息变成了：<code>“java.lang.OutOfMemoryError:Metaspace”</code>。直接内存不足也会导致OOM。</p>
</li>
</ul>
</li>
</ul>
<p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理空间。</p>
<ol>
<li>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ol>
<p>当然，也不是在任何情况下垃圾收集器都会被触发。</p>
<ol>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError.</li>
</ol>
<h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p><strong>概述</strong></p>
<p>也称作“存储泄漏”。<strong>严格来说，只有对象不会再被程序用到了，但是GC又不能回收它们的情况，才叫内存泄漏。</strong></p>
<p>实际情况，很多时候一些不太友好的实践（或疏忽）会导致对象的生命周期变得很长，甚至导致OOM，也可以叫做<strong>宽泛意义上的“内存泄漏”</strong>。</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是，一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。</p>
<p>注意：这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘区交换设定的大小。</p>
<p><strong>图解</strong></p>
<p><img src="/2021/04/24/jvm/image-20201211173159360.png" alt="image-20201211173159360"></p>
<p><strong>例</strong></p>
<p>例一：单例模式</p>
<p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
<p>例二：一些提供close的资源未关闭导致内存泄漏</p>
<p>数据库连接（dataSource.getConnection()）,网络连接（socket）和IO连接必须手动Close（），否则是不能被回收的。</p>
<h4 id="6-5-3、Stop-The-World"><a href="#6-5-3、Stop-The-World" class="headerlink" title="6.5.3、Stop The World"></a>6.5.3、Stop The World</h4><blockquote>
<p>Stop-The-World ，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何相应，</strong>有点像卡死的感觉，这个停顿称为STW。</p>
</blockquote>
<p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p>
<ol>
<li>分析工作必须在一个能确保一致性的快照中进行。</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上。</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。</strong></li>
</ol>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成卡带一样，所以我们需要减少STW的发生。</p>
<p>==注意：==</p>
<ul>
<li><p>STW和采用哪款GC无关，所有的GC都有这个事件。</p>
</li>
<li><p>哪怕是G1也不能完全避免Stop-The-World情况的发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常工作的线程全部停掉。</p>
</li>
<li><p>开发中不要用System.gc(),会导致Stop-The-World的发生。</p>
</li>
</ul>
<h4 id="6-5-4、垃圾回收的并行与并发"><a href="#6-5-4、垃圾回收的并行与并发" class="headerlink" title="6.5.4、垃圾回收的并行与并发"></a>6.5.4、垃圾回收的并行与并发</h4><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h5><p><img src="/2021/04/24/jvm/image-20201211202000137.png" alt="image-20201211202000137"></p>
<p>图解</p>
<p><img src="/2021/04/24/jvm/image-20201211202015897.png" alt="并发图解"></p>
<h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a><strong>并行</strong></h5><blockquote>
<p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行</p>
</blockquote>
<p>==注意：==</p>
<ul>
<li>其实决定并行的因素并不是CPU的数量，而是CPU的核心数量，比如一个CPU多核也可以并行</li>
<li>适合科学计算，后台处理等弱交互场景</li>
</ul>
<p>图解</p>
<p><img src="/2021/04/24/jvm/image-20201211202712630.png" alt="并行图示"></p>
<p><strong>并发/并行区别</strong></p>
<p><img src="/2021/04/24/jvm/image-20201211202911595.png" alt="image-20201211202911595"></p>
<h5 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a><strong>垃圾回收的并发与并行</strong></h5><p>并发与并行，在谈论垃圾收集器的上下文语境中，可以解释如下：</p>
<ul>
<li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此用户线程仍处于等待状态。<ul>
<li>如 ParNew、Parallel Scavenge、Parallel Old</li>
</ul>
</li>
<li><strong>串行（Serial）</strong><ul>
<li>相较于并行的概念，单线程执行</li>
<li>如果内存不足，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/24/jvm/image-20201211203838984.png" alt="image-20201211203838984"></p>
<p><img src="/2021/04/24/jvm/image-20201211203851368.png" alt="image-20201211203851368"></p>
<ul>
<li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能是交替进行），垃圾回收线程在执行时不会停顿用户程序的运行</p>
<ul>
<li>用户程序再继续运行，而垃圾收集程序线程 运行在另一个CPU上</li>
<li>如：CMS 、 G1</li>
</ul>
<p><img src="/2021/04/24/jvm/image-20201211204517387.png" alt="image-20201211204517387"></p>
</li>
</ul>
<h4 id="6-5-5、安全点与安全区域"><a href="#6-5-5、安全点与安全区域" class="headerlink" title="6.5.5、安全点与安全区域"></a>6.5.5、安全点与安全区域</h4><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><blockquote>
<p>程序只能在特定的位置停顿下来开始GC，这些位置称为“<strong>安全点</strong>”</p>
</blockquote>
<p><strong>Safe Point</strong> 选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。</strong>大部分指令的执行时间都非常短暂、通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为<strong>Safe Point</strong>，如<strong>方法调用、循环跳转和异常跳转</strong>等。</p>
<p><img src="/2021/04/24/jvm/image-20201211210127002.png" alt="image-20201211210127002"></p>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>SafePoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？如线程处于Sleep状态或Blocked状态，这时 候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。这种情况，就需要安全区域（Safe Region）来解决。</p>
<p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。</strong></p>
<p><strong>实际执行时</strong>：</p>
<p><img src="/2021/04/24/jvm/image-20201211211016183.png" alt="image-20201211211016183"></p>
<h4 id="6-5-6、引用"><a href="#6-5-6、引用" class="headerlink" title="6.5.6、引用"></a>6.5.6、引用</h4><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这<strong>4种引用强度依次逐渐减弱</strong>。</p>
<p>除强引用外，其他三种引用均可在java.lang.ref包中找到他们的身影。如图</p>
<p><img src="/2021/04/24/jvm/image-20201214103147146.png" alt="image-20201214103147146"></p>
<ul>
<li><strong>强引用（StrongReference）</strong>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Objectd）”这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li>
<li><strong>软引用（SoftReference）</strong>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。 （内存不足，才回收）</li>
<li><strong>弱引用（WeakReference）</strong>：被弱引用关联的对象只能生存到下一次垃圾收集之前。<strong>当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</strong>（发现即回收）</li>
<li><strong>虚引用（PhantomReference）</strong>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置<strong>虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></li>
</ul>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><blockquote>
<p>（StrongReference）不死不回收</p>
</blockquote>
<p>最常见的引用方式，（<strong>普通系统99%都是强引用</strong>），默认的引用类型。</p>
<p>当Java语言中使用new操作符创建一个对象，并将其赋值给一个变量时，这个变量就成为指向该对象的一个强引用。</p>
<p><strong>强引用的对象时可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过引用的作用域或者显示地将相应（强）引用赋值为null，就可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p><img src="/2021/04/24/jvm/image-20201214110226917.png" alt="image-20201214110226917"></p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><blockquote>
<p>（SoftReference）内存不足即回收</p>
</blockquote>
<p>用来描述一些还有用，但非必须的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果此次回收仍然内存不足，才会抛出内存溢出异常</p>
<p><strong>软引用通常用来实现内存敏感的缓存</strong>。比如：高速缓存，如果还用空闲内存，就可以暂时保留缓存，但内存不足时清理掉，保证了使用缓存的同时又不会耗尽内存</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列。</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><blockquote>
<p>（Weak Reference ）发现即回收</p>
</blockquote>
<p>用来描述那些非必须对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</strong>在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</p>
<p>但是，由于垃圾回收线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象，在这种情况下，<strong>弱引用对象可能存在较长的时间。</strong></p>
<p>弱引用和软引用一样，在构造弱引用是，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通常这个队列可以跟踪对象的回收情况。</p>
<p><strong>软引用、弱引用都非常适合来保存哪些可有可无的缓存数据。</strong></p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><blockquote>
<p>（Phantom Reference）对象回收跟踪</p>
</blockquote>
<p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是nul1。</p>
<p><img src="/2021/04/24/jvm/image-20201226150313229.png" alt="image-20201226150313229"></p>
<h5 id="终接器引用"><a href="#终接器引用" class="headerlink" title="终接器引用"></a>终接器引用</h5><p>它用以实现对象的finalize（）方法，也可以称为终结器引用。</p>
<p>无需手动编码，其内部配合引用队列使用。</p>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize（）方法，第二次Gc时才能回收被引用对象。</p>
<h3 id="6-6、垃圾回收器"><a href="#6-6、垃圾回收器" class="headerlink" title="6.6、垃圾回收器"></a>6.6、垃圾回收器</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</li>
<li>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</li>
<li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>1、按<strong>线程数</strong>分：串行垃圾回收器和并行垃圾回收器</p>
<p><img src="/2021/04/24/jvm/image-20201226161021888.png" alt="image-20201226161021888"></p>
<ul>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的Client模式下的JVM中</strong></li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
</li>
<li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</li>
</ul>
<p>2、按<strong>工作模式</strong>分：并发式垃圾回收器和独占式垃圾回收器</p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="/2021/04/24/jvm/image-20201226161806507.png" alt="image-20201226161806507"></p>
<p>3、按<strong>碎片处理方式</strong>分：压缩式垃圾回收器和非压缩式垃圾回收器</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。<ul>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式的垃圾回收器不进行这步操作。<ul>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
<p>4、按<strong>工作内存区间</strong>分：年轻代垃圾回收器和老年代垃圾回收器</p>
<h4 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h4><ul>
<li><strong>吞吐量：运行用户代码的时间占总运行时间的比例</strong><ul>
<li>总运行时间：用户代码运行时间 + 内存回收时间</li>
</ul>
</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行的比例</li>
<li><strong>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</strong></li>
<li>收集频率：相对于应用程序的执行，手机操作发生的频率</li>
<li><strong>内存占用：Java堆区所占的内存大小</strong></li>
<li>快速：一个对象从诞生到被回收所经历的时间</li>
</ul>
<h5 id="吞吐量-throu"><a href="#吞吐量-throu" class="headerlink" title="吞吐量(throu)"></a>吞吐量(throu)</h5><p>指的是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 &#x3D; 运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比如：虚拟机总共运行了180分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
</blockquote>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4</p>
<p><img src="/2021/04/24/jvm/image-20201227151136642.png" alt="image-20201227151136642"></p>
<h5 id="暂停时间-pause-time"><a href="#暂停时间-pause-time" class="headerlink" title="暂停时间(pause time)"></a>暂停时间(pause time)</h5><p>指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p>
<blockquote>
<p>比如，GC期间100毫秒的暂停时间意味着在这1ee毫秒期间内没有应用程序线程是活动的。</p>
</blockquote>
<p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1+0.1+0.1+0.1=0.5</p>
<p><img src="/2021/04/24/jvm/image-20201227151207233.png" alt="image-20201227151207233"></p>
<h5 id="吞吐量VS暂停时间"><a href="#吞吐量VS暂停时间" class="headerlink" title="吞吐量VS暂停时间"></a>吞吐量VS暂停时间</h5><p><img src="/2021/04/24/jvm/image-20201227151756253.png" alt="image-20201227151756253"></p>
<p>在设计（或使用）GC算法时，我们必须确定我们的<strong>目标</strong>：一<strong>个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间）</strong>，<strong>或尝试找到一个二者的折衷</strong>。</p>
<p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong>。</p>
<h4 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h4><p><img src="/2021/04/24/jvm/image-20201227153424398.png" alt="image-20201227153424398"></p>
<blockquote>
<p>7款经典垃圾收集器与垃圾分代之间的关系</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201227154131529.png" alt="image-20201227154131529"></p>
<blockquote>
<p>垃圾收集器的组合关系</p>
</blockquote>
<p><img src="/2021/04/24/jvm/image-20201227154300730.png" alt="image-20201227154300730"></p>
<p><img src="/2021/04/24/jvm/image-20201227155058820.png" alt="image-20201227155058820"></p>
<h5 id="如何查看默认的垃圾收集器"><a href="#如何查看默认的垃圾收集器" class="headerlink" title="如何查看默认的垃圾收集器?"></a><strong>如何查看默认的垃圾收集器?</strong></h5><p>1、<code>-XX:+PrintCommandLineFlags</code>: 查看命令行参数（包含使用的垃圾收集器）</p>
<p>2、使用命令行指令:  <code>jinfo  -flag  相关垃圾收集器参数  进程ID</code></p>
<h5 id="Serial和Serial-Old回收器"><a href="#Serial和Serial-Old回收器" class="headerlink" title="Serial和Serial Old回收器"></a>Serial和Serial Old回收器</h5><blockquote>
<p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。</p>
</blockquote>
<p>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</p>
<p>Serial o1d是运行在client模式下默认的老年代的垃圾回收器</p>
<p>==<strong>机制：</strong>==</p>
<p><strong>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</strong></p>
<p><strong>Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</strong></p>
<blockquote>
<p>Serial old在Server模式下主要有两个用途：</p>
</blockquote>
<p>①与新生代的Parallel Scavenge配合使用</p>
<p>②作为老年代CMS收集器的后备垃圾收集方案</p>
<p>图示</p>
<p><img src="/2021/04/24/jvm/image-20201227162953548.png" alt="image-20201227162953548"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<strong>只会使用一个CPU或者一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程，</strong>直到它收集结束（Stop The World）</p>
<p><strong>优势</strong>：<strong>简单而高效</strong>（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在client模式下的虚拟机是个不错的选择。</li>
</ul>
<p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p><strong>设置</strong></p>
<p>在Hotspot虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。</p>
<ul>
<li>等价于新生代用SerialGC，且老年代用Serial old GC</li>
</ul>
<p><strong>总结</strong></p>
<p>这种垃圾收集器大家了解就行，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>
<h5 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h5><blockquote>
<p>并行回收</p>
</blockquote>
<p>ParNew收集器相当于Serial收集器的多线程版本</p>
<ul>
<li>Par 是 Parallel 的缩写，New：只能处理的是新生代</li>
</ul>
<p>ParNew收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，其他方面和Serial收集器几乎没有任何区别。ParNew收集器在年轻代中同样也是<strong>采用复制算法、“Stop-the-World”</strong>机制。</p>
<p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
<p><img src="/2021/04/24/jvm/image-20201227195843161.png" alt="image-20201227195843161"></p>
<ul>
<li><p>对于新生代，回收次数频繁，使用并行方式高效</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换是线程，串行可以省去切换线程的资源）</p>
</li>
</ul>
<p><strong>面试题</strong></p>
<blockquote>
<p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p>
</blockquote>
<ul>
<li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
<p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>
<p><strong>设置</strong></p>
<p><code>-XX:+UseParNewGC</code>指定使用ParNew收集器执行内存回收任务。表示年轻代使用ParNew并行收集器，不影响老年代</p>
<p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和CPU相同的线程数</p>
<h5 id="Parallel-Scavenge和Parallel-Old回收器"><a href="#Parallel-Scavenge和Parallel-Old回收器" class="headerlink" title="Parallel Scavenge和Parallel Old回收器"></a>Parallel Scavenge和Parallel Old回收器</h5><blockquote>
<p>Java 8中，默认的垃圾收集器</p>
</blockquote>
<p><strong>Parallel Scavenge回收器</strong></p>
<blockquote>
<p>吞吐量优先</p>
</blockquote>
<p>Parallel Scavenge收集器和ParNew收集器一样是采用了<strong>复制算法、并行回收和“Stop the World”机制。</strong></p>
<p><strong>Parallel Old回收器</strong></p>
<p>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的<strong>Parallel Old收集器</strong>，用来代替老年代的Serial Old收集器，采用了<strong>标记-压缩算法</strong>，<strong>基于并行回收和”stop-the-World”机制</strong>。</p>
<blockquote>
<p>既然有了ParNew，那么Parallel收集器的出现是否是多此一举？</p>
</blockquote>
<ul>
<li><p>和ParNew收集器不同， parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），他也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li><p><strong>自适应调节策略</strong>也是Parrallel Scavenge与ParNew的一个重要区别</p>
</li>
</ul>
<p><strong>使用场景</strong></p>
<p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要<strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。<strong>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</strong></p>
<p><strong>设置</strong></p>
<p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用Parallel并行收集器执行内存回收任务</p>
<p><code>-XX:+UseParallelOldGC</code>手动指定老年代使用并行回收收集器。</p>
<ul>
<li>上面两个参数，默认开启一个，另一个也会被开启。（相互激活）。默认JDK8是开启的</li>
</ul>
<p><code>-XX:+ParallelGCThreads</code>设置年轻代并行收集器的线程数。一般的最好和CPU数相等，以避免过多的线程数影响垃圾收集的性能</p>
<ul>
<li>默认情况下，当CPU数量小于8个，parallelGCThreads的值等于CPU数量</li>
<li>当CPU数量大于8个，ParallelGCThreads的值等于<code>3+[5*CPU_Count]/8</code></li>
</ul>
<p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p>
<ul>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Paralle1，进行控制。</li>
<li>该参数使用需谨慎。</li>
</ul>
<p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例  1/(N+1)。</p>
<ul>
<li>用于衡量吞吐量的大小。</li>
<li>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1s。</li>
<li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li>
</ul>
<p><code>-XX:+UseAdaptiveSizePolicy</code> 设置Parallel Scavenge收集器具有自适应调节策略</p>
<ul>
<li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMi11s），让虚拟机自己完成调优工作。</li>
</ul>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年04月23日 21:30</p>
        <p>原始链接： <a class="post-url" href="/2021/04/24/jvm/" title="深入理解JVM虚拟机---类加载、内存区域、GC">http://javacoderx.github.io/2021/04/24/jvm/</a></p>
        <footer>
            <a href="http://javacoderx.github.io">
                <img src="/images/logo.png" alt="xyc">
                xyc
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://javacoderx.github.io/2021/04/24/jvm/&title=《深入理解JVM虚拟机---类加载、内存区域、GC》 — 太阳以西？&pic=https://picsum.photos/200/300?grayscale" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://javacoderx.github.io/2021/04/24/jvm/&title=《深入理解JVM虚拟机---类加载、内存区域、GC》 — 太阳以西？&source=专注 WEB 开发的技术博客" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://javacoderx.github.io/2021/04/24/jvm/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《深入理解JVM虚拟机---类加载、内存区域、GC》 — 太阳以西？&url=http://javacoderx.github.io/2021/04/24/jvm/&via=http://javacoderx.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://javacoderx.github.io/2021/04/24/jvm/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://javacoderx.github.io/2021/04/24/jvm/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/jvm/" class="color4">jvm</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap" style="overflow:scroll">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="post-toc-text">1、类加载器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="post-toc-text">1.1、类加载的过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="post-toc-text">1.2、类加载器的分类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-1%E3%80%81%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="post-toc-text">1.2.1、引导类加载器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-2%E3%80%81%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="post-toc-text">1.2.2、扩展类加载器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-3%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="post-toc-text">1.2.3、应用程序类加载器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-4%E3%80%81%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="post-toc-text">1.2.4、用户自定义类加载器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3%E3%80%81ClassLoader%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="post-toc-text">1.3、ClassLoader类的常用方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="post-toc-text">1.4、双亲委派机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5%E3%80%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="post-toc-text">1.5、类的使用方式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="post-toc-text">2、运行时数据区</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="post-toc-text">2.1、程序计数器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2%E3%80%81Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="post-toc-text">2.2、Java虚拟机栈</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-1%E3%80%81%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="post-toc-text">2.2.1、栈的存储单位</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-2%E3%80%81%E6%A0%88%E5%B8%A7%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="post-toc-text">2.2.2、栈帧的存储结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="post-toc-text">1、局部变量表</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="post-toc-text">2、操作数栈</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="post-toc-text">3、动态链接</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="post-toc-text">4、方法的调用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#5%E3%80%81%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="post-toc-text">5、方法返回地址</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#6%E3%80%81%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="post-toc-text">6、附加信息</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="post-toc-text">2.3、本地方法栈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4%E3%80%81%E5%A0%86"><span class="post-toc-text">2.4、堆</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="post-toc-text">2.4.1、概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-2%E3%80%81%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%86%E5%88%86"><span class="post-toc-text">2.4.2、堆内存细分</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-3%E3%80%81%E8%AE%BE%E7%BD%AE%E5%A0%86%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="post-toc-text">2.4.3、设置堆空间大小</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-4%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="post-toc-text">2.4.4、新生代与老年代</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-5%E3%80%81%E5%9B%BE%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="post-toc-text">2.4.5、图解对象分配过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-6%E3%80%81%E5%8C%BA%E5%88%86Minor-GC-Y-GC-%E3%80%81Major-GC%E3%80%81Full-GC"><span class="post-toc-text">2.4.6、区分Minor GC(Y GC) 、Major GC、Full GC</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-7%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="post-toc-text">2.4.7、内存分配策略</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B-TLAB"><span class="post-toc-text">2.4.8、对象分配过程 TLAB</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-9%E3%80%81%E5%A0%86%E7%A9%BA%E9%97%B4%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="post-toc-text">2.4.9、堆空间常用参数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-10%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="post-toc-text">2.4.10、逃逸分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="post-toc-text">2.5、方法区</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5-1%E3%80%81%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="post-toc-text">2.5.1、理解方法区</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5-2%E3%80%81%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="post-toc-text">2.5.2、设置方法区</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5-3%E3%80%81%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="post-toc-text">2.5.3、内部结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="post-toc-text">类型信息</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%9F%9F%EF%BC%88field%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="post-toc-text">域（field）信息</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="post-toc-text">方法（Method）信息</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#non-final%E7%9A%84%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="post-toc-text">non-final的类变量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#class%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="post-toc-text">class文件中常量池</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="post-toc-text">运行时常量池</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="post-toc-text">从字节码文件理解方法区</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E5%8F%98"><span class="post-toc-text">方法区的演变</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6%E3%80%81%E6%80%BB%E7%BB%93"><span class="post-toc-text">2.6、总结</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-7%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="post-toc-text">2.7、常见面试题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="post-toc-text">3、对象的实例化、内存布局与访问定位</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="post-toc-text">3.1、对象的实例化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="post-toc-text">3.2、对象的内存布局</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="post-toc-text">3.3、对象的访问定位</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="post-toc-text">3.4、直接内存</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="post-toc-text">4、执行引擎</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="post-toc-text">4.1、概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2%E3%80%81%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="post-toc-text">4.2、工作过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3"><span class="post-toc-text">4.3、机器码、指令、汇编、高级语言理解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="post-toc-text">机器码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="post-toc-text">指令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="post-toc-text">汇编语言</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="post-toc-text">高级语言</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="post-toc-text">字节码</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-4%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="post-toc-text">4.4、解释器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-5%E3%80%81JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="post-toc-text">4.5、JIT编译器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="post-toc-text">热点代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="post-toc-text">方法调用计数器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="post-toc-text">回边计数器</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5%E3%80%81StringTable"><span class="post-toc-text">5、StringTable</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-1%E3%80%81String%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="post-toc-text">5.1、String的基本特性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2%E3%80%81String%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="post-toc-text">5.2、String的内存分配</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3%E3%80%81String%E7%9A%84%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="post-toc-text">5.3、String的拼接操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4%E3%80%81intern-%E6%96%B9%E6%B3%95"><span class="post-toc-text">5.4、intern( ) 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-5%E3%80%81G1%E7%9A%84String%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="post-toc-text">5.5、G1的String去重操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="post-toc-text">6、垃圾收集</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%EF%BC%9F"><span class="post-toc-text">6.1、什么是垃圾？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2%E3%80%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="post-toc-text">6.2、大厂面试题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="post-toc-text">6.3、垃圾回收机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="post-toc-text">6.4、垃圾回收算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="post-toc-text">引用计数算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="post-toc-text">可达性分析算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#finalization%E6%9C%BA%E5%88%B6"><span class="post-toc-text">finalization机制</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="post-toc-text">标记清除算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="post-toc-text">复制算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="post-toc-text">标记整理\压缩算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="post-toc-text">对比三种算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="post-toc-text">分代收集算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="post-toc-text">增量收集算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="post-toc-text">分区算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-5%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="post-toc-text">6.5、垃圾回收相关概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-5-1%E3%80%81System-gc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="post-toc-text">6.5.1、System.gc( )的理解</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-5-2%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="post-toc-text">6.5.2、内存溢出和内存泄漏</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88OOM%EF%BC%89"><span class="post-toc-text">内存溢出（OOM）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="post-toc-text">内存泄漏</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-5-3%E3%80%81Stop-The-World"><span class="post-toc-text">6.5.3、Stop The World</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-5-4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="post-toc-text">6.5.4、垃圾回收的并行与并发</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="post-toc-text">并发</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="post-toc-text">并行</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="post-toc-text">垃圾回收的并发与并行</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-5-5%E3%80%81%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="post-toc-text">6.5.5、安全点与安全区域</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9"><span class="post-toc-text">安全点</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="post-toc-text">安全区域</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-5-6%E3%80%81%E5%BC%95%E7%94%A8"><span class="post-toc-text">6.5.6、引用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="post-toc-text">强引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="post-toc-text">软引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="post-toc-text">弱引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="post-toc-text">虚引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BB%88%E6%8E%A5%E5%99%A8%E5%BC%95%E7%94%A8"><span class="post-toc-text">终接器引用</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-6%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="post-toc-text">6.6、垃圾回收器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E7%B1%BB"><span class="post-toc-text">分类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%84%E4%BC%B0GC%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="post-toc-text">评估GC的性能指标</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F-throu"><span class="post-toc-text">吞吐量(throu)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4-pause-time"><span class="post-toc-text">暂停时间(pause time)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8FVS%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4"><span class="post-toc-text">吞吐量VS暂停时间</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7%E6%AC%BE%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="post-toc-text">7款经典的垃圾收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="post-toc-text">如何查看默认的垃圾收集器?</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Serial%E5%92%8CSerial-Old%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="post-toc-text">Serial和Serial Old回收器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ParNew%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="post-toc-text">ParNew回收器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Parallel-Scavenge%E5%92%8CParallel-Old%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="post-toc-text">Parallel Scavenge和Parallel Old回收器</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2021/04/24/openjdk/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          带你手动编译openjdk
        
      </span>
    </a>
  
  
    <a href="/2021/04/24/springboot/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">springboot零基础入门篇</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 xyc<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "http://javacoderx.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/docker/">docker</a><a class="category-link" href="/categories/jvm/">jvm</a><a class="category-link" href="/categories/openjdk/">openjdk</a><a class="category-link" href="/categories/springboot/">springboot</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/openjdk/" style="font-size: 10px;">openjdk</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/openjdk/" style="font-size: 10px;">openjdk</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>